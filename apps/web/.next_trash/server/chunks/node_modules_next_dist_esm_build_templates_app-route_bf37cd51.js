module.exports=[602963,e=>{"use strict";var t=e.i(747909),r=e.i(174017),a=e.i(996250),n=e.i(759756),s=e.i(561916),i=e.i(174677),o=e.i(869741),l=e.i(316795),d=e.i(487718),u=e.i(995169),c=e.i(47587),_=e.i(666012),h=e.i(570101),p=e.i(626937),m=e.i(10372),g=e.i(193695);e.i(52474);var f=e.i(600220),x=e.i(89171),E=e.i(843793),R=e.i(300959),y=e.i(583627),b=e.i(184883),w=e.i(56778),S=e.i(901323);function v(e){return String(e||"").trim().toLowerCase()}let A=w.ethers.id("Transfer(address,address,uint256)"),N=new w.ethers.Interface(["event Transfer(address indexed from, address indexed to, uint256 value)"]);async function O(e,t){let r=String(t??"").trim();if(!r)return null;try{let t=await e.getCode(r);if(!t)return null;return"0x"!==String(t).toLowerCase()}catch{return null}}function T(e,t,r){return Number.isFinite(e)?Math.max(t,Math.min(r,Math.trunc(e))):t}async function C(e){let t,r=(0,E.getSql)(),a=await (0,y.requireAdminForApi)(r,e);if(!a.ok)return a.response;let n=new URL(e.url),s=(n.searchParams.get("chain")??"bsc").trim().toLowerCase(),i=n.searchParams.get("address")??"",o=(n.searchParams.get("tx_hash")??n.searchParams.get("tx")??"").trim(),l=v(i),d=T(Number(n.searchParams.get("limit")??"20"),1,200);if("bsc"!==s)return x.NextResponse.json({ok:!1,error:"unsupported_chain",hint:"Only chain=bsc is supported right now."},{status:400});if(!l&&!o)return x.NextResponse.json({ok:!1,error:"missing_query",hint:"Provide address=0x... and/or tx_hash=0x..."},{status:400});if(o&&(t=String(o||"").trim(),!/^0x[0-9a-fA-F]{64}$/.test(t)))return x.NextResponse.json({ok:!1,error:"invalid_tx_hash"},{status:400});try{let e,t=(0,S.getBscReadProvider)(),a=T((e=Number(String(process.env.BSC_DEPOSIT_CONFIRMATIONS??"").trim()),Number.isFinite(e)?Math.trunc(e):2),0,200),[n,s,i]=await Promise.all([t.getBlockNumber(),(0,b.retryOnceOnTransientDbError)(async()=>(await r`
          SELECT last_scanned_block
          FROM ex_chain_deposit_cursor
          WHERE chain = 'bsc'
          LIMIT 1
        `)[0]??null),(async()=>{if(!o)return null;let e=await t.getTransactionReceipt(o),r=await t.getTransaction(o);if(!e&&!r)return{found:!1};let a=r?.to?v(r.to):"",n="bigint"==typeof r?.value?r.value:0n;return{found:!0,tx_hash:o,status:"number"==typeof e?.status?e.status:null,block_number:e?.blockNumber!=null?Number(e.blockNumber):null,from:r?.from?v(r.from):null,to:a||null,value_wei:n.toString(),receipt:e}})()]),u=v(l||(i&&i.found&&i.to?i.to:"")),c=i&&i.found&&i.to?await O(t,String(i.to)):null,_=Math.max(0,n-a),h=s?Number(s.last_scanned_block??0):0,p=Math.max(0,_-h),m=u?await (0,b.retryOnceOnTransientDbError)(async()=>(await r`
            SELECT user_id::text AS user_id, address, status, created_at::text AS created_at
            FROM ex_deposit_address
            WHERE chain = 'bsc'
              AND lower(address) = ${u}
            LIMIT 1
          `)[0]??null):null,g=await (0,b.retryOnceOnTransientDbError)(async()=>o?await r`
          SELECT
            e.id,
            e.chain,
            e.tx_hash,
            e.log_index,
            e.block_number,
            e.from_address,
            e.to_address,
            e.user_id::text AS user_id,
            e.asset_id::text AS asset_id,
            a.symbol AS asset_symbol,
            e.amount::text AS amount,
            e.journal_entry_id::text AS journal_entry_id,
            e.created_at::text AS created_at
          FROM ex_chain_deposit_event e
          JOIN ex_asset a ON a.id = e.asset_id
          WHERE e.chain = 'bsc'
            AND e.tx_hash = ${o}
          ORDER BY e.log_index ASC
          LIMIT ${d}
        `:await r`
        SELECT
          e.id,
          e.chain,
          e.tx_hash,
          e.log_index,
          e.block_number,
          e.from_address,
          e.to_address,
          e.user_id::text AS user_id,
          e.asset_id::text AS asset_id,
          a.symbol AS asset_symbol,
          e.amount::text AS amount,
          e.journal_entry_id::text AS journal_entry_id,
          e.created_at::text AS created_at
        FROM ex_chain_deposit_event e
        JOIN ex_asset a ON a.id = e.asset_id
        WHERE e.chain = 'bsc'
          AND lower(e.to_address) = ${u}
        ORDER BY e.block_number DESC, e.id DESC
        LIMIT ${d}
      `),f=Array.from(new Set(g.map(e=>e.journal_entry_id).filter(Boolean))),E=f.length?await (0,b.retryOnceOnTransientDbError)(async()=>await r`
            SELECT
              jl.entry_id::text AS entry_id,
              jl.account_id::text AS account_id,
              la.user_id::text AS user_id,
              jl.asset_id::text AS asset_id,
              jl.amount::text AS amount
            FROM ex_journal_line jl
            JOIN ex_ledger_account la ON la.id = jl.account_id
            WHERE jl.entry_id = ANY(${f}::uuid[])
            ORDER BY jl.entry_id ASC, jl.amount DESC
          `):[],R=g.some(e=>!!e.journal_entry_id),y=m?v(m.address):u,C=!!(i&&i.found&&i.to&&v(String(i.to))===y&&BigInt(String(i.value_wei??"0"))>0n),k=[];try{let e=i?.receipt;if(e&&Array.isArray(e.logs)&&y){for(let t of e.logs)if(String(t?.topics?.[0]??"")===A)try{let e=N.decodeEventLog("Transfer",t.data,t.topics),r=e?.to?v(String(e.to)):"";if(!r||r!==y)continue;let a="bigint"==typeof e?.value?e.value:0n;if(a<=0n)continue;k.push({contract:v(String(t.address??"")),value_wei:a.toString(),log_index:"number"==typeof t?.logIndex?t.logIndex:null})}catch{}}}catch{}let I=Array.from(new Set(k.map(e=>e.contract).filter(Boolean))),D=I.length?await (0,b.retryOnceOnTransientDbError)(async()=>await r`
            SELECT symbol, decimals, contract_address
            FROM ex_asset
            WHERE chain = 'bsc'
              AND contract_address IS NOT NULL
              AND lower(contract_address) = ANY(${I})
          `):[],P=new Map;for(let e of D)P.set(v(e.contract_address),{symbol:e.symbol,decimals:e.decimals});let M=k.map(e=>{let t=P.get(e.contract),r=t?.decimals??18,a=w.ethers.formatUnits(BigInt(e.value_wei),r);return{kind:"token",asset_symbol:t?.symbol??"UNKNOWN",contract:e.contract,amount:a,log_index:e.log_index}}),j=C?[{kind:"native",asset_symbol:"BNB",amount:(()=>{try{let e=BigInt(String(i?.value_wei??"0"));return w.ethers.formatEther(e)}catch{return"0"}})(),log_index:null}]:[],L=y&&(j.length>0||M.length>0||g.length>0)?R?"credited":g.length>0?"seen":"pending":"not_ours",H="number"==typeof i?.status?i.status:null,U=0===H?{kind:"reverted_tx",message:"This transaction reverted on-chain (status=0), so it did not complete."}:"not_ours"!==L||!i?.receipt||j.length>0||M.length>0||g.length>0?null:i?.to?!0===c?{kind:"contract_interaction_no_transfer_logs",tx_to_is_contract:!0,message:"Tx interacts with a contract and has no Transfer logs to the deposit address. Internal transfers may not be detectable without trace APIs."}:{kind:"no_matching_transfers",message:"No native transfer or token Transfer logs were found to the resolved deposit address in this tx."}:{kind:"contract_creation_or_missing_to",message:"This transaction has no 'to' address (contract creation). It does not look like a direct deposit to this address."},F=u?await (0,b.retryOnceOnTransientDbError)(async()=>{let e=await r`
            SELECT count(*)::int AS count
            FROM ex_chain_deposit_event
            WHERE chain = 'bsc'
              AND lower(to_address) = ${u}
              AND journal_entry_id IS NULL
          `;return Number(e[0]?.count??0)||0}):0;return x.NextResponse.json({ok:!0,chain:"bsc",tip:n,confirmations_required:a,safe_tip:_,verdict:L,cursor:{last_scanned_block:h,lag_blocks:p},query:{address:u||null,tx_hash:o||null},deposit_address:m?{found:!0,user_id:m.user_id,address:v(m.address),status:m.status??null,created_at:m.created_at}:{found:!1},onchain:i,matches:{native:j,token:M},events:g,credited:R,uncredited_for_address:F,journal_lines:E,...null!=c?{tx_to_is_contract:c}:{},...U?{diagnostic:U}:{}})}catch(t){let e=t instanceof Error?t.message:String(t);return(0,R.apiError)("internal_error",{details:{message:e}})}}e.s(["GET",()=>C,"dynamic",0,"force-dynamic","runtime",0,"nodejs"],888822);var k=e.i(888822);let I=new t.AppRouteRouteModule({definition:{kind:r.RouteKind.APP_ROUTE,page:"/api/exchange/admin/deposits/lookup/route",pathname:"/api/exchange/admin/deposits/lookup",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/src/app/api/exchange/admin/deposits/lookup/route.ts",nextConfigOutput:"",userland:k}),{workAsyncStorage:D,workUnitAsyncStorage:P,serverHooks:M}=I;function j(){return(0,a.patchFetch)({workAsyncStorage:D,workUnitAsyncStorage:P})}async function L(e,t,a){I.isDev&&(0,n.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let x="/api/exchange/admin/deposits/lookup/route";x=x.replace(/\/index$/,"")||"/";let E=await I.prepare(e,t,{srcPage:x,multiZoneDraftMode:!1});if(!E)return t.statusCode=400,t.end("Bad Request"),null==a.waitUntil||a.waitUntil.call(a,Promise.resolve()),null;let{buildId:R,params:y,nextConfig:b,parsedUrl:w,isDraftMode:S,prerenderManifest:v,routerServerContext:A,isOnDemandRevalidate:N,revalidateOnlyGenerated:O,resolvedPathname:T,clientReferenceManifest:C,serverActionsManifest:k}=E,D=(0,o.normalizeAppPath)(x),P=!!(v.dynamicRoutes[D]||v.routes[T]),M=async()=>((null==A?void 0:A.render404)?await A.render404(e,t,w,!1):t.end("This page could not be found"),null);if(P&&!S){let e=!!v.routes[T],t=v.dynamicRoutes[D];if(t&&!1===t.fallback&&!e){if(b.experimental.adapterPath)return await M();throw new g.NoFallbackError}}let j=null;!P||I.isDev||S||(j="/index"===(j=T)?"/":j);let L=!0===I.isDev||!P,H=P&&!L;k&&C&&(0,i.setManifestsSingleton)({page:x,clientReferenceManifest:C,serverActionsManifest:k});let U=e.method||"GET",F=(0,s.getTracer)(),q=F.getActiveScopeSpan(),B={params:y,prerenderManifest:v,renderOpts:{experimental:{authInterrupts:!!b.experimental.authInterrupts},cacheComponents:!!b.cacheComponents,supportsDynamicResponse:L,incrementalCache:(0,n.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:b.cacheLife,waitUntil:a.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,r,a,n)=>I.onRequestError(e,t,a,n,A)},sharedContext:{buildId:R}},$=new l.NodeNextRequest(e),W=new l.NodeNextResponse(t),K=d.NextRequestAdapter.fromNodeNextRequest($,(0,d.signalFromNodeResponse)(t));try{let i=async e=>I.handle(K,B).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let r=F.getRootSpanAttributes();if(!r)return;if(r.get("next.span_type")!==u.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${r.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let a=r.get("next.route");if(a){let t=`${U} ${a}`;e.setAttributes({"next.route":a,"http.route":a,"next.span_name":t}),e.updateName(t)}else e.updateName(`${U} ${x}`)}),o=!!(0,n.getRequestMeta)(e,"minimalMode"),l=async n=>{var s,l;let d=async({previousCacheEntry:r})=>{try{if(!o&&N&&O&&!r)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let s=await i(n);e.fetchMetrics=B.renderOpts.fetchMetrics;let l=B.renderOpts.pendingWaitUntil;l&&a.waitUntil&&(a.waitUntil(l),l=void 0);let d=B.renderOpts.collectedTags;if(!P)return await (0,_.sendResponse)($,W,s,B.renderOpts.pendingWaitUntil),null;{let e=await s.blob(),t=(0,h.toNodeOutgoingHttpHeaders)(s.headers);d&&(t[m.NEXT_CACHE_TAGS_HEADER]=d),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let r=void 0!==B.renderOpts.collectedRevalidate&&!(B.renderOpts.collectedRevalidate>=m.INFINITE_CACHE)&&B.renderOpts.collectedRevalidate,a=void 0===B.renderOpts.collectedExpire||B.renderOpts.collectedExpire>=m.INFINITE_CACHE?void 0:B.renderOpts.collectedExpire;return{value:{kind:f.CachedRouteKind.APP_ROUTE,status:s.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:r,expire:a}}}}catch(t){throw(null==r?void 0:r.isStale)&&await I.onRequestError(e,t,{routerKind:"App Router",routePath:x,routeType:"route",revalidateReason:(0,c.getRevalidateReason)({isStaticGeneration:H,isOnDemandRevalidate:N})},!1,A),t}},u=await I.handleResponse({req:e,nextConfig:b,cacheKey:j,routeKind:r.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:v,isRoutePPREnabled:!1,isOnDemandRevalidate:N,revalidateOnlyGenerated:O,responseGenerator:d,waitUntil:a.waitUntil,isMinimalMode:o});if(!P)return null;if((null==u||null==(s=u.value)?void 0:s.kind)!==f.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==u||null==(l=u.value)?void 0:l.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});o||t.setHeader("x-nextjs-cache",N?"REVALIDATED":u.isMiss?"MISS":u.isStale?"STALE":"HIT"),S&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let g=(0,h.fromNodeOutgoingHttpHeaders)(u.value.headers);return o&&P||g.delete(m.NEXT_CACHE_TAGS_HEADER),!u.cacheControl||t.getHeader("Cache-Control")||g.get("Cache-Control")||g.set("Cache-Control",(0,p.getCacheControlHeader)(u.cacheControl)),await (0,_.sendResponse)($,W,new Response(u.value.body,{headers:g,status:u.value.status||200})),null};q?await l(q):await F.withPropagatedContext(e.headers,()=>F.trace(u.BaseServerSpan.handleRequest,{spanName:`${U} ${x}`,kind:s.SpanKind.SERVER,attributes:{"http.method":U,"http.target":e.url}},l))}catch(t){if(t instanceof g.NoFallbackError||await I.onRequestError(e,t,{routerKind:"App Router",routePath:D,routeType:"route",revalidateReason:(0,c.getRevalidateReason)({isStaticGeneration:H,isOnDemandRevalidate:N})},!1,A),P)throw t;return await (0,_.sendResponse)($,W,new Response(null,{status:500})),null}}e.s(["handler",()=>L,"patchFetch",()=>j,"routeModule",()=>I,"serverHooks",()=>M,"workAsyncStorage",()=>D,"workUnitAsyncStorage",()=>P],602963)}];

//# sourceMappingURL=node_modules_next_dist_esm_build_templates_app-route_bf37cd51.js.map