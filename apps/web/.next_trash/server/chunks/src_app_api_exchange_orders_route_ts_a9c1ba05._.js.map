{"version":3,"sources":["../../../src/app/api/exchange/orders/route.ts","../../../src/lib/exchange/matcher.ts","../../../src/lib/exchange/orderMath.ts"],"sourcesContent":["import { z } from \"zod\";\r\nimport { createHash } from \"node:crypto\";\r\n\r\nimport { apiError, apiZodError } from \"@/lib/api/errors\";\r\nimport { requireActiveUser } from \"@/lib/auth/activeUser\";\r\nimport { requireSessionUserId } from \"@/lib/auth/sessionGuard\";\r\nimport { resolveReadOnlyUserScope } from \"@/lib/auth/impersonation\";\r\nimport { getSql } from \"@/lib/db\";\r\nimport { responseForDbError, retryOnceOnTransientDbError } from \"@/lib/dbTransient\";\r\nimport { logRouteResponse } from \"@/lib/routeLog\";\r\nimport { amount3818PositiveSchema } from \"@/lib/exchange/amount\";\r\nimport { bpsFeeCeil3818, fromBigInt3818, isZeroOrLess3818, toBigInt3818 } from \"@/lib/exchange/fixed3818\";\r\nimport { planLimitMatches, planMarketMatches } from \"@/lib/exchange/matcher\";\r\nimport { consumeAmountForHold, estimateMarketBuyReserve, quoteAmountForFill, reserveAmountForLimitOrder } from \"@/lib/exchange/orderMath\";\r\nimport { isMultipleOfStep3818 } from \"@/lib/exchange/steps\";\r\nimport { enqueueOutbox } from \"@/lib/outbox\";\r\nimport { writeAuditLog, auditContextFromRequest } from \"@/lib/auditLog\";\r\nimport { createNotification } from \"@/lib/notifications\";\r\nimport { propagateLeaderOrder } from \"@/lib/exchange/copyTrading\";\r\nimport { chargeGasFee } from \"@/lib/exchange/gas\";\r\nimport { createPgRateLimiter } from \"@/lib/rateLimitPg\";\r\n\r\nexport const runtime = \"nodejs\";\r\nexport const dynamic = \"force-dynamic\";\r\n\r\nconst SYSTEM_FEE_USER_ID = \"00000000-0000-0000-0000-000000000001\";\r\n\r\ntype OrderRow = {\r\n  id: string;\r\n  market_id: string;\r\n  user_id: string;\r\n  side: \"buy\" | \"sell\";\r\n  type: \"limit\" | \"market\";\r\n  price: string;\r\n  quantity: string;\r\n  remaining_quantity: string;\r\n  iceberg_display_quantity?: string | null;\r\n  iceberg_hidden_remaining?: string;\r\n  status: \"open\" | \"partially_filled\" | \"filled\" | \"canceled\";\r\n  hold_id: string | null;\r\n  created_at: string;\r\n  updated_at: string;\r\n};\r\n\r\nconst sideSchema = z.enum([\"buy\", \"sell\"]);\r\n\r\nconst timeInForceSchema = z.enum([\"GTC\", \"IOC\", \"FOK\"]);\r\n\r\nconst stpModeSchema = z.enum([\"none\", \"cancel_newest\", \"cancel_oldest\", \"cancel_both\"]);\r\n\r\nconst idempotencyKeySchema = z\r\n  .string()\r\n  .trim()\r\n  .min(1)\r\n  .max(120)\r\n  .regex(/^[A-Za-z0-9:_\\-\\.]+$/);\r\n\r\nconst placeOrderSchema = z.discriminatedUnion(\"type\", [\r\n  z.object({\r\n    market_id: z.string().uuid(),\r\n    side: sideSchema,\r\n    type: z.literal(\"limit\"),\r\n    price: amount3818PositiveSchema,\r\n    quantity: amount3818PositiveSchema,\r\n    iceberg_display_quantity: amount3818PositiveSchema.optional(),\r\n    time_in_force: timeInForceSchema.optional().default(\"GTC\"),\r\n    post_only: z.boolean().optional().default(false),\r\n    stp_mode: stpModeSchema.optional().default(\"none\"),\r\n    reduce_only: z.boolean().optional().default(false),\r\n    idempotency_key: idempotencyKeySchema.optional(),\r\n  }),\r\n  z.object({\r\n    market_id: z.string().uuid(),\r\n    side: sideSchema,\r\n    type: z.literal(\"market\"),\r\n    quantity: amount3818PositiveSchema,\r\n    stp_mode: stpModeSchema.optional().default(\"none\"),\r\n    reduce_only: z.boolean().optional().default(false),\r\n    idempotency_key: idempotencyKeySchema.optional(),\r\n  }),\r\n]);\r\n\r\nfunction hashIdempotencyPayload(payload: Record<string, unknown>): string {\r\n  return createHash(\"sha256\").update(JSON.stringify(payload)).digest(\"hex\");\r\n}\r\n\r\nfunction parseEnvInt(name: string): number | null {\r\n  const raw = String(process.env[name] ?? \"\").trim();\r\n  if (!raw) return null;\r\n  const n = Number(raw);\r\n  if (!Number.isFinite(n)) return null;\r\n  const v = Math.trunc(n);\r\n  return v > 0 ? v : null;\r\n}\r\n\r\nfunction parseEnvNumber(name: string): number | null {\r\n  const raw = String(process.env[name] ?? \"\").trim();\r\n  if (!raw) return null;\r\n  const n = Number(raw);\r\n  return Number.isFinite(n) && n > 0 ? n : null;\r\n}\r\n\r\nexport async function GET(request: Request) {\r\n  const startMs = Date.now();\r\n  const sql = getSql();\r\n\r\n  let actingUserId: string | null = null;\r\n  const reply = (response: Response, meta?: Record<string, unknown>) => {\r\n    try {\r\n      logRouteResponse(request, response, { startMs, userId: actingUserId, meta });\r\n    } catch {\r\n      // ignore\r\n    }\r\n    return response;\r\n  };\r\n\r\n  const authed = await requireSessionUserId(sql as any, request);\r\n  if (!authed.ok) return reply(authed.response, { code: \"unauthorized\" });\r\n  actingUserId = authed.userId;\r\n\r\n  const scopeRes = await retryOnceOnTransientDbError(() => resolveReadOnlyUserScope(sql, request, actingUserId));\r\n  if (!scopeRes.ok) return reply(apiError(scopeRes.error, { status: 403 }), { code: scopeRes.error });\r\n  const userId = scopeRes.scope.userId;\r\n\r\n  try {\r\n    const activeErr = await requireActiveUser(sql, userId);\r\n    if (activeErr) return reply(apiError(activeErr), { code: activeErr });\r\n\r\n    const url = new URL(request.url);\r\n    const marketId = url.searchParams.get(\"market_id\");\r\n    if (marketId && !z.string().uuid().safeParse(marketId).success) return reply(apiError(\"invalid_market_id\"), { code: \"invalid_market_id\" });\r\n\r\n    const rows = await retryOnceOnTransientDbError(async () => {\r\n      return await sql<OrderRow[]>`\r\n        SELECT\r\n          id,\r\n          market_id,\r\n          user_id,\r\n          side,\r\n          type,\r\n          price::text AS price,\r\n          quantity::text AS quantity,\r\n          remaining_quantity::text AS remaining_quantity,\r\n          iceberg_display_quantity::text AS iceberg_display_quantity,\r\n          iceberg_hidden_remaining::text AS iceberg_hidden_remaining,\r\n          status,\r\n          hold_id,\r\n          created_at,\r\n          updated_at\r\n        FROM ex_order\r\n        WHERE user_id = ${userId}\r\n          AND (${marketId ?? null}::uuid IS NULL OR market_id = ${marketId ?? null}::uuid)\r\n        ORDER BY created_at DESC\r\n        LIMIT 100\r\n      `;\r\n    });\r\n\r\n    return reply(Response.json({ user_id: userId, orders: rows }),\r\n      scopeRes.scope.impersonating ? { impersonate_user_id: userId } : undefined\r\n    );\r\n  } catch (e) {\r\n    const resp = responseForDbError(\"exchange.orders.list\", e);\r\n    if (resp) return reply(resp, { code: \"db_error\" });\r\n    throw e;\r\n  }\r\n}\r\n\r\nexport async function POST(request: Request) {\r\n  const startMs = Date.now();\r\n  const sql = getSql();\r\n\r\n  let actingUserId: string | null = null;\r\n  const reply = (response: Response, meta?: Record<string, unknown>) => {\r\n    try {\r\n      logRouteResponse(request, response, { startMs, userId: actingUserId, meta });\r\n    } catch {\r\n      // ignore\r\n    }\r\n    return response;\r\n  };\r\n\r\n  const authed = await requireSessionUserId(sql as any, request);\r\n  if (!authed.ok) return reply(authed.response, { code: \"unauthorized\" });\r\n  actingUserId = authed.userId;\r\n\r\n  try {\r\n    const activeErr = await requireActiveUser(sql, actingUserId);\r\n    if (activeErr) return reply(apiError(activeErr), { code: activeErr });\r\n\r\n    // Optional per-user place rate limit (prevents automation/spam).\r\n    // Default is off to avoid breaking high-frequency strategies; enable via env.\r\n    const placeMax = Number(String(process.env.EXCHANGE_PLACE_MAX_PER_MIN ?? \"\").trim() || \"0\");\r\n    if (Number.isFinite(placeMax) && placeMax > 0) {\r\n      try {\r\n        const limiter = createPgRateLimiter(sql as any, { name: \"exchange-place\", windowMs: 60_000, max: Math.trunc(placeMax) });\r\n        const rl = await limiter.consume(`u:${actingUserId}`);\r\n        if (!rl.allowed) return reply(apiError(\"rate_limit_exceeded\", { status: 429 }), { code: \"rate_limit_exceeded\" });\r\n      } catch {\r\n        // If limiter fails, do not block order placement.\r\n      }\r\n    }\r\n\r\n    const body = await request.json().catch(() => ({}));\r\n    let input: z.infer<typeof placeOrderSchema>;\r\n    try {\r\n      input = placeOrderSchema.parse(body);\r\n    } catch (e) {\r\n      return reply(apiZodError(e) ?? apiError(\"invalid_input\"), { code: \"invalid_input\" });\r\n    }\r\n\r\n    const idemScope = \"exchange.orders.place\";\r\n    const headerKey = request.headers.get(\"x-idempotency-key\")?.trim() || null;\r\n    const idemKey = headerKey ?? (input as any).idempotency_key ?? null;\r\n    const idemPayload =\r\n      input.type === \"limit\"\r\n        ? {\r\n            market_id: input.market_id,\r\n            side: input.side,\r\n            type: input.type,\r\n            price: input.price,\r\n            quantity: input.quantity,\r\n            iceberg_display_quantity: (input as any).iceberg_display_quantity ?? null,\r\n            time_in_force: input.time_in_force,\r\n            post_only: input.post_only,\r\n            stp_mode: (input as any).stp_mode,\r\n            reduce_only: (input as any).reduce_only,\r\n          }\r\n        : {\r\n            market_id: input.market_id,\r\n            side: input.side,\r\n            type: input.type,\r\n            quantity: input.quantity,\r\n            stp_mode: (input as any).stp_mode,\r\n            reduce_only: (input as any).reduce_only,\r\n          };\r\n    const idemHash = idemKey ? hashIdempotencyPayload(idemPayload) : null;\r\n\r\n    const result = await sql.begin(async (tx) => {\r\n      const txSql = tx as unknown as typeof sql;\r\n\r\n      // Idempotency (optional): if x-idempotency-key is provided, ensure safe retries.\r\n      if (idemKey && idemHash) {\r\n        const rows = await txSql<\r\n          {\r\n            request_hash: string;\r\n            response_json: unknown;\r\n            status_code: number | null;\r\n          }[]\r\n        >`\r\n          SELECT request_hash, response_json, status_code\r\n          FROM app_idempotency_key\r\n          WHERE user_id = ${actingUserId}::uuid\r\n            AND scope = ${idemScope}\r\n            AND idem_key = ${idemKey}\r\n          LIMIT 1\r\n          FOR UPDATE\r\n        `;\r\n\r\n        const existing = rows[0] ?? null;\r\n        if (existing) {\r\n          if (existing.request_hash !== idemHash) {\r\n            return { status: 409 as const, body: { error: \"idempotency_key_conflict\" } };\r\n          }\r\n\r\n          if (existing.status_code != null && existing.response_json != null) {\r\n            return { status: existing.status_code as any, body: existing.response_json as any };\r\n          }\r\n        } else {\r\n          await txSql`\r\n            INSERT INTO app_idempotency_key (user_id, scope, idem_key, request_hash)\r\n            VALUES (${actingUserId}::uuid, ${idemScope}, ${idemKey}, ${idemHash})\r\n          `;\r\n        }\r\n      }\r\n\r\n      const gasErr = await chargeGasFee(txSql, {\r\n        userId: actingUserId,\r\n        action: \"place_order\",\r\n        reference: input.market_id,\r\n      });\r\n      if (gasErr) return { status: 409 as const, body: { error: gasErr.code, details: gasErr.details } };\r\n\r\n      const finalizeHoldIfTerminal = async (orderId: string, holdId: string | null): Promise<void> => {\r\n        if (!holdId) return;\r\n\r\n        const orderRows = await txSql<{ status: string }[]>`\r\n          SELECT status\r\n          FROM ex_order\r\n          WHERE id = ${orderId}::uuid\r\n          LIMIT 1\r\n        `;\r\n        const status = orderRows[0]?.status;\r\n        if (status !== \"filled\" && status !== \"canceled\") return;\r\n\r\n        const holdRows = await txSql<{ remaining_amount: string; status: string }[]>`\r\n          SELECT remaining_amount::text AS remaining_amount, status\r\n          FROM ex_hold\r\n          WHERE id = ${holdId}::uuid\r\n          LIMIT 1\r\n          FOR UPDATE\r\n        `;\r\n        const hold = holdRows[0];\r\n        if (!hold) return;\r\n        if (hold.status !== \"active\") return;\r\n\r\n        if (isZeroOrLess3818(hold.remaining_amount)) {\r\n          await txSql`\r\n            UPDATE ex_hold\r\n            SET remaining_amount = 0, status = 'consumed'\r\n            WHERE id = ${holdId}::uuid AND status = 'active'\r\n          `;\r\n          return;\r\n        }\r\n\r\n        await txSql`\r\n          UPDATE ex_hold\r\n          SET status = 'released', released_at = now()\r\n          WHERE id = ${holdId}::uuid AND status = 'active'\r\n        `;\r\n      };\r\n\r\n      // Per-market serialized matching (simple but safe for MVP).\r\n      await txSql`SELECT pg_advisory_xact_lock(hashtext(${input.market_id}::text))`;\r\n\r\n      const markets = await txSql<\r\n        {\r\n          id: string;\r\n          chain: string;\r\n          symbol: string;\r\n          base_asset_id: string;\r\n          quote_asset_id: string;\r\n          status: string;\r\n          halt_until: string | null;\r\n          tick_size: string;\r\n          lot_size: string;\r\n          maker_fee_bps: number;\r\n          taker_fee_bps: number;\r\n        }[]\r\n      >`\r\n        SELECT\r\n          id,\r\n          chain,\r\n          symbol,\r\n          base_asset_id,\r\n          quote_asset_id,\r\n          status,\r\n          halt_until::text AS halt_until,\r\n          tick_size::text AS tick_size,\r\n          lot_size::text AS lot_size,\r\n          maker_fee_bps,\r\n          taker_fee_bps\r\n        FROM ex_market\r\n        WHERE id = ${input.market_id}\r\n        LIMIT 1\r\n      `;\r\n\r\n      if (markets.length === 0) return { status: 404 as const, body: { error: \"market_not_found\" } };\r\n      const market = markets[0]!;\r\n      if (market.status !== \"enabled\") return { status: 409 as const, body: { error: \"market_disabled\" } };\r\n\r\n      if (market.halt_until) {\r\n        const untilMs = Date.parse(market.halt_until);\r\n        if (Number.isFinite(untilMs) && untilMs > Date.now()) {\r\n          return { status: 409 as const, body: { error: \"market_halted\", details: { halt_until: market.halt_until } } };\r\n        }\r\n      }\r\n\r\n      // --- Basic risk limits (env-gated) ---\r\n      // Keep these simple and tunable for ops.\r\n      const maxOpenOrders = parseEnvInt(\"EXCHANGE_MAX_OPEN_ORDERS_PER_USER\");\r\n      if (maxOpenOrders) {\r\n        const rows = await txSql<{ n: number }[]>`\r\n          SELECT count(*)::int AS n\r\n          FROM ex_order\r\n          WHERE user_id = ${actingUserId}::uuid\r\n            AND status IN ('open','partially_filled')\r\n        `;\r\n        const n = rows[0]?.n ?? 0;\r\n        if (n >= maxOpenOrders) {\r\n          return { status: 409 as const, body: { error: \"open_orders_limit\" } };\r\n        }\r\n      }\r\n\r\n      const maxNotional = parseEnvNumber(\"EXCHANGE_MAX_ORDER_NOTIONAL\");\r\n      if (maxNotional) {\r\n        // Use limit price when available; for market orders, approximate from last exec or best book.\r\n        let px: number | null = null;\r\n        if (input.type === \"limit\") {\r\n          const p = Number(input.price);\r\n          px = Number.isFinite(p) && p > 0 ? p : null;\r\n        } else {\r\n          const rows = await txSql<{ last_exec_price: string | null; bid: string | null; ask: string | null }[]>`\r\n            SELECT\r\n              (\r\n                SELECT e.price::text\r\n                FROM ex_execution e\r\n                WHERE e.market_id = ${market.id}::uuid\r\n                ORDER BY e.created_at DESC\r\n                LIMIT 1\r\n              ) AS last_exec_price,\r\n              (\r\n                SELECT o.price::text\r\n                FROM ex_order o\r\n                WHERE o.market_id = ${market.id}::uuid\r\n                  AND o.side = 'buy'\r\n                  AND o.status IN ('open','partially_filled')\r\n                  AND o.user_id <> ${actingUserId}::uuid\r\n                ORDER BY o.price DESC, o.created_at ASC\r\n                LIMIT 1\r\n              ) AS bid,\r\n              (\r\n                SELECT o.price::text\r\n                FROM ex_order o\r\n                WHERE o.market_id = ${market.id}::uuid\r\n                  AND o.side = 'sell'\r\n                  AND o.status IN ('open','partially_filled')\r\n                  AND o.user_id <> ${actingUserId}::uuid\r\n                ORDER BY o.price ASC, o.created_at ASC\r\n                LIMIT 1\r\n              ) AS ask\r\n          `;\r\n          const r = rows[0];\r\n          const ask = r?.ask != null ? Number(r.ask) : NaN;\r\n          const bid = r?.bid != null ? Number(r.bid) : NaN;\r\n          const last = r?.last_exec_price != null ? Number(r.last_exec_price) : NaN;\r\n\r\n          if (input.side === \"buy\") {\r\n            px = Number.isFinite(ask) && ask > 0 ? ask : Number.isFinite(last) && last > 0 ? last : Number.isFinite(bid) && bid > 0 ? bid : null;\r\n          } else {\r\n            px = Number.isFinite(bid) && bid > 0 ? bid : Number.isFinite(last) && last > 0 ? last : Number.isFinite(ask) && ask > 0 ? ask : null;\r\n          }\r\n        }\r\n\r\n        const qty = Number(input.quantity);\r\n        if (px && Number.isFinite(qty) && qty > 0) {\r\n          const notional = px * qty;\r\n          if (Number.isFinite(notional) && notional > maxNotional) {\r\n            return { status: 409 as const, body: { error: \"order_notional_too_large\", details: { max: maxNotional } } };\r\n          }\r\n        }\r\n      }\r\n\r\n      // Price-band protection (limit orders only).\r\n      // Prevents fat-fingered limit orders far away from current trading range.\r\n      const bandBps = parseEnvInt(\"EXCHANGE_PRICE_BAND_BPS\");\r\n      if (bandBps && input.type === \"limit\") {\r\n        const rows = await txSql<{ last_exec_price: string | null; bid: string | null; ask: string | null }[]>`\r\n          SELECT\r\n            (\r\n              SELECT e.price::text\r\n              FROM ex_execution e\r\n              WHERE e.market_id = ${market.id}::uuid\r\n              ORDER BY e.created_at DESC\r\n              LIMIT 1\r\n            ) AS last_exec_price,\r\n            (\r\n              SELECT o.price::text\r\n              FROM ex_order o\r\n              WHERE o.market_id = ${market.id}::uuid\r\n                AND o.side = 'buy'\r\n                AND o.status IN ('open','partially_filled')\r\n              ORDER BY o.price DESC, o.created_at ASC\r\n              LIMIT 1\r\n            ) AS bid,\r\n            (\r\n              SELECT o.price::text\r\n              FROM ex_order o\r\n              WHERE o.market_id = ${market.id}::uuid\r\n                AND o.side = 'sell'\r\n                AND o.status IN ('open','partially_filled')\r\n              ORDER BY o.price ASC, o.created_at ASC\r\n              LIMIT 1\r\n            ) AS ask\r\n        `;\r\n\r\n        const r = rows[0];\r\n        const last = r?.last_exec_price != null ? Number(r.last_exec_price) : NaN;\r\n        const bid = r?.bid != null ? Number(r.bid) : NaN;\r\n        const ask = r?.ask != null ? Number(r.ask) : NaN;\r\n        const mid = Number.isFinite(bid) && bid > 0 && Number.isFinite(ask) && ask > 0 ? (bid + ask) / 2 : NaN;\r\n\r\n        const ref = Number.isFinite(last) && last > 0 ? last : Number.isFinite(mid) && mid > 0 ? mid : null;\r\n        const p = Number(input.price);\r\n\r\n        if (ref && Number.isFinite(p) && p > 0) {\r\n          const deviationBps = Math.abs((p - ref) / ref) * 10_000;\r\n          if (Number.isFinite(deviationBps) && deviationBps > bandBps) {\r\n            const circuitSeconds = parseEnvInt(\"EXCHANGE_CIRCUIT_BREAKER_SECONDS\");\r\n            if (circuitSeconds) {\r\n              await txSql`\r\n                UPDATE ex_market\r\n                SET halt_until = GREATEST(\r\n                  COALESCE(halt_until, now()),\r\n                  now() + make_interval(secs => ${circuitSeconds})\r\n                )\r\n                WHERE id = ${market.id}::uuid\r\n              `;\r\n            }\r\n\r\n            const min = ref * (1 - bandBps / 10_000);\r\n            const max = ref * (1 + bandBps / 10_000);\r\n            return {\r\n              status: 409 as const,\r\n              body: {\r\n                error: \"exchange_price_out_of_band\",\r\n                details: {\r\n                  reference_price: String(ref),\r\n                  band_bps: bandBps,\r\n                  min_price: String(min),\r\n                  max_price: String(max),\r\n                },\r\n              },\r\n            };\r\n          }\r\n        }\r\n      }\r\n\r\n      const isMarket = input.type === \"market\";\r\n      const timeInForce = input.type === \"limit\" ? input.time_in_force : \"IOC\";\r\n      const postOnly = input.type === \"limit\" ? input.post_only : false;\r\n      const inputPrice = input.type === \"limit\" ? input.price : \"0\";\r\n\r\n      // --- Iceberg (limit only) ---\r\n      const icebergDisplayQty = input.type === \"limit\" ? (input as any).iceberg_display_quantity : undefined;\r\n      const icebergDisplayQtySql: string | null = icebergDisplayQty != null ? String(icebergDisplayQty) : null;\r\n      if (icebergDisplayQty != null && input.type !== \"limit\") {\r\n        return { status: 400 as const, body: { error: \"iceberg_limit_only\" } };\r\n      }\r\n\r\n      if (icebergDisplayQty != null) {\r\n        if (timeInForce !== \"GTC\") {\r\n          return { status: 400 as const, body: { error: \"iceberg_gtc_only\" } };\r\n        }\r\n        if (!isMultipleOfStep3818(String(icebergDisplayQty), market.lot_size)) {\r\n          return {\r\n            status: 400 as const,\r\n            body: { error: \"iceberg_display_not_multiple_of_lot\", details: { lot_size: market.lot_size } },\r\n          };\r\n        }\r\n\r\n        const disp = toBigInt3818(String(icebergDisplayQty));\r\n        const total = toBigInt3818(String((input as any).quantity));\r\n        if (disp <= 0n || disp >= total) {\r\n          return { status: 400 as const, body: { error: \"iceberg_display_must_be_lt_total\" } };\r\n        }\r\n      }\r\n\r\n      // --- Self-trade prevention (STP) modes ---\r\n      // The matcher excludes same-user makers, but that can still create a crossed self-book.\r\n      // STP defines what to do when the incoming order would cross against the user's own resting orders.\r\n      const stpMode = (input as any).stp_mode as z.infer<typeof stpModeSchema>;\r\n      if (stpMode && stpMode !== \"none\") {\r\n        const makerSide = input.side === \"buy\" ? \"sell\" : \"buy\";\r\n        const crossers = await txSql<{ id: string; hold_id: string | null }[]>`\r\n          SELECT id::text AS id, hold_id::text AS hold_id\r\n          FROM ex_order\r\n          WHERE market_id = ${market.id}::uuid\r\n            AND user_id = ${actingUserId}::uuid\r\n            AND side = ${makerSide}\r\n            AND status IN ('open','partially_filled')\r\n            AND remaining_quantity > 0\r\n            AND (\r\n              ${isMarket}::boolean = true\r\n              OR (${input.side} = 'buy' AND price <= (${inputPrice}::numeric))\r\n              OR (${input.side} = 'sell' AND price >= (${inputPrice}::numeric))\r\n            )\r\n          ORDER BY\r\n            CASE WHEN ${input.side} = 'buy' THEN price END ASC,\r\n            CASE WHEN ${input.side} = 'sell' THEN price END DESC,\r\n            created_at ASC\r\n          LIMIT 200\r\n          FOR UPDATE\r\n        `;\r\n\r\n        if (crossers.length > 0) {\r\n          if (stpMode === \"cancel_oldest\" || stpMode === \"cancel_both\") {\r\n            for (const c of crossers) {\r\n              await txSql`\r\n                UPDATE ex_order\r\n                SET status = 'canceled', updated_at = now()\r\n                WHERE id = ${c.id}::uuid\r\n                  AND user_id = ${actingUserId}::uuid\r\n                  AND status IN ('open','partially_filled')\r\n              `;\r\n              await finalizeHoldIfTerminal(c.id, c.hold_id);\r\n            }\r\n          }\r\n\r\n          if (stpMode === \"cancel_newest\") {\r\n            return {\r\n              status: 409 as const,\r\n              body: { error: \"stp_cancel_newest\", details: { crossing_orders: crossers.length } },\r\n            };\r\n          }\r\n          if (stpMode === \"cancel_both\") {\r\n            return {\r\n              status: 409 as const,\r\n              body: { error: \"stp_cancel_both\", details: { crossing_orders: crossers.length } },\r\n            };\r\n          }\r\n        }\r\n      }\r\n\r\n      // Tick-size validation (limit only â€” market orders have no price)\r\n      if (input.type === \"limit\" && !isMultipleOfStep3818(input.price, market.tick_size)) {\r\n        return { status: 400 as const, body: { error: \"price_not_multiple_of_tick\", details: { tick_size: market.tick_size } } };\r\n      }\r\n\r\n      if (!isMultipleOfStep3818(input.quantity, market.lot_size)) {\r\n        return { status: 400 as const, body: { error: \"quantity_not_multiple_of_lot\", details: { lot_size: market.lot_size } } };\r\n      }\r\n\r\n      const reserveAssetId = input.side === \"buy\" ? market.quote_asset_id : market.base_asset_id;\r\n      const maxFeeBps = Math.max(market.maker_fee_bps ?? 0, market.taker_fee_bps ?? 0);\r\n\r\n      // --- Post-only and FOK checks (limit orders only) ---\r\n      if (!isMarket && (postOnly || timeInForce === \"FOK\")) {\r\n        const makerSide = input.side === \"buy\" ? \"sell\" : \"buy\";\r\n\r\n        const makers = await txSql<{ id: string; price: string; remaining_quantity: string; created_at: string }[]>`\r\n          SELECT id::text AS id, price::text AS price, remaining_quantity::text AS remaining_quantity, created_at::text AS created_at\r\n          FROM ex_order\r\n          WHERE market_id = ${market.id}::uuid\r\n            AND side = ${makerSide}\r\n            AND status IN ('open','partially_filled')\r\n            AND remaining_quantity > 0\r\n            AND user_id <> ${actingUserId}::uuid\r\n            AND (\r\n              (${input.side} = 'buy' AND price <= (${inputPrice}::numeric))\r\n              OR (${input.side} = 'sell' AND price >= (${inputPrice}::numeric))\r\n            )\r\n          ORDER BY\r\n            CASE WHEN ${input.side} = 'buy' THEN price END ASC,\r\n            CASE WHEN ${input.side} = 'sell' THEN price END DESC,\r\n            created_at ASC\r\n          LIMIT 200\r\n        `;\r\n\r\n        if (postOnly && makers.length > 0) {\r\n          return { status: 409 as const, body: { error: \"post_only_would_take\" } };\r\n        }\r\n\r\n        if (timeInForce === \"FOK\") {\r\n          const planned = planLimitMatches({\r\n            taker: {\r\n              id: \"00000000-0000-0000-0000-000000000000\",\r\n              side: input.side,\r\n              price: inputPrice,\r\n              remaining_quantity: input.quantity,\r\n              created_at: new Date().toISOString(),\r\n            },\r\n            makers: makers.map((m) => ({\r\n              id: m.id,\r\n              side: makerSide as any,\r\n              price: m.price,\r\n              remaining_quantity: m.remaining_quantity,\r\n              created_at: m.created_at,\r\n            })),\r\n            maxFills: 200,\r\n          });\r\n\r\n          if (!isZeroOrLess3818(planned.taker_remaining_quantity)) {\r\n            return { status: 409 as const, body: { error: \"fok_insufficient_liquidity\" } };\r\n          }\r\n        }\r\n      }\r\n\r\n      // --- Reserve amount calculation ---\r\n      let reserveAmount: string;\r\n      if (isMarket && input.side === \"buy\") {\r\n        // For market buys, estimate cost from resting asks\r\n        const restingAsks = await txSql<{ price: string; remaining_quantity: string }[]>`\r\n          SELECT price::text AS price, remaining_quantity::text AS remaining_quantity\r\n          FROM ex_order\r\n          WHERE market_id = ${market.id}::uuid\r\n            AND side = 'sell'\r\n            AND status IN ('open', 'partially_filled')\r\n            AND user_id <> ${actingUserId}::uuid\r\n            AND remaining_quantity > 0\r\n          ORDER BY price ASC, created_at ASC\r\n          LIMIT 200\r\n        `;\r\n        const est = estimateMarketBuyReserve(input.quantity, restingAsks, { maxFeeBps });\r\n        if (!est) {\r\n          return { status: 409 as const, body: { error: \"insufficient_liquidity\", details: { available_asks: restingAsks.length } } };\r\n        }\r\n        reserveAmount = est;\r\n      } else if (isMarket) {\r\n        // Market sell: reserve base quantity\r\n        reserveAmount = input.quantity;\r\n      } else {\r\n        // Limit order\r\n        reserveAmount = reserveAmountForLimitOrder(input.side, inputPrice, input.quantity, { maxFeeBps });\r\n      }\r\n\r\n      const accountRows = await txSql<{ id: string }[]>`\r\n        INSERT INTO ex_ledger_account (user_id, asset_id)\r\n        VALUES (${actingUserId}, ${reserveAssetId}::uuid)\r\n        ON CONFLICT (user_id, asset_id) DO UPDATE SET user_id = EXCLUDED.user_id\r\n        RETURNING id\r\n      `;\r\n      const accountId = accountRows[0]!.id;\r\n\r\n      const balRows = await txSql<{ posted: string; held: string; available: string; ok: boolean }[]>`\r\n        WITH posted AS (\r\n          SELECT coalesce(sum(amount), 0)::numeric AS posted\r\n          FROM ex_journal_line\r\n          WHERE account_id = ${accountId}\r\n        ),\r\n        held AS (\r\n          SELECT coalesce(sum(remaining_amount), 0)::numeric AS held\r\n          FROM ex_hold\r\n          WHERE account_id = ${accountId} AND status = 'active'\r\n        )\r\n        SELECT\r\n          posted.posted::text AS posted,\r\n          held.held::text AS held,\r\n          (posted.posted - held.held)::text AS available,\r\n          ((posted.posted - held.held) >= (${reserveAmount}::numeric)) AS ok\r\n        FROM posted, held\r\n      `;\r\n      const bal = balRows[0];\r\n      if (!bal?.ok) {\r\n        return {\r\n          status: 409 as const,\r\n          body: {\r\n            error: \"insufficient_balance\",\r\n            details: {\r\n              posted: bal?.posted ?? \"0\",\r\n              held: bal?.held ?? \"0\",\r\n              available: bal?.available ?? \"0\",\r\n              requested: reserveAmount,\r\n            },\r\n          },\r\n        };\r\n      }\r\n\r\n      const orderRows = await txSql<OrderRow[]>`\r\n        INSERT INTO ex_order (\r\n          market_id,\r\n          user_id,\r\n          side,\r\n          type,\r\n          price,\r\n          quantity,\r\n          remaining_quantity,\r\n          iceberg_display_quantity,\r\n          iceberg_hidden_remaining,\r\n          status\r\n        )\r\n        VALUES (\r\n          ${market.id}::uuid,\r\n          ${actingUserId}::uuid,\r\n          ${input.side},\r\n          ${input.type},\r\n          (${inputPrice}::numeric),\r\n          (${input.quantity}::numeric),\r\n          (\r\n            CASE\r\n              WHEN ${icebergDisplayQtySql}::numeric IS NULL THEN (${input.quantity}::numeric)\r\n              ELSE (${icebergDisplayQtySql}::numeric)\r\n            END\r\n          ),\r\n          (${icebergDisplayQtySql}::numeric),\r\n          (\r\n            CASE\r\n              WHEN ${icebergDisplayQtySql}::numeric IS NULL THEN 0\r\n              ELSE greatest((${input.quantity}::numeric) - (${icebergDisplayQtySql}::numeric), 0)\r\n            END\r\n          ),\r\n          'open'\r\n        )\r\n        RETURNING\r\n          id,\r\n          market_id,\r\n          user_id,\r\n          side,\r\n          type,\r\n          price::text AS price,\r\n          quantity::text AS quantity,\r\n          remaining_quantity::text AS remaining_quantity,\r\n          status,\r\n          hold_id,\r\n          created_at,\r\n          updated_at\r\n      `;\r\n\r\n      const order = orderRows[0]!;\r\n\r\n      const holdRows = await txSql<{ id: string; amount: string; remaining_amount: string; status: string; created_at: string }[]>`\r\n        INSERT INTO ex_hold (account_id, asset_id, amount, remaining_amount, reason)\r\n        VALUES (${accountId}, ${reserveAssetId}::uuid, (${reserveAmount}::numeric), (${reserveAmount}::numeric), ${`order:${order.id}`})\r\n        RETURNING id, amount::text AS amount, remaining_amount::text AS remaining_amount, status, created_at\r\n      `;\r\n\r\n      const holdId = holdRows[0]!.id;\r\n\r\n      const updatedOrderRows = await txSql<OrderRow[]>`\r\n        UPDATE ex_order\r\n        SET hold_id = ${holdId}::uuid, updated_at = now()\r\n        WHERE id = ${order.id}::uuid\r\n        RETURNING\r\n          id,\r\n          market_id,\r\n          user_id,\r\n          side,\r\n          type,\r\n          price::text AS price,\r\n          quantity::text AS quantity,\r\n          remaining_quantity::text AS remaining_quantity,\r\n          status,\r\n          hold_id,\r\n          created_at,\r\n          updated_at\r\n      `;\r\n\r\n      let taker = updatedOrderRows[0]!;\r\n      const executions: Array<{\r\n        id: string;\r\n        price: string;\r\n        quantity: string;\r\n        maker_order_id: string;\r\n        taker_order_id: string;\r\n        created_at: string;\r\n      }> = [];\r\n\r\n      const makerSide = taker.side === \"buy\" ? \"sell\" : \"buy\";\r\n      const makerFillNotifs: Array<{ userId: string; orderId: string; side: string; fillQty: string; price: string; isFilled: boolean }> = [];\r\n\r\n      let fillCount = 0;\r\n      while (fillCount < 200) {\r\n        const remaining = await txSql<{ remaining: string; status: string }[]>`\r\n          SELECT remaining_quantity::text AS remaining, status\r\n          FROM ex_order\r\n          WHERE id = ${taker.id}::uuid\r\n          LIMIT 1\r\n        `;\r\n        const takerRemaining = remaining[0]?.remaining ?? \"0\";\r\n        const takerStatus = remaining[0]?.status ?? taker.status;\r\n        if (takerStatus === \"filled\" || isZeroOrLess3818(takerRemaining)) break;\r\n\r\n        const makers = await txSql<\r\n          {\r\n            id: string;\r\n            user_id: string;\r\n            side: \"buy\" | \"sell\";\r\n            price: string;\r\n            remaining_quantity: string;\r\n            iceberg_display_quantity: string | null;\r\n            iceberg_hidden_remaining: string;\r\n            hold_id: string | null;\r\n            created_at: string;\r\n          }[]\r\n        >`\r\n          SELECT\r\n            id,\r\n            user_id,\r\n            side,\r\n            price::text AS price,\r\n            remaining_quantity::text AS remaining_quantity,\r\n            iceberg_display_quantity::text AS iceberg_display_quantity,\r\n            iceberg_hidden_remaining::text AS iceberg_hidden_remaining,\r\n            hold_id,\r\n            created_at\r\n          FROM ex_order\r\n          WHERE market_id = ${market.id}::uuid\r\n            AND side = ${makerSide}\r\n            AND status IN ('open','partially_filled')\r\n            AND remaining_quantity > 0\r\n            AND id <> ${taker.id}::uuid\r\n            AND user_id <> ${taker.user_id}::uuid\r\n            AND (\r\n              ${isMarket}::boolean = true\r\n              OR (${taker.side} = 'buy' AND price <= (${taker.price}::numeric))\r\n              OR (${taker.side} = 'sell' AND price >= (${taker.price}::numeric))\r\n            )\r\n          ORDER BY\r\n            CASE WHEN ${taker.side} = 'buy' THEN price END ASC,\r\n            CASE WHEN ${taker.side} = 'sell' THEN price END DESC,\r\n            created_at ASC\r\n          LIMIT 200\r\n          FOR UPDATE\r\n        `;\r\n\r\n        const makersById = new Map(makers.map((m) => [m.id, m] as const));\r\n\r\n        const planned = isMarket\r\n          ? planMarketMatches({\r\n              taker: {\r\n                id: taker.id,\r\n                side: taker.side,\r\n                remaining_quantity: takerRemaining,\r\n                created_at: taker.created_at,\r\n              },\r\n              makers: makers.map((m) => ({\r\n                id: m.id,\r\n                side: m.side,\r\n                price: m.price,\r\n                remaining_quantity: m.remaining_quantity,\r\n                created_at: m.created_at,\r\n              })),\r\n              maxFills: 1,\r\n            })\r\n          : planLimitMatches({\r\n              taker: {\r\n                id: taker.id,\r\n                side: taker.side,\r\n                price: taker.price,\r\n                remaining_quantity: takerRemaining,\r\n                created_at: taker.created_at,\r\n              },\r\n              makers: makers.map((m) => ({\r\n                id: m.id,\r\n                side: m.side,\r\n                price: m.price,\r\n                remaining_quantity: m.remaining_quantity,\r\n                created_at: m.created_at,\r\n              })),\r\n              maxFills: 1,\r\n            });\r\n\r\n        const fill = planned.fills[0] ?? null;\r\n        if (!fill) break;\r\n\r\n        const maker = makersById.get(fill.maker_order_id);\r\n        if (!maker) break;\r\n\r\n        const fillQty = fill.quantity;\r\n        if (isZeroOrLess3818(fillQty)) continue;\r\n\r\n        const execPrice = fill.price; // maker price (price-time priority)\r\n\r\n        // Settlement amounts\r\n        const quoteAmt = quoteAmountForFill(fillQty, execPrice);\r\n\r\n        const makerFeeQuote = bpsFeeCeil3818(quoteAmt, market.maker_fee_bps ?? 0);\r\n        const takerFeeQuote = bpsFeeCeil3818(quoteAmt, market.taker_fee_bps ?? 0);\r\n\r\n        const buyerUserId = taker.side === \"buy\" ? taker.user_id : maker.user_id;\r\n        const sellerUserId = taker.side === \"sell\" ? taker.user_id : maker.user_id;\r\n\r\n        // Ensure accounts exist\r\n        const acctRows = await txSql<{ user_id: string; asset_id: string; id: string }[]>`\r\n          WITH upserts AS (\r\n            INSERT INTO ex_ledger_account (user_id, asset_id)\r\n            VALUES\r\n              (${buyerUserId}::uuid, ${market.base_asset_id}::uuid),\r\n              (${buyerUserId}::uuid, ${market.quote_asset_id}::uuid),\r\n              (${sellerUserId}::uuid, ${market.base_asset_id}::uuid),\r\n              (${sellerUserId}::uuid, ${market.quote_asset_id}::uuid)\r\n            ON CONFLICT (user_id, asset_id) DO UPDATE SET user_id = EXCLUDED.user_id\r\n            RETURNING user_id, asset_id, id\r\n          )\r\n          SELECT user_id::text AS user_id, asset_id::text AS asset_id, id::text AS id FROM upserts\r\n        `;\r\n\r\n        const acct = (userId: string, assetId: string) => acctRows.find((r) => r.user_id === userId && r.asset_id === assetId)?.id;\r\n\r\n        const buyerBaseAcct = acct(buyerUserId, market.base_asset_id);\r\n        const buyerQuoteAcct = acct(buyerUserId, market.quote_asset_id);\r\n        const sellerBaseAcct = acct(sellerUserId, market.base_asset_id);\r\n        const sellerQuoteAcct = acct(sellerUserId, market.quote_asset_id);\r\n        if (!buyerBaseAcct || !buyerQuoteAcct || !sellerBaseAcct || !sellerQuoteAcct) {\r\n          return { status: 500 as const, body: { error: \"not_found\", details: \"missing_accounts\" } };\r\n        }\r\n\r\n        const makerQuoteAcct = acct(maker.user_id, market.quote_asset_id);\r\n        const takerQuoteAcct = acct(taker.user_id, market.quote_asset_id);\r\n        if (!makerQuoteAcct || !takerQuoteAcct) {\r\n          return { status: 500 as const, body: { error: \"not_found\", details: \"missing_accounts_maker_taker\" } };\r\n        }\r\n\r\n        const feeAcctRows = await txSql<{ id: string }[]>`\r\n          INSERT INTO ex_ledger_account (user_id, asset_id)\r\n          VALUES (${SYSTEM_FEE_USER_ID}::uuid, ${market.quote_asset_id}::uuid)\r\n          ON CONFLICT (user_id, asset_id) DO UPDATE SET user_id = EXCLUDED.user_id\r\n          RETURNING id\r\n        `;\r\n        const feeCollectorQuoteAcct = feeAcctRows[0]?.id;\r\n        if (!feeCollectorQuoteAcct) {\r\n          return { status: 500 as const, body: { error: \"not_found\", details: \"missing_fee_collector_account\" } };\r\n        }\r\n\r\n        // Create execution\r\n        const execRows = await txSql<{ id: string; created_at: string }[]>`\r\n          INSERT INTO ex_execution (market_id, price, quantity, maker_order_id, taker_order_id, maker_fee_quote, taker_fee_quote)\r\n          VALUES (\r\n            ${market.id}::uuid,\r\n            (${execPrice}::numeric),\r\n            (${fillQty}::numeric),\r\n            ${maker.id}::uuid,\r\n            ${taker.id}::uuid,\r\n            (${makerFeeQuote}::numeric),\r\n            (${takerFeeQuote}::numeric)\r\n          )\r\n          RETURNING id, created_at\r\n        `;\r\n        executions.push({\r\n          id: execRows[0]!.id,\r\n          price: execPrice,\r\n          quantity: fillQty,\r\n          maker_order_id: maker.id,\r\n          taker_order_id: taker.id,\r\n          created_at: execRows[0]!.created_at,\r\n        });\r\n\r\n        // Ledger journal entry (balanced per asset)\r\n        const entryRows = await (txSql as any)<{ id: string }[]>`\r\n          INSERT INTO ex_journal_entry (type, reference, metadata_json)\r\n          VALUES (\r\n            'trade',\r\n            ${`${market.symbol} ${fillQty}@${execPrice}`},\r\n            ${{ market_id: market.id, maker_order_id: maker.id, taker_order_id: taker.id }}::jsonb\r\n          )\r\n          RETURNING id\r\n        `;\r\n        const entryId = entryRows[0]!.id;\r\n\r\n        await txSql`\r\n          INSERT INTO ex_journal_line (entry_id, account_id, asset_id, amount)\r\n          VALUES\r\n            -- base: buyer +qty, seller -qty\r\n            (${entryId}::uuid, ${buyerBaseAcct}::uuid, ${market.base_asset_id}::uuid, (${fillQty}::numeric)),\r\n            (${entryId}::uuid, ${sellerBaseAcct}::uuid, ${market.base_asset_id}::uuid, ((${fillQty}::numeric) * -1)),\r\n            -- quote: buyer -q, seller +q\r\n            (${entryId}::uuid, ${buyerQuoteAcct}::uuid, ${market.quote_asset_id}::uuid, ((${quoteAmt}::numeric) * -1)),\r\n            (${entryId}::uuid, ${sellerQuoteAcct}::uuid, ${market.quote_asset_id}::uuid, (${quoteAmt}::numeric))\r\n        `;\r\n\r\n        // Fees in quote asset: debit maker/taker quote accounts, credit fee collector.\r\n        const feeLines: Array<{ accountId: string; amountSigned: string }> = [];\r\n        if (!isZeroOrLess3818(makerFeeQuote)) {\r\n          feeLines.push({ accountId: makerQuoteAcct, amountSigned: `-${makerFeeQuote}` });\r\n        }\r\n        if (!isZeroOrLess3818(takerFeeQuote)) {\r\n          feeLines.push({ accountId: takerQuoteAcct, amountSigned: `-${takerFeeQuote}` });\r\n        }\r\n\r\n        if (feeLines.length > 0) {\r\n          // We can't build a SQL VALUES list with dynamic row count via postgres.js template safely here,\r\n          // so insert fee lines with separate statements (small N, safe for MVP).\r\n          for (const fl of feeLines) {\r\n            await txSql`\r\n              INSERT INTO ex_journal_line (entry_id, account_id, asset_id, amount)\r\n              VALUES (${entryId}::uuid, ${fl.accountId}::uuid, ${market.quote_asset_id}::uuid, (${fl.amountSigned}::numeric))\r\n            `;\r\n          }\r\n\r\n          let totalFeeScaled = 0n;\r\n          if (!isZeroOrLess3818(makerFeeQuote)) totalFeeScaled += toBigInt3818(makerFeeQuote);\r\n          if (!isZeroOrLess3818(takerFeeQuote)) totalFeeScaled += toBigInt3818(takerFeeQuote);\r\n          const feeCredit = fromBigInt3818(totalFeeScaled);\r\n\r\n          await txSql`\r\n            INSERT INTO ex_journal_line (entry_id, account_id, asset_id, amount)\r\n            VALUES (${entryId}::uuid, ${feeCollectorQuoteAcct}::uuid, ${market.quote_asset_id}::uuid, (${feeCredit}::numeric))\r\n          `;\r\n        }\r\n\r\n        // Update orders remaining + status\r\n        await txSql`\r\n          UPDATE ex_order\r\n          SET\r\n            remaining_quantity = CASE\r\n              WHEN (remaining_quantity - (${fillQty}::numeric)) <= 0\r\n                AND iceberg_hidden_remaining > 0\r\n                AND iceberg_display_quantity IS NOT NULL\r\n              THEN LEAST(iceberg_display_quantity, iceberg_hidden_remaining)\r\n              ELSE remaining_quantity - (${fillQty}::numeric)\r\n            END,\r\n            iceberg_hidden_remaining = CASE\r\n              WHEN (remaining_quantity - (${fillQty}::numeric)) <= 0\r\n                AND iceberg_hidden_remaining > 0\r\n                AND iceberg_display_quantity IS NOT NULL\r\n              THEN GREATEST(iceberg_hidden_remaining - LEAST(iceberg_display_quantity, iceberg_hidden_remaining), 0)\r\n              ELSE iceberg_hidden_remaining\r\n            END,\r\n            created_at = CASE\r\n              WHEN (remaining_quantity - (${fillQty}::numeric)) <= 0\r\n                AND iceberg_hidden_remaining > 0\r\n                AND iceberg_display_quantity IS NOT NULL\r\n              THEN now()\r\n              ELSE created_at\r\n            END,\r\n            status = CASE\r\n              WHEN (remaining_quantity - (${fillQty}::numeric)) <= 0\r\n                AND iceberg_hidden_remaining > 0\r\n                AND iceberg_display_quantity IS NOT NULL\r\n              THEN 'partially_filled'\r\n              WHEN (remaining_quantity - (${fillQty}::numeric)) <= 0 THEN 'filled'\r\n              ELSE 'partially_filled'\r\n            END,\r\n            updated_at = now()\r\n          WHERE id = ${maker.id}::uuid\r\n        `;\r\n\r\n        // Track maker fill for notification\r\n        const makerAfterRows = await txSql<{ remaining: string; hidden: string; status: string }[]>`\r\n          SELECT remaining_quantity::text AS remaining, iceberg_hidden_remaining::text AS hidden, status\r\n          FROM ex_order\r\n          WHERE id = ${maker.id}::uuid\r\n          LIMIT 1\r\n        `;\r\n        const makerAfter = makerAfterRows[0];\r\n        const makerIsFilled = makerAfter?.status === \"filled\" ||\r\n          (makerAfter ? (isZeroOrLess3818(makerAfter.remaining) && isZeroOrLess3818(makerAfter.hidden)) : false);\r\n        makerFillNotifs.push({\r\n          userId: maker.user_id,\r\n          orderId: maker.id,\r\n          side: maker.side,\r\n          fillQty,\r\n          price: execPrice,\r\n          isFilled: makerIsFilled,\r\n        });\r\n\r\n        await txSql`\r\n          UPDATE ex_order\r\n          SET\r\n            remaining_quantity = CASE\r\n              WHEN (remaining_quantity - (${fillQty}::numeric)) <= 0\r\n                AND iceberg_hidden_remaining > 0\r\n                AND iceberg_display_quantity IS NOT NULL\r\n              THEN LEAST(iceberg_display_quantity, iceberg_hidden_remaining)\r\n              ELSE remaining_quantity - (${fillQty}::numeric)\r\n            END,\r\n            iceberg_hidden_remaining = CASE\r\n              WHEN (remaining_quantity - (${fillQty}::numeric)) <= 0\r\n                AND iceberg_hidden_remaining > 0\r\n                AND iceberg_display_quantity IS NOT NULL\r\n              THEN GREATEST(iceberg_hidden_remaining - LEAST(iceberg_display_quantity, iceberg_hidden_remaining), 0)\r\n              ELSE iceberg_hidden_remaining\r\n            END,\r\n            created_at = CASE\r\n              WHEN (remaining_quantity - (${fillQty}::numeric)) <= 0\r\n                AND iceberg_hidden_remaining > 0\r\n                AND iceberg_display_quantity IS NOT NULL\r\n              THEN now()\r\n              ELSE created_at\r\n            END,\r\n            status = CASE\r\n              WHEN (remaining_quantity - (${fillQty}::numeric)) <= 0\r\n                AND iceberg_hidden_remaining > 0\r\n                AND iceberg_display_quantity IS NOT NULL\r\n              THEN 'partially_filled'\r\n              WHEN (remaining_quantity - (${fillQty}::numeric)) <= 0 THEN 'filled'\r\n              ELSE 'partially_filled'\r\n            END,\r\n            updated_at = now()\r\n          WHERE id = ${taker.id}::uuid\r\n        `;\r\n\r\n        // Consume holds proportionally\r\n        const makerConsume = consumeAmountForHold(maker.side, fillQty, quoteAmt, makerFeeQuote);\r\n        const takerConsume = consumeAmountForHold(taker.side, fillQty, quoteAmt, takerFeeQuote);\r\n\r\n        if (maker.hold_id) {\r\n          await txSql`\r\n            UPDATE ex_hold\r\n            SET\r\n              remaining_amount = greatest(remaining_amount - (${makerConsume}::numeric), 0),\r\n              status = CASE\r\n                WHEN (remaining_amount - (${makerConsume}::numeric)) <= 0 THEN 'consumed'\r\n                ELSE status\r\n              END\r\n            WHERE id = ${maker.hold_id}::uuid AND status = 'active'\r\n          `;\r\n        }\r\n\r\n        if (taker.hold_id) {\r\n          await txSql`\r\n            UPDATE ex_hold\r\n            SET\r\n              remaining_amount = greatest(remaining_amount - (${takerConsume}::numeric), 0),\r\n              status = CASE\r\n                WHEN (remaining_amount - (${takerConsume}::numeric)) <= 0 THEN 'consumed'\r\n                ELSE status\r\n              END\r\n            WHERE id = ${taker.hold_id}::uuid AND status = 'active'\r\n          `;\r\n        }\r\n\r\n        await finalizeHoldIfTerminal(maker.id, maker.hold_id);\r\n        await finalizeHoldIfTerminal(taker.id, taker.hold_id);\r\n\r\n        // Refresh taker snapshot\r\n        const takerRows = await txSql<OrderRow[]>`\r\n          SELECT\r\n            id,\r\n            market_id,\r\n            user_id,\r\n            side,\r\n            type,\r\n            price::text AS price,\r\n            quantity::text AS quantity,\r\n            remaining_quantity::text AS remaining_quantity,\r\n            status,\r\n            hold_id,\r\n            created_at,\r\n            updated_at\r\n          FROM ex_order\r\n          WHERE id = ${taker.id}::uuid\r\n          LIMIT 1\r\n        `;\r\n        taker = takerRows[0]!;\r\n\r\n        fillCount += 1;\r\n      }\r\n\r\n      await finalizeHoldIfTerminal(taker.id, taker.hold_id);\r\n\r\n      // --- IOC cancellation for market orders: cancel any unfilled remainder ---\r\n      if (isMarket && !isZeroOrLess3818(taker.remaining_quantity) && taker.status !== \"filled\") {\r\n        await txSql`\r\n          UPDATE ex_order\r\n          SET status = 'canceled', updated_at = now()\r\n          WHERE id = ${taker.id}::uuid\r\n            AND status IN ('open', 'partially_filled')\r\n        `;\r\n\r\n        // Release the hold for any remaining amount\r\n        await finalizeHoldIfTerminal(taker.id, taker.hold_id);\r\n\r\n        // Refresh taker snapshot\r\n        const canceledRows = await txSql<OrderRow[]>`\r\n          SELECT\r\n            id, market_id, user_id, side, type,\r\n            price::text AS price, quantity::text AS quantity,\r\n            remaining_quantity::text AS remaining_quantity,\r\n            status, hold_id, created_at, updated_at\r\n          FROM ex_order WHERE id = ${taker.id}::uuid LIMIT 1\r\n        `;\r\n        taker = canceledRows[0]!;\r\n      }\r\n\r\n      // --- IOC cancellation for limit orders ---\r\n      if (!isMarket && timeInForce === \"IOC\" && !isZeroOrLess3818(taker.remaining_quantity) && taker.status !== \"filled\") {\r\n        await txSql`\r\n          UPDATE ex_order\r\n          SET status = 'canceled', updated_at = now()\r\n          WHERE id = ${taker.id}::uuid\r\n            AND status IN ('open', 'partially_filled')\r\n        `;\r\n\r\n        await finalizeHoldIfTerminal(taker.id, taker.hold_id);\r\n\r\n        const canceledRows = await txSql<OrderRow[]>`\r\n          SELECT\r\n            id, market_id, user_id, side, type,\r\n            price::text AS price, quantity::text AS quantity,\r\n            remaining_quantity::text AS remaining_quantity,\r\n            status, hold_id, created_at, updated_at\r\n          FROM ex_order WHERE id = ${taker.id}::uuid LIMIT 1\r\n        `;\r\n        taker = canceledRows[0]!;\r\n      }\r\n\r\n      // --- Notifications for makers ---\r\n      for (const mf of makerFillNotifs) {\r\n        await createNotification(txSql, {\r\n          userId: mf.userId,\r\n          type: mf.isFilled ? \"order_filled\" : \"order_partially_filled\",\r\n          title: mf.isFilled ? \"Order Filled\" : \"Order Partially Filled\",\r\n          body: `Your ${mf.side} order was ${mf.isFilled ? \"fully\" : \"partially\"} filled: ${mf.fillQty} @ ${mf.price} on ${market.symbol}`,\r\n          metadata: { orderId: mf.orderId, fillQty: mf.fillQty, price: mf.price, market: market.symbol },\r\n        });\r\n      }\r\n\r\n      // --- Notification for taker ---\r\n      if (executions.length > 0 || taker.status === \"canceled\") {\r\n        const notifType =\r\n          taker.status === \"filled\"\r\n            ? \"order_filled\"\r\n            : taker.status === \"canceled\"\r\n              ? \"order_canceled\"\r\n              : \"order_partially_filled\";\r\n        const notifTitle =\r\n          taker.status === \"filled\"\r\n            ? \"Order Filled\"\r\n            : taker.status === \"canceled\"\r\n              ? (isMarket ? \"Market Order Canceled (IOC)\" : \"Limit Order Canceled (IOC)\")\r\n              : \"Order Partially Filled\";\r\n        await createNotification(txSql, {\r\n          userId: taker.user_id,\r\n          type: notifType as any,\r\n          title: notifTitle,\r\n          body: `Your ${taker.side} ${taker.type} order on ${market.symbol} â€” ${executions.length} fill(s)`,\r\n          metadata: { orderId: taker.id, market: market.symbol, fills: executions.length },\r\n        });\r\n      }\r\n\r\n      // --- Notification for an accepted open order (no immediate fills) ---\r\n      if (executions.length === 0 && (taker.status === \"open\" || taker.status === \"partially_filled\")) {\r\n        await createNotification(txSql, {\r\n          userId: taker.user_id,\r\n          type: \"order_placed\" as any,\r\n          title: \"Order Placed\",\r\n          body: `Your ${taker.side} ${taker.type} order was placed on ${market.symbol}.`,\r\n          metadata: { orderId: taker.id, market: market.symbol },\r\n        });\r\n      }\r\n\r\n      await enqueueOutbox(txSql, {\r\n        topic: \"ex.order.placed\",\r\n        aggregate_type: \"order\",\r\n        aggregate_id: taker.id,\r\n        payload: {\r\n          order: taker,\r\n          executions,\r\n        },\r\n      });\r\n\r\n      // Persist idempotency result (success only) so retries can safely replay.\r\n      if (idemKey) {\r\n        await txSql`\r\n          UPDATE app_idempotency_key\r\n          SET response_json = ${(txSql as any).json({ order: taker, executions })}::jsonb,\r\n              status_code = 201,\r\n              updated_at = now()\r\n          WHERE user_id = ${actingUserId}::uuid\r\n            AND scope = ${idemScope}\r\n            AND idem_key = ${idemKey}\r\n            AND request_hash = ${idemHash}\r\n        `;\r\n      }\r\n\r\n      return { status: 201 as const, body: { order: taker, executions } };\r\n    });\r\n\r\n    const err = result.body as { error?: string; details?: unknown };\r\n    if (typeof err.error === \"string\") {\r\n      // If we reserved an idempotency key but did not store a success response, release it.\r\n      if (idemKey) {\r\n        try {\r\n          await sql`\r\n            DELETE FROM app_idempotency_key\r\n            WHERE user_id = ${actingUserId}::uuid\r\n              AND scope = ${idemScope}\r\n              AND idem_key = ${idemKey}\r\n              AND status_code IS NULL\r\n          `;\r\n        } catch {\r\n          // ignore\r\n        }\r\n      }\r\n\r\n      // Best-effort: surface meaningful placement rejections as notifications.\r\n      // Avoid notifying on auth/validation errors to prevent spam.\r\n      try {\r\n        const rejectable = new Set([\r\n          \"insufficient_balance\",\r\n          \"insufficient_liquidity\",\r\n          \"post_only_would_take\",\r\n          \"fok_insufficient_liquidity\",\r\n          \"open_orders_limit\",\r\n          \"order_notional_too_large\",\r\n          \"exchange_price_out_of_band\",\r\n          \"market_halted\",\r\n          \"stp_cancel_newest\",\r\n          \"stp_cancel_both\",\r\n        ]);\r\n        if (rejectable.has(err.error)) {\r\n          const marketId = (body as any)?.market_id ?? null;\r\n          const side = (body as any)?.side ?? null;\r\n          const type = (body as any)?.type ?? null;\r\n          await createNotification(sql as any, {\r\n            userId: actingUserId,\r\n            type: \"order_rejected\",\r\n            title: \"Order Rejected\",\r\n            body: `Your order was rejected (${err.error}).`,\r\n            metadata: {\r\n              reason: err.error,\r\n              market_id: marketId,\r\n              side,\r\n              type,\r\n            },\r\n          });\r\n        }\r\n      } catch {\r\n        // ignore\r\n      }\r\n\r\n      return reply(apiError(err.error, { status: result.status, details: err.details }), { code: err.error });\r\n    }\r\n\r\n    const response = reply(Response.json(result.body, { status: result.status }), { orderId: (result.body as any)?.order?.id });\r\n\r\n    try {\r\n      const o = (result.body as any)?.order;\r\n      if (o?.id) {\r\n        // Audit Log\r\n        await writeAuditLog(sql, {\r\n          actorId: actingUserId,\r\n          actorType: \"user\",\r\n          action: \"order.placed\",\r\n          resourceType: \"order\",\r\n          resourceId: o.id,\r\n          ...auditContextFromRequest(request),\r\n          detail: { side: o.side, price: o.price, quantity: o.quantity, market_id: o.market_id },\r\n        });\r\n\r\n        // Trigger Copy Trading (Fire & Forget)\r\n        // We do NOT await this to avoid blocking the response to the leader.\r\n        // In serverless, this might be risky, but in a long-running Node process (e.g. standard Next.js container) it's fine.\r\n        // Ideally use `waitUntil` if available (Vercel/Cloudflare).\r\n        // Since we don't have waitUntil here easily, we just don't await.\r\n        propagateLeaderOrder(sql, {\r\n             leaderUserId: actingUserId,\r\n             marketId: o.market_id,\r\n             side: o.side,\r\n             type: o.type,\r\n             price: o.price,\r\n             quantity: o.quantity\r\n        }).catch(err => console.error(\"Copy trading propagation failed:\", err));\r\n      }\r\n    } catch { /* audit log failure must not block */ }\r\n\r\n    return response;\r\n  } catch (e) {\r\n    const resp = responseForDbError(\"exchange.orders.place\", e);\r\n    if (resp) return reply(resp, { code: \"db_error\" });\r\n    throw e;\r\n  }\r\n}\r\n","import { cmp3818, isZeroOrLess3818, min3818, sub3818NonNegative } from \"@/lib/exchange/fixed3818\";\r\nimport type { OrderSide } from \"@/lib/exchange/orderMath\";\r\n\r\nexport type MatchableOrder = {\r\n  id: string;\r\n  side: OrderSide;\r\n  price: string;\r\n  remaining_quantity: string;\r\n  created_at: string; // ISO timestamp\r\n};\r\n\r\nexport type PlannedFill = {\r\n  maker_order_id: string;\r\n  taker_order_id: string;\r\n  price: string; // maker price\r\n  quantity: string;\r\n};\r\n\r\nfunction isPriceCrossed(takerSide: OrderSide, takerPrice: string, makerPrice: string): boolean {\r\n  // For a buy taker, we cross if maker ask <= taker price.\r\n  // For a sell taker, we cross if maker bid >= taker price.\r\n  const c = cmp3818(makerPrice, takerPrice);\r\n  return takerSide === \"buy\" ? c <= 0 : c >= 0;\r\n}\r\n\r\nfunction bookSortForTaker(takerSide: OrderSide) {\r\n  return (a: MatchableOrder, b: MatchableOrder) => {\r\n    // Price-time priority\r\n    if (takerSide === \"buy\") {\r\n      // Prefer lowest sell price\r\n      const priceCmp = cmp3818(a.price, b.price);\r\n      if (priceCmp !== 0) return priceCmp;\r\n    } else {\r\n      // Prefer highest buy price\r\n      const priceCmp = cmp3818(b.price, a.price);\r\n      if (priceCmp !== 0) return priceCmp;\r\n    }\r\n\r\n    // Earlier order first\r\n    if (a.created_at < b.created_at) return -1;\r\n    if (a.created_at > b.created_at) return 1;\r\n    return a.id < b.id ? -1 : a.id > b.id ? 1 : 0;\r\n  };\r\n}\r\n\r\nexport function planLimitMatches(params: {\r\n  taker: MatchableOrder;\r\n  makers: MatchableOrder[];\r\n  maxFills?: number;\r\n}): { fills: PlannedFill[]; taker_remaining_quantity: string; maker_remaining_by_id: Record<string, string> } {\r\n  const { taker } = params;\r\n  const maxFills = params.maxFills ?? 200;\r\n\r\n  const makers = params.makers\r\n    .filter((m) => m.side !== taker.side)\r\n    .filter((m) => !isZeroOrLess3818(m.remaining_quantity))\r\n    .slice()\r\n    .sort(bookSortForTaker(taker.side));\r\n\r\n  let takerRemaining = taker.remaining_quantity;\r\n  const makerRemaining = new Map<string, string>();\r\n  for (const m of makers) makerRemaining.set(m.id, m.remaining_quantity);\r\n\r\n  const fills: PlannedFill[] = [];\r\n\r\n  for (let i = 0; i < makers.length && fills.length < maxFills; i++) {\r\n    if (isZeroOrLess3818(takerRemaining)) break;\r\n\r\n    const maker = makers[i]!;\r\n    const makerRem = makerRemaining.get(maker.id) ?? \"0\";\r\n    if (isZeroOrLess3818(makerRem)) continue;\r\n\r\n    if (!isPriceCrossed(taker.side, taker.price, maker.price)) break;\r\n\r\n    const qty = min3818(takerRemaining, makerRem);\r\n    if (isZeroOrLess3818(qty)) break;\r\n\r\n    fills.push({\r\n      maker_order_id: maker.id,\r\n      taker_order_id: taker.id,\r\n      price: maker.price,\r\n      quantity: qty,\r\n    });\r\n\r\n    // Update remaining quantities\r\n    takerRemaining = sub3818NonNegative(takerRemaining, qty);\r\n    const makerNewRem = sub3818NonNegative(makerRem, qty);\r\n    makerRemaining.set(maker.id, makerNewRem);\r\n  }\r\n\r\n  return {\r\n    fills,\r\n    taker_remaining_quantity: takerRemaining,\r\n    maker_remaining_by_id: Object.fromEntries(makerRemaining.entries()),\r\n  };\r\n}\r\n\r\n/**\r\n * Plan fills for a market order (IOC semantics â€” no price limit).\r\n * Matches against all resting orders at their prices.\r\n */\r\nexport function planMarketMatches(params: {\r\n  taker: Omit<MatchableOrder, \"price\"> & { side: OrderSide };\r\n  makers: MatchableOrder[];\r\n  maxFills?: number;\r\n}): { fills: PlannedFill[]; taker_remaining_quantity: string; maker_remaining_by_id: Record<string, string> } {\r\n  // Synthetic extreme price ensures every resting order crosses.\r\n  const syntheticPrice =\r\n    params.taker.side === \"buy\"\r\n      ? \"999999999999999999.000000000000000000\"\r\n      : \"0.000000000000000001\";\r\n\r\n  return planLimitMatches({\r\n    taker: { ...params.taker, price: syntheticPrice },\r\n    makers: params.makers,\r\n    maxFills: params.maxFills,\r\n  });\r\n}\r\n","import {\r\n  add3818,\r\n  bpsFeeCeil3818,\r\n  cmp3818,\r\n  fromBigInt3818,\r\n  isZeroOrLess3818,\r\n  min3818,\r\n  mul3818Ceil,\r\n  mul3818Round,\r\n  sub3818NonNegative,\r\n  toBigInt3818,\r\n} from \"@/lib/exchange/fixed3818\";\r\n\r\nexport type OrderSide = \"buy\" | \"sell\";\r\nexport type OrderStatus = \"open\" | \"partially_filled\" | \"filled\";\r\n\r\nexport function orderStatusForRemaining(\r\n  remainingQuantity: string,\r\n  originalQuantity: string\r\n): OrderStatus {\r\n  if (isZeroOrLess3818(remainingQuantity)) return \"filled\";\r\n  if (cmp3818(remainingQuantity, originalQuantity) < 0) return \"partially_filled\";\r\n  return \"open\";\r\n}\r\n\r\nexport function reserveAmountForLimitOrder(\r\n  side: OrderSide,\r\n  price: string,\r\n  quantity: string,\r\n  opts?: { maxFeeBps?: number }\r\n): string {\r\n  if (side !== \"buy\") return quantity;\r\n\r\n  const grossQuote = mul3818Ceil(price, quantity);\r\n  const maxFeeBps = opts?.maxFeeBps ?? 0;\r\n  const feeQuote = bpsFeeCeil3818(grossQuote, maxFeeBps);\r\n  return add3818(grossQuote, feeQuote);\r\n}\r\n\r\nexport function fillQuantity(takerRemaining: string, makerRemaining: string): string {\r\n  return min3818(takerRemaining, makerRemaining);\r\n}\r\n\r\nexport function quoteAmountForFill(fillQty: string, execPrice: string): string {\r\n  return mul3818Round(fillQty, execPrice);\r\n}\r\n\r\nexport function consumeAmountForHold(\r\n  side: OrderSide,\r\n  fillQty: string,\r\n  quoteAmt: string,\r\n  feeQuote: string = \"0\"\r\n): string {\r\n  // Sell orders reserve base; buy orders reserve quote.\r\n  return side === \"sell\" ? fillQty : add3818(quoteAmt, feeQuote);\r\n}\r\n\r\n/**\r\n * Estimate reserve for a market buy by summing price*qty across resting asks,\r\n * plus fee buffer and 1% slippage buffer.\r\n * Returns null if insufficient resting liquidity.\r\n */\r\nexport function estimateMarketBuyReserve(\r\n  quantity: string,\r\n  asks: { price: string; remaining_quantity: string }[],\r\n  opts?: { maxFeeBps?: number },\r\n): string | null {\r\n  let qtyNeeded = quantity;\r\n  let estimatedCostScaled = 0n;\r\n\r\n  for (const ask of asks) {\r\n    if (isZeroOrLess3818(qtyNeeded)) break;\r\n    const fillQty = min3818(qtyNeeded, ask.remaining_quantity);\r\n    estimatedCostScaled += toBigInt3818(mul3818Ceil(fillQty, ask.price));\r\n    qtyNeeded = sub3818NonNegative(qtyNeeded, fillQty);\r\n  }\r\n\r\n  // Not enough resting liquidity\r\n  if (!isZeroOrLess3818(qtyNeeded)) return null;\r\n\r\n  const estimatedCost = fromBigInt3818(estimatedCostScaled);\r\n  const feeEstimate = bpsFeeCeil3818(estimatedCost, opts?.maxFeeBps ?? 0);\r\n  const slippageBuffer = bpsFeeCeil3818(estimatedCost, 100); // 1%\r\n  return add3818(add3818(estimatedCost, feeEstimate), slippageBuffer);\r\n}\r\n"],"names":[],"mappings":"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"}