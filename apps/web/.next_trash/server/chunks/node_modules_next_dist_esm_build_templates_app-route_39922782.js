module.exports=[600738,e=>{"use strict";var t=e.i(747909),i=e.i(174017),a=e.i(996250),r=e.i(759756),n=e.i(561916),s=e.i(174677),o=e.i(869741),d=e.i(316795),l=e.i(487718),u=e.i(995169),_=e.i(47587),p=e.i(666012),m=e.i(570101),E=e.i(626937),c=e.i(10372),h=e.i(193695);e.i(52474);var f=e.i(600220),N=e.i(89171),g=e.i(469719),S=e.i(843793),y=e.i(300959),R=e.i(977775),A=e.i(364608),b=e.i(332935),T=e.i(842026),x=e.i(60828);let v=g.z.object({side:g.z.enum(["BUY","SELL"]).default("BUY"),asset:g.z.string().default("USDT"),fiat:g.z.string().default("USD"),amount:g.z.coerce.number().optional()}),C=g.z.object({side:g.z.enum(["BUY","SELL"]),asset:g.z.string().min(2).max(12).transform(e=>e.trim().toUpperCase()),fiat:g.z.string().min(2).max(5),price_type:g.z.enum(["fixed","floating"]).default("fixed"),fixed_price:g.z.number().positive(),total_amount:g.z.number().positive(),min_limit:g.z.number().positive(),max_limit:g.z.number().positive(),terms:g.z.string().optional(),payment_window_minutes:g.z.number().min(15).max(180).default(15),payment_methods:g.z.array(g.z.string().uuid()).optional(),use_highlight_boost:g.z.boolean().optional().default(!1)}).superRefine((e,t)=>{"SELL"!==e.side||e.payment_methods&&0!==e.payment_methods.length||t.addIssue({code:g.z.ZodIssueCode.custom,path:["payment_methods"],message:"SELL ads must include at least one payment method."}),e.min_limit>e.max_limit&&t.addIssue({code:g.z.ZodIssueCode.custom,path:["min_limit"],message:"min_limit must be <= max_limit."})});function L(e,t,i){return Number.isFinite(e)?Math.min(i,Math.max(t,e)):t}async function D(e){try{let t=new URL(e.url),i=v.safeParse(Object.fromEntries(t.searchParams));if(!i.success)return(0,y.apiZodError)(i.error)??(0,y.apiError)("invalid_input");let{side:a,asset:r,fiat:n,amount:s}=i.data,o=(0,S.getSql)(),d=new Set(String(process.env.P2P_AGENT_EMAILS??"").split(",").map(e=>e.trim().toLowerCase()).filter(Boolean)),l=n.toUpperCase(),u=r.toUpperCase(),_="BUY"===a?"SELL":"BUY",[p]=await o`
      SELECT id
      FROM ex_asset
      WHERE symbol = ${u}
        AND chain = 'bsc'
        AND is_enabled = true
      LIMIT 1
    `;if(!p)return N.NextResponse.json({ads:[]});let m=await o`
      SELECT 
        ad.id,
        ad.user_id,
        ad.side,
        ad.fiat_currency,
        ad.price_type,
        ad.fixed_price,
        ad.margin_percent,
        ad.remaining_amount,
        ad.min_limit,
        ad.max_limit,
        ad.payment_window_minutes,
        ad.payment_method_ids,
        (
          SELECT coalesce(array_agg(DISTINCT pm.identifier), ARRAY[]::text[])
          FROM p2p_payment_method pm
          WHERE pm.user_id = ad.user_id
            AND pm.is_enabled = true
            AND pm.id::text = ANY(
              CASE
                WHEN jsonb_typeof(
                  CASE
                    WHEN jsonb_typeof(ad.payment_method_ids) = 'array' THEN ad.payment_method_ids
                    WHEN jsonb_typeof(ad.payment_method_ids) = 'string' AND left((ad.payment_method_ids #>> '{}'), 1) = '[' THEN (ad.payment_method_ids #>> '{}')::jsonb
                    ELSE '[]'::jsonb
                  END
                ) = 'array' THEN (
                  SELECT array_agg(x)
                  FROM jsonb_array_elements_text(
                    CASE
                      WHEN jsonb_typeof(ad.payment_method_ids) = 'array' THEN ad.payment_method_ids
                      WHEN jsonb_typeof(ad.payment_method_ids) = 'string' AND left((ad.payment_method_ids #>> '{}'), 1) = '[' THEN (ad.payment_method_ids #>> '{}')::jsonb
                      ELSE '[]'::jsonb
                    END
                  ) AS x
                )
                ELSE ARRAY[]::text[]
              END
            )
        ) AS payment_methods,
        u.email,
        u.display_name,
        coalesce(rep.positive, 0)::int AS rep_positive,
        coalesce(rep.negative, 0)::int AS rep_negative,
        coalesce(rep.total, 0)::int AS rep_total,
        (
          SELECT count(*)::int
          FROM p2p_order o
          WHERE o.status = 'completed'
            AND (o.buyer_id = ad.user_id OR o.seller_id = ad.user_id)
        ) AS completed_count,
        ad.terms,
        ad.highlighted_until
      FROM p2p_ad ad
      JOIN app_user u ON ad.user_id = u.id
      LEFT JOIN (
        SELECT
          to_user_id,
          sum(CASE WHEN rating = 'positive' THEN 1 ELSE 0 END)::int AS positive,
          sum(CASE WHEN rating = 'negative' THEN 1 ELSE 0 END)::int AS negative,
          count(*)::int AS total
        FROM p2p_feedback
        GROUP BY to_user_id
      ) rep ON rep.to_user_id = ad.user_id
      WHERE ad.status = 'online'
        AND ad.side = ${_}
        AND ad.asset_id = ${p.id}
        AND ad.fiat_currency = ${l}
        ${s?o`AND ad.min_limit <= ${s} AND ad.max_limit >= ${s}`:o``}
        AND ad.remaining_amount > 0
        ${"SELL"===_?o`
              AND EXISTS (
                SELECT 1
                FROM p2p_payment_method pm2
                WHERE pm2.user_id = ad.user_id
                  AND pm2.is_enabled = true
                  AND pm2.id::text = ANY(
                    CASE
                      WHEN jsonb_typeof(
                        CASE
                          WHEN jsonb_typeof(ad.payment_method_ids) = 'array' THEN ad.payment_method_ids
                          WHEN jsonb_typeof(ad.payment_method_ids) = 'string' AND left((ad.payment_method_ids #>> '{}'), 1) = '[' THEN (ad.payment_method_ids #>> '{}')::jsonb
                          ELSE '[]'::jsonb
                        END
                      ) = 'array' THEN (
                        SELECT array_agg(x)
                        FROM jsonb_array_elements_text(
                          CASE
                            WHEN jsonb_typeof(ad.payment_method_ids) = 'array' THEN ad.payment_method_ids
                            WHEN jsonb_typeof(ad.payment_method_ids) = 'string' AND left((ad.payment_method_ids #>> '{}'), 1) = '[' THEN (ad.payment_method_ids #>> '{}')::jsonb
                            ELSE '[]'::jsonb
                          END
                        ) AS x
                      )
                      ELSE ARRAY[]::text[]
                    END
                  )
                  AND pm2.details IS NOT NULL
                  AND jsonb_typeof(pm2.details) = 'object'
                  AND pm2.details <> '{}'::jsonb
              )
            `:o``}
      ORDER BY ad.created_at DESC
      LIMIT 200
    `,E=await (0,b.getOrComputeFxReferenceRate)(o,u,l),c=E?.mid??null,h=Date.now(),f=(m??[]).map(e=>{let t=String(e.price_type??"fixed"),i=null;if("fixed"===t){let t=Number(e.fixed_price);i=Number.isFinite(t)&&t>0?t:null}else{let t=function(e){let t="number"==typeof e?e:"string"==typeof e?Number(e):NaN;if(!Number.isFinite(t))return null;let i=.5>=Math.abs(t)?1+t:t;return!Number.isFinite(i)||i<=0?null:Math.min(2.5,Math.max(.5,i))}(e.margin_percent);c&&t&&(i=c*t)}let a=e.highlighted_until,r=a?new Date(String(a)).getTime():NaN,n=!!Number.isFinite(r)&&r>h;return{...e,is_verified_agent:d.size>0&&d.has(String(e.email??"").toLowerCase()),fixed_price:null!==i?String(i):null,_display_price:i,_highlight_active:n}}).filter(e=>null!==e._display_price).sort((e,t)=>{let i=!!e._highlight_active,a=!!t._highlight_active;if(i!==a)return i?-1:1;let r=e._display_price,n=t._display_price;return"SELL"===_?r-n:n-r}).slice(0,50).map(e=>{let{_display_price:t,_highlight_active:i,...a}=e;return a});return N.NextResponse.json({ads:f})}catch(e){return(0,y.apiError)(e.message||"internal_error",{details:e})}}async function w(e){let t=(0,S.getSql)(),i=(0,R.getActingUserId)(e),a=(0,R.requireActingUserIdInProd)(i);if(a)return(0,y.apiError)(a);if(!i)return(0,y.apiError)("unauthorized",{status:401});try{let a=await (0,A.requireActiveUser)(t,i);if(a)return(0,y.apiError)(a);let n=await t`
      SELECT country, email_verified, kyc_level
      FROM app_user
      WHERE id = ${i}::uuid
      LIMIT 1
    `,s=n[0]?.country??null;if(!(0,T.isSupportedP2PCountry)(s))return(0,y.apiError)("p2p_country_not_supported",{status:403,details:{country:s}});let o=await e.json(),d=C.safeParse(o);if(!d.success)return(0,y.apiZodError)(d.error)??(0,y.apiError)("invalid_input");let l=d.data,u=Math.max(0,Math.min(100,Number(process.env.P2P_MAX_ONLINE_ADS_PER_USER??"3")));if(u>0){let e=await t`
        SELECT count(*)::int AS n
        FROM p2p_ad
        WHERE user_id = ${i}::uuid
          AND status = 'online'
      `,a=Number(e[0]?.n??0);if(Number.isFinite(a)&&a>=u)return(0,y.apiError)("ad_limit_reached",{status:409,details:{max_online_ads:u}})}if("SELL"===l.side){var r;let e;if(!n[0]?.email_verified)return(0,y.apiError)("email_not_verified",{status:403,details:{message:"Verify your email before posting SELL ads."}});if(r=n[0]?.kyc_level,e=String(r??"").trim().toLowerCase(),"basic"!==e&&"verified"!==e&&"full"!==e)return(0,y.apiError)("kyc_required",{status:403,details:{message:"Complete Basic KYC before posting SELL ads."}})}let _=l.fiat.toUpperCase(),p=L(Number(process.env.P2P_MIN_TRADE_USD??"5"),.5,1e4),m=L(Number(process.env.P2P_MAX_TRADE_USD??"2000"),p,1e5);if("SELL"===l.side){let e=L(Number(process.env.P2P_MIN_SELL_AD_TRADE_USD??"20"),.5,1e4);p=Math.max(p,e)}let E=await (0,b.getOrComputeFxReferenceRate)(t,"USDT",_);if(!E?.mid)return(0,y.apiError)("fx_unavailable",{status:503,details:{base:"USDT",quote:_}});let c=Math.ceil(p*E.mid),h=Math.floor(m*E.mid);if(!(Number.isFinite(c)&&Number.isFinite(h)&&c>0&&h>=c))return(0,y.apiError)("fx_unavailable",{status:503,details:{base:"USDT",quote:_}});if("SELL"===l.side){let e=L(Number(process.env.P2P_MIN_SELL_AD_TOTAL_USD??"50"),.5,1e5),t=Math.ceil(e*E.mid),i=Math.floor(l.total_amount*l.fixed_price);if(!Number.isFinite(i)||i<=0)return(0,y.apiError)("invalid_input",{details:{message:"Ad liquidity is too low."}});if(i<t)return(0,y.apiError)("ad_liquidity_too_low",{status:409,details:{total_fiat:i,required_min_total:t,fiat:_,min_total_usd:e}})}if(l.min_limit<c)return(0,y.apiError)("min_limit_too_low",{status:409,details:{min_limit:l.min_limit,required_min:c,fiat:_,min_usd:p}});if(l.max_limit>h)return(0,y.apiError)("max_limit_too_high",{status:409,details:{max_limit:l.max_limit,allowed_max:h,fiat:_,max_usd:m}});let f=[];if("SELL"===l.side&&(f=(function(e){let t=[],i=new Set;for(let a of e){let e=String(a);i.has(e)||(i.add(e),t.push(e))}return t})(l.payment_methods??[]).slice(0,3),(await t`
        SELECT id::text AS id
        FROM p2p_payment_method
        WHERE user_id = ${i}::uuid
          AND is_enabled = true
          AND id::text = ANY(${f})
      `).length!==f.length))return(0,y.apiError)("invalid_input",{details:{message:"One or more payment methods are invalid or not yours."}});let g=null,S=null,R=null;if("fixed"===l.price_type){let e=await (0,b.getOrComputeFxReferenceRate)(t,l.asset,_);e&&(g=e.mid,S=e.sources,R=e.computedAt)}let[v]=await t`
      SELECT id
      FROM ex_asset
      WHERE chain = 'bsc'
        AND is_enabled = true
        AND symbol = ${l.asset}
      LIMIT 1
    `;if(!v)return(0,y.apiError)("invalid_asset");let D=null;if("SELL"===l.side){D=(await t`
        INSERT INTO ex_ledger_account (user_id, asset_id)
        VALUES (${i}::uuid, ${v.id}::uuid)
        ON CONFLICT (user_id, asset_id) DO UPDATE SET user_id = EXCLUDED.user_id
        RETURNING id
      `)[0].id;let e=await t`
        WITH posted AS (
          SELECT coalesce(sum(amount), 0)::numeric AS posted
          FROM ex_journal_line
          WHERE account_id = ${D}::uuid
        ),
        held AS (
          SELECT coalesce(sum(remaining_amount), 0)::numeric AS held
          FROM ex_hold
          WHERE account_id = ${D}::uuid AND status = 'active'
        )
        SELECT
          posted.posted::text AS posted,
          held.held::text AS held,
          (posted.posted - held.held)::text AS available,
          ((posted.posted - held.held) >= (${l.total_amount}::numeric)) AS ok
        FROM posted, held
      `,a=Number(e[0]?.available??"0");if(!e[0]?.ok)return(0,y.apiError)("insufficient_funds",{details:{message:`You want to sell ${l.total_amount} ${l.asset}, but only have ${a} available (after escrow).`}})}let w=Math.floor(l.total_amount*l.fixed_price);if(w<=0)return(0,y.apiError)("invalid_input",{details:{message:"Ad liquidity is too low."}});let O=Math.min(l.max_limit,w);if(l.min_limit>O)return(0,y.apiError)("invalid_input",{details:{message:"min_limit must be <= max_limit."}});let $=await t.begin(async e=>{let t,a,[r]=await e`
        INSERT INTO p2p_ad (
          user_id, side, asset_id, fiat_currency,
          price_type, fixed_price, total_amount, remaining_amount,
          min_limit, max_limit, payment_window_minutes, terms,
          status, payment_method_ids,
          reference_mid, reference_sources, reference_computed_at, price_band_pct
        ) VALUES (
          ${i}, ${l.side}, ${v.id}, ${_},
          ${l.price_type}, ${l.fixed_price}, ${l.total_amount}, ${l.total_amount},
          ${l.min_limit}, ${O}, ${l.payment_window_minutes}, ${l.terms||""},
          'online', ${JSON.stringify(f)}::jsonb,
          ${g}, ${S?JSON.stringify(S):"{}"}::jsonb, ${R?R.toISOString():null},
          ${g?(t=l.fiat.toUpperCase(),a=Number(process.env[`P2P_PRICE_BAND_PCT_${t}`]??process.env.P2P_PRICE_BAND_PCT??"0.02"),!Number.isFinite(a)||a<=0?.02:Math.min(.25,Math.max(.001,a))):null}
        )
        RETURNING id
      `;if(l.use_highlight_boost){let t=await e`
          SELECT id::text AS id, quantity, metadata_json, code
          FROM arcade_inventory
          WHERE user_id = ${i}::uuid
            AND kind = 'boost'
            AND code = ANY(ARRAY['p2p_highlight_3','p2p_highlight_1']::text[])
          ORDER BY coalesce((metadata_json->>'duration_hours')::int, 0) DESC, updated_at DESC
          LIMIT 1
          FOR UPDATE
        `;if(!t.length||0>=Number(t[0].quantity??0))throw Error("no_highlight_boost");let a=t[0],n=Number(a.quantity??0),s=a.metadata_json?.duration_hours,o=Math.max(1,Math.min(720,Number(s??72)));1===n?await e`
            DELETE FROM arcade_inventory
            WHERE id = ${a.id}::uuid
          `:await e`
            UPDATE arcade_inventory
            SET quantity = ${n-1}, updated_at = now()
            WHERE id = ${a.id}::uuid
          `,await e`
          UPDATE p2p_ad
          SET highlighted_until = (
            CASE
              WHEN highlighted_until IS NULL OR highlighted_until < now() THEN now()
              ELSE highlighted_until
            END
          ) + make_interval(hours => ${o}::int)
          WHERE id = ${r.id}
        `,await (0,x.logArcadeConsumption)(e,{user_id:i,kind:"boost",code:String(a.code),rarity:null,quantity:1,context_type:"p2p_ad",context_id:String(r.id),module:"p2p",metadata:{duration_hours:o}})}if("SELL"===l.side){let t=(await e`
          INSERT INTO ex_ledger_account (user_id, asset_id)
          VALUES (${i}::uuid, ${v.id}::uuid)
          ON CONFLICT (user_id, asset_id) DO UPDATE SET user_id = EXCLUDED.user_id
          RETURNING id
        `)[0].id,a=await e`
          INSERT INTO ex_hold (account_id, asset_id, amount, remaining_amount, reason, status)
          VALUES (
            ${t}::uuid,
            ${v.id}::uuid,
            (${l.total_amount}::numeric),
            (${l.total_amount}::numeric),
            ${`p2p_ad:${r.id}`},
            'active'
          )
          RETURNING id
        `;await e`
          UPDATE p2p_ad
          SET inventory_hold_id = ${a[0].id}::uuid
          WHERE id = ${r.id}
        `}return r});return N.NextResponse.json({success:!0,id:$.id})}catch(e){if(console.error("POST /api/p2p/ads error:",e),"no_highlight_boost"===String(e?.message??""))return(0,y.apiError)("insufficient_balance",{details:{message:"No P2P highlight boost available."}});return(0,y.apiError)("internal_error")}}e.s(["GET",()=>D,"POST",()=>w,"dynamic",0,"force-dynamic"],746973);var O=e.i(746973);let $=new t.AppRouteRouteModule({definition:{kind:i.RouteKind.APP_ROUTE,page:"/api/p2p/ads/route",pathname:"/api/p2p/ads",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/src/app/api/p2p/ads/route.ts",nextConfigOutput:"",userland:O}),{workAsyncStorage:I,workUnitAsyncStorage:P,serverHooks:H}=$;function U(){return(0,a.patchFetch)({workAsyncStorage:I,workUnitAsyncStorage:P})}async function M(e,t,a){$.isDev&&(0,r.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let N="/api/p2p/ads/route";N=N.replace(/\/index$/,"")||"/";let g=await $.prepare(e,t,{srcPage:N,multiZoneDraftMode:!1});if(!g)return t.statusCode=400,t.end("Bad Request"),null==a.waitUntil||a.waitUntil.call(a,Promise.resolve()),null;let{buildId:S,params:y,nextConfig:R,parsedUrl:A,isDraftMode:b,prerenderManifest:T,routerServerContext:x,isOnDemandRevalidate:v,revalidateOnlyGenerated:C,resolvedPathname:L,clientReferenceManifest:D,serverActionsManifest:w}=g,O=(0,o.normalizeAppPath)(N),I=!!(T.dynamicRoutes[O]||T.routes[L]),P=async()=>((null==x?void 0:x.render404)?await x.render404(e,t,A,!1):t.end("This page could not be found"),null);if(I&&!b){let e=!!T.routes[L],t=T.dynamicRoutes[O];if(t&&!1===t.fallback&&!e){if(R.experimental.adapterPath)return await P();throw new h.NoFallbackError}}let H=null;!I||$.isDev||b||(H="/index"===(H=L)?"/":H);let U=!0===$.isDev||!I,M=I&&!U;w&&D&&(0,s.setManifestsSingleton)({page:N,clientReferenceManifest:D,serverActionsManifest:w});let j=e.method||"GET",F=(0,n.getTracer)(),W=F.getActiveScopeSpan(),q={params:y,prerenderManifest:T,renderOpts:{experimental:{authInterrupts:!!R.experimental.authInterrupts},cacheComponents:!!R.cacheComponents,supportsDynamicResponse:U,incrementalCache:(0,r.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:R.cacheLife,waitUntil:a.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,i,a,r)=>$.onRequestError(e,t,a,r,x)},sharedContext:{buildId:S}},z=new d.NodeNextRequest(e),k=new d.NodeNextResponse(t),Y=l.NextRequestAdapter.fromNodeNextRequest(z,(0,l.signalFromNodeResponse)(t));try{let s=async e=>$.handle(Y,q).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let i=F.getRootSpanAttributes();if(!i)return;if(i.get("next.span_type")!==u.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${i.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let a=i.get("next.route");if(a){let t=`${j} ${a}`;e.setAttributes({"next.route":a,"http.route":a,"next.span_name":t}),e.updateName(t)}else e.updateName(`${j} ${N}`)}),o=!!(0,r.getRequestMeta)(e,"minimalMode"),d=async r=>{var n,d;let l=async({previousCacheEntry:i})=>{try{if(!o&&v&&C&&!i)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let n=await s(r);e.fetchMetrics=q.renderOpts.fetchMetrics;let d=q.renderOpts.pendingWaitUntil;d&&a.waitUntil&&(a.waitUntil(d),d=void 0);let l=q.renderOpts.collectedTags;if(!I)return await (0,p.sendResponse)(z,k,n,q.renderOpts.pendingWaitUntil),null;{let e=await n.blob(),t=(0,m.toNodeOutgoingHttpHeaders)(n.headers);l&&(t[c.NEXT_CACHE_TAGS_HEADER]=l),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let i=void 0!==q.renderOpts.collectedRevalidate&&!(q.renderOpts.collectedRevalidate>=c.INFINITE_CACHE)&&q.renderOpts.collectedRevalidate,a=void 0===q.renderOpts.collectedExpire||q.renderOpts.collectedExpire>=c.INFINITE_CACHE?void 0:q.renderOpts.collectedExpire;return{value:{kind:f.CachedRouteKind.APP_ROUTE,status:n.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:i,expire:a}}}}catch(t){throw(null==i?void 0:i.isStale)&&await $.onRequestError(e,t,{routerKind:"App Router",routePath:N,routeType:"route",revalidateReason:(0,_.getRevalidateReason)({isStaticGeneration:M,isOnDemandRevalidate:v})},!1,x),t}},u=await $.handleResponse({req:e,nextConfig:R,cacheKey:H,routeKind:i.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:T,isRoutePPREnabled:!1,isOnDemandRevalidate:v,revalidateOnlyGenerated:C,responseGenerator:l,waitUntil:a.waitUntil,isMinimalMode:o});if(!I)return null;if((null==u||null==(n=u.value)?void 0:n.kind)!==f.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==u||null==(d=u.value)?void 0:d.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});o||t.setHeader("x-nextjs-cache",v?"REVALIDATED":u.isMiss?"MISS":u.isStale?"STALE":"HIT"),b&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let h=(0,m.fromNodeOutgoingHttpHeaders)(u.value.headers);return o&&I||h.delete(c.NEXT_CACHE_TAGS_HEADER),!u.cacheControl||t.getHeader("Cache-Control")||h.get("Cache-Control")||h.set("Cache-Control",(0,E.getCacheControlHeader)(u.cacheControl)),await (0,p.sendResponse)(z,k,new Response(u.value.body,{headers:h,status:u.value.status||200})),null};W?await d(W):await F.withPropagatedContext(e.headers,()=>F.trace(u.BaseServerSpan.handleRequest,{spanName:`${j} ${N}`,kind:n.SpanKind.SERVER,attributes:{"http.method":j,"http.target":e.url}},d))}catch(t){if(t instanceof h.NoFallbackError||await $.onRequestError(e,t,{routerKind:"App Router",routePath:O,routeType:"route",revalidateReason:(0,_.getRevalidateReason)({isStaticGeneration:M,isOnDemandRevalidate:v})},!1,x),I)throw t;return await (0,p.sendResponse)(z,k,new Response(null,{status:500})),null}}e.s(["handler",()=>M,"patchFetch",()=>U,"routeModule",()=>$,"serverHooks",()=>H,"workAsyncStorage",()=>I,"workUnitAsyncStorage",()=>P],600738)}];

//# sourceMappingURL=node_modules_next_dist_esm_build_templates_app-route_39922782.js.map