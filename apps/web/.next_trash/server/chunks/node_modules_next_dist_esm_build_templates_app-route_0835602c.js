module.exports=[776798,e=>{"use strict";var t=e.i(747909),r=e.i(174017),a=e.i(996250),i=e.i(759756),n=e.i(561916),o=e.i(174677),s=e.i(869741),d=e.i(316795),u=e.i(487718),l=e.i(995169),_=e.i(47587),p=e.i(666012),c=e.i(570101),m=e.i(626937),E=e.i(10372),f=e.i(193695);e.i(52474);var h=e.i(600220),y=e.i(89171),R=e.i(469719),S=e.i(843793),N=e.i(300959),T=e.i(977775),w=e.i(364608),g=e.i(194748),A=e.i(794383),O=e.i(332935),x=e.i(842026),C=e.i(831075);let b=null,$=R.z.object({ad_id:R.z.string().uuid(),amount_fiat:R.z.number().positive(),payment_method_id:R.z.string().uuid().optional()});function P(e){let t=e.toUpperCase(),r=Number(process.env[`P2P_PRICE_BAND_PCT_${t}`]??process.env.P2P_PRICE_BAND_PCT??"0.02");return!Number.isFinite(r)||r<=0?.02:Math.min(.25,Math.max(.001,r))}async function L(e){let t=(0,S.getSql)(),r=(0,T.getActingUserId)(e);if(!r)return(0,N.apiError)("unauthorized",{status:401});try{let e=(await t`
        SELECT 
           o.id, 
           o.status, 
           o.amount_fiat, 
           o.fiat_currency, 
           o.amount_asset,
           o.price, 
           o.created_at,
          o.payment_method_snapshot,
           a.symbol as asset_symbol,
           CASE WHEN o.buyer_id = ${r} THEN 'BUY' ELSE 'SELL' END as my_side
        FROM p2p_order o
        LEFT JOIN ex_asset a ON a.id = o.asset_id
        WHERE o.maker_id = ${r} 
           OR o.taker_id = ${r} 
           OR o.buyer_id = ${r} 
           OR o.seller_id = ${r}
        ORDER BY o.created_at DESC
        LIMIT 50
     `).map(e=>{let{payment_method_snapshot:t,...r}=e;return{...r,payment_details_ready:(0,A.hasUsablePaymentDetails)((0,A.normalizePaymentMethodSnapshot)(t))}});return y.NextResponse.json({orders:e})}catch(e){return console.error("[GET /orders] Error:",e),(0,N.apiError)("internal_error")}}async function I(e){let t=(0,S.getSql)(),r=(0,T.getActingUserId)(e),a=(0,T.requireActingUserIdInProd)(r);if(a)return(0,N.apiError)(a);if(!r)return(0,N.apiError)("unauthorized",{status:401});try{let a,i=await (0,w.requireActiveUser)(t,r);if(i)return(0,N.apiError)(i);let n=await t`
      SELECT country
      FROM app_user
      WHERE id = ${r}::uuid
      LIMIT 1
    `,o=n[0]?.country??null;if(!(0,x.isSupportedP2PCountry)(o))return(0,N.apiError)("p2p_country_not_supported",{status:403,details:{country:o}});let s=function(){if(b)return b;let e=(0,S.getSql)();return b=(0,C.createPgRateLimiter)(e,{name:"p2p-order-create",windowMs:6e4,max:6})}(),d=(a=e.headers.get("x-forwarded-for"))?a.split(",")[0]?.trim()||null:e.headers.get("x-real-ip"),[u,l]=await Promise.all([s.consume(`user:${r}`),d?s.consume(`ip:${d}`):Promise.resolve(null)]),_=u.allowed?l&&!l.allowed?l:null:u;if(_&&!_.allowed)return(0,N.apiError)("rate_limit_exceeded",{status:429,details:{limit:_.limit,remaining:_.remaining,resetMs:_.resetMs}});let p=await e.json().catch(()=>null),c=$.safeParse(p);if(!c.success)return(0,N.apiZodError)(c.error)??(0,N.apiError)("invalid_input");let{ad_id:m,amount_fiat:E,payment_method_id:f}=c.data;try{await t.begin(async e=>{for(let t of(await e`SET LOCAL lock_timeout = '5s'`,await e`SET LOCAL statement_timeout = '8s'`,await e`
        UPDATE p2p_order o
        SET status = 'cancelled', cancelled_at = now()
        WHERE o.buyer_id = ${r}::uuid
          AND o.ad_id = ${m}::uuid
          AND o.status = 'created'
          AND o.expires_at IS NOT NULL
          AND o.expires_at <= now()
        RETURNING
          o.id::text,
          o.ad_id::text,
          o.escrow_hold_id::text,
          o.amount_asset::text
      `))t.escrow_hold_id&&await e`
            UPDATE ex_hold
            SET status = 'released', released_at = now()
            WHERE id = ${t.escrow_hold_id}::uuid
              AND status = 'active'
          `,await e`
          UPDATE p2p_ad
          SET remaining_amount = remaining_amount + (${t.amount_asset}::numeric)
          WHERE id = ${t.ad_id}::uuid
        `,await e`
          INSERT INTO p2p_chat_message (order_id, sender_id, content)
          VALUES (${t.id}::uuid, NULL, 'System: Order expired (late cleanup). Escrow released.')
        `})}catch(r){let e="string"==typeof r?.code?r.code:"",t="string"==typeof r?.message?r.message:"";if("55P03"===e||"57014"===e||/lock timeout/i.test(t)||/canceling statement due to lock timeout/i.test(t)||/canceling statement due to statement timeout/i.test(t))return(0,N.apiError)("p2p_busy",{status:409})}let h=null,R=Number(process.env.P2P_MAX_OPEN_CREATED_ORDERS??"3");if(Number.isFinite(R)&&R>0){let e=await t`
        SELECT count(*)::int AS open_created
        FROM p2p_order
        WHERE buyer_id = ${r}::uuid
          AND status = 'created'
          AND (expires_at IS NULL OR expires_at > now())
      `,a=e[0]?.open_created??0;if(a>=R)return(0,N.apiError)("p2p_open_orders_limit",{status:409,details:{max:R,open:a}})}let T=await t`
      SELECT id::text
      FROM p2p_order
      WHERE buyer_id = ${r}::uuid
        AND ad_id = ${m}::uuid
        AND status IN ('created', 'paid_confirmed', 'disputed')
        AND (status <> 'created' OR expires_at IS NULL OR expires_at > now())
      ORDER BY created_at DESC
      LIMIT 1
    `;if(T.length>0)return(0,N.apiError)("p2p_order_duplicate_open",{status:409,details:{order_id:T[0].id}});let L=Number(process.env.P2P_TIMEOUT_WINDOW_HOURS??"24"),I=Number(process.env.P2P_TIMEOUT_MIN_COUNT??"5"),v=Number(process.env.P2P_TIMEOUT_RATIO_THRESHOLD??"0.6"),D=Number(process.env.P2P_TIMEOUT_COOLDOWN_MINUTES??"60");if(Number.isFinite(L)&&Number.isFinite(I)&&Number.isFinite(v)&&Number.isFinite(D)&&L>0&&I>0&&v>0&&D>0){let e=await t`
        WITH recent AS (
          SELECT
            status,
            created_at,
            cancelled_at,
            expires_at
          FROM p2p_order
          WHERE buyer_id = ${r}::uuid
            AND created_at >= now() - make_interval(hours => ${L})
        ),
        timeouts AS (
          SELECT cancelled_at
          FROM recent
          WHERE status = 'cancelled'
            AND cancelled_at IS NOT NULL
            AND expires_at IS NOT NULL
            AND cancelled_at >= expires_at
        )
        SELECT
          (SELECT count(*)::int FROM recent) AS total_created,
          (SELECT count(*)::int FROM timeouts) AS timeout_count,
          (SELECT max(cancelled_at) FROM timeouts) AS last_timeout_at
      `,a=e[0]?.total_created??0,i=e[0]?.timeout_count??0,n=e[0]?.last_timeout_at??null,o=a>0?i/a:0;if(i>=I&&o>=v&&n){let e=new Date(n.getTime()+6e4*D);if(e.getTime()>Date.now())return(0,N.apiError)("p2p_order_create_cooldown",{status:429,details:{cooldown_ends_at:e.toISOString(),window_hours:L,timeout_count:i,total_created:a}})}}let U=process.env.P2P_REFERENCE_TIMEOUT_MS??process.env.FX_LIVE_TIMEOUT_MS??"2500",M=Number(U),H=Number.isFinite(M)?Math.min(8e3,Math.max(500,Math.trunc(M))):2500;try{let e=(await t`
        SELECT asset_id::text AS asset_id, fiat_currency, price_type
        FROM p2p_ad
        WHERE id = ${m}::uuid
        LIMIT 1
      `)[0]??null,r=String(e?.fiat_currency??"").toUpperCase();if(e?.asset_id&&r&&"fixed"===String(e?.price_type??"")){let a=await t`
          SELECT symbol
          FROM ex_asset
          WHERE id = ${e.asset_id}::uuid
          LIMIT 1
        `,i=String(a[0]?.symbol??"").toUpperCase();if(i){let e=await Promise.race([(0,O.getOrComputeFxReferenceRate)(t,i,r),new Promise(e=>setTimeout(()=>e(null),H))]);e&&"number"==typeof e.mid&&Number.isFinite(e.mid)&&e.mid>0&&(h={assetSymbol:i,fiat:r,mid:e.mid,sources:e.sources??{},computedAt:e.computedAt})}}}catch{h=null}let F=await t.begin(async e=>{let t,a;await e`SET LOCAL lock_timeout = '5s'`,await e`SET LOCAL statement_timeout = '10s'`;let[i]=await e`
        SELECT
          ad.*,
          to_json(
            (
              CASE
                WHEN jsonb_typeof(
                  CASE
                    WHEN jsonb_typeof(ad.payment_method_ids) = 'array' THEN ad.payment_method_ids
                    WHEN jsonb_typeof(ad.payment_method_ids) = 'string' AND left((ad.payment_method_ids #>> '{}'), 1) = '[' THEN (ad.payment_method_ids #>> '{}')::jsonb
                    ELSE '[]'::jsonb
                  END
                ) = 'array' THEN (
                  SELECT array_agg(x)
                  FROM jsonb_array_elements_text(
                    CASE
                      WHEN jsonb_typeof(ad.payment_method_ids) = 'array' THEN ad.payment_method_ids
                      WHEN jsonb_typeof(ad.payment_method_ids) = 'string' AND left((ad.payment_method_ids #>> '{}'), 1) = '[' THEN (ad.payment_method_ids #>> '{}')::jsonb
                      ELSE '[]'::jsonb
                    END
                  ) AS x
                )
                ELSE ARRAY[]::text[]
              END
            )
          )::jsonb AS payment_method_ids_json
        FROM p2p_ad ad
        WHERE ad.id = ${m}
        FOR UPDATE
      `;if(!i)throw Error("ad_not_found");if(i.user_id===r)throw Error("cannot_trade_own_ad");if("online"!==i.status)throw Error("ad_is_not_online");let n=parseFloat(i.min_limit),o=parseFloat(i.max_limit);if(E<n||E>o)throw Error("amount_out_of_bounds");let s=parseFloat(i.fixed_price),d=E/s,u=null,l=null,_=null,p=String(i.fiat_currency??"").toUpperCase(),[c]=await e`SELECT id, symbol FROM ex_asset WHERE id = ${i.asset_id}`;if(c?.symbol&&"fixed"===i.price_type&&h&&h.assetSymbol===String(c.symbol).toUpperCase()&&h.fiat===p){u=h.mid,l=h.sources,_=h.computedAt;let e=P(p),t=u*(1-e),r=u*(1+e);if(s<t||s>r)throw Error("p2p_price_out_of_band")}let y=parseFloat(i.remaining_amount);if(d>y)throw Error("insufficient_liquidity_on_ad");let R=i.user_id;"BUY"===i.side?(a=R,t=r):(a=r,t=R);let S=[],N=function(e){if(Array.isArray(e))return e.map(e=>String(e)).filter(Boolean);if("string"==typeof e){let t=e.trim();if(!t)return[];try{let e=JSON.parse(t);if(Array.isArray(e))return e.map(e=>String(e)).filter(Boolean);if("string"==typeof e){let t=e.trim();if(t.startsWith("[")&&t.endsWith("]")){let e=JSON.parse(t);if(Array.isArray(e))return e.map(e=>String(e)).filter(Boolean)}}}catch{}}return[]}(i.payment_method_ids_json);if(R===t){if(0===N.length)throw Error("seller_payment_details_missing");let r=await e`
          SELECT id, identifier, name, details
          FROM p2p_payment_method
          WHERE id::text = ANY(${N})
            AND user_id = ${t}::uuid
        `;if(!r.length||(S=(0,A.normalizePaymentMethodSnapshot)(r),!(0,A.hasUsablePaymentDetails)(S)))throw Error("seller_payment_details_missing")}else{if(!f)throw Error("seller_payment_method_required");let[r]=await e`
          SELECT id, identifier, name, details
          FROM p2p_payment_method
          WHERE id = ${f}::uuid
            AND user_id = ${t}::uuid
        `;if(!r)throw Error("invalid_seller_payment_method");if(S=(0,A.normalizePaymentMethodSnapshot)([r]),!(0,A.hasUsablePaymentDetails)(S))throw Error("seller_payment_details_missing")}let T=(await e`
        INSERT INTO ex_ledger_account (user_id, asset_id)
        VALUES (${t}::uuid, ${c.id}::uuid)
        ON CONFLICT (user_id, asset_id) DO UPDATE SET user_id = EXCLUDED.user_id
        RETURNING id
      `)[0].id,w="SELL"===String(i.side)&&String(R)===String(t);if(!w){let t=await e`
          WITH posted AS (
            SELECT coalesce(sum(amount), 0)::numeric AS posted
            FROM ex_journal_line
            WHERE account_id = ${T}::uuid
          ),
          held AS (
            SELECT coalesce(sum(remaining_amount), 0)::numeric AS held
            FROM ex_hold
            WHERE account_id = ${T}::uuid AND status = 'active'
          )
          SELECT
            posted.posted::text AS posted,
            held.held::text AS held,
            (posted.posted - held.held)::text AS available,
            ((posted.posted - held.held) >= (${d}::numeric)) AS ok
          FROM posted, held
        `;if(!t[0]?.ok)throw Error("seller_insufficient_funds")}await e`
        UPDATE p2p_ad 
        SET remaining_amount = remaining_amount - ${d}
        WHERE id = ${i.id}
      `;let O=new Date(Date.now()+6e4*i.payment_window_minutes),[x]=await e`
        INSERT INTO p2p_order (
          ad_id, maker_id, taker_id, buyer_id, seller_id,
          asset_id, amount_asset, price, amount_fiat, fiat_currency,
          status, payment_method_snapshot, expires_at,
          reference_mid, reference_sources, reference_computed_at, price_band_pct
        ) VALUES (
          ${i.id}, ${R}, ${r}, ${a}, ${t},
          ${c.id}, ${d}, ${s}, ${E}, ${i.fiat_currency},
          'created', ${S}::jsonb, ${O},
          ${u}, ${l?JSON.stringify(l):"{}"}::jsonb, ${_?_.toISOString():null},
          ${u?P(i.fiat_currency):null}
        )
        RETURNING id
      `;if(w){if(!i.inventory_hold_id)throw Error("ad_not_funded");let t=(await e`
          SELECT id::text, account_id::text, asset_id::text, status, remaining_amount::text, amount::text
          FROM ex_hold
          WHERE id = ${i.inventory_hold_id}::uuid
          FOR UPDATE
        `)[0];if(!t||"active"!==t.status||String(t.account_id)!==String(T)||String(t.asset_id)!==String(c.id))throw Error("ad_not_funded");let r=await e`
          SELECT ((${t.remaining_amount}::numeric) >= (${d}::numeric)) AS ok
        `;if(!r[0]?.ok)throw Error("insufficient_liquidity_on_ad");await e`
          UPDATE ex_hold
          SET
            remaining_amount = remaining_amount - (${d}::numeric)
          WHERE id = ${i.inventory_hold_id}::uuid
            AND status = 'active'
        `}let C=await e`
        INSERT INTO ex_hold (account_id, asset_id, amount, remaining_amount, reason, status)
        VALUES (
          ${T}::uuid,
          ${c.id}::uuid,
          (${d}::numeric),
          (${d}::numeric),
          ${`p2p_order:${x.id}`},
          'active'
        )
        RETURNING id
      `;return await e`
        UPDATE p2p_order
        SET escrow_hold_id = ${C[0].id}::uuid
        WHERE id = ${x.id}
      `,await e`
        INSERT INTO p2p_chat_message (order_id, sender_id, content)
        VALUES 
        (${x.id}, NULL, 'Order created. Escrow secured. Please proceed with payment.')
      `,i.auto_reply&&await e`
          INSERT INTO p2p_chat_message (order_id, sender_id, content)
          VALUES 
          (${x.id}, ${R}, ${i.auto_reply})
        `,await (0,g.createNotification)(e,{userId:R,type:"p2p_order_created",title:"New P2P Order",body:` Someone started a trade on your ad for ${E} ${i.fiat_currency}.`,metadata:{order_id:x.id}}),await (0,g.createNotification)(e,{userId:r,type:"p2p_order_created",title:"P2P Order Created",body:`Your order was created for ${E} ${i.fiat_currency}. Await payment / release steps in the order chat.`,metadata:{order_id:x.id}}),x.id});return y.NextResponse.json({success:!0,order_id:F})}catch(a){console.error("[POST /orders] Error:",a);let e="string"==typeof a?.code?a.code:"",t="string"==typeof a?.message?a.message:"";if("55P03"===e||"57014"===e||/lock timeout/i.test(t)||/canceling statement due to lock timeout/i.test(t))return(0,N.apiError)("p2p_busy",{status:409});let r=["ad_not_found","cannot_trade_own_ad","ad_is_not_online","amount_out_of_bounds","insufficient_liquidity_on_ad","seller_insufficient_funds","ad_not_funded","seller_payment_details_missing","seller_payment_method_required","invalid_seller_payment_method","reference_price_unavailable","p2p_price_out_of_band"].find(e=>a.message?.startsWith(e))??"internal_error";return(0,N.apiError)(r)}}e.s(["GET",()=>L,"POST",()=>I,"dynamic",0,"force-dynamic","runtime",0,"nodejs"],132643);var v=e.i(132643);let D=new t.AppRouteRouteModule({definition:{kind:r.RouteKind.APP_ROUTE,page:"/api/p2p/orders/route",pathname:"/api/p2p/orders",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/src/app/api/p2p/orders/route.ts",nextConfigOutput:"",userland:v}),{workAsyncStorage:U,workUnitAsyncStorage:M,serverHooks:H}=D;function F(){return(0,a.patchFetch)({workAsyncStorage:U,workUnitAsyncStorage:M})}async function W(e,t,a){D.isDev&&(0,i.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let y="/api/p2p/orders/route";y=y.replace(/\/index$/,"")||"/";let R=await D.prepare(e,t,{srcPage:y,multiZoneDraftMode:!1});if(!R)return t.statusCode=400,t.end("Bad Request"),null==a.waitUntil||a.waitUntil.call(a,Promise.resolve()),null;let{buildId:S,params:N,nextConfig:T,parsedUrl:w,isDraftMode:g,prerenderManifest:A,routerServerContext:O,isOnDemandRevalidate:x,revalidateOnlyGenerated:C,resolvedPathname:b,clientReferenceManifest:$,serverActionsManifest:P}=R,L=(0,s.normalizeAppPath)(y),I=!!(A.dynamicRoutes[L]||A.routes[b]),v=async()=>((null==O?void 0:O.render404)?await O.render404(e,t,w,!1):t.end("This page could not be found"),null);if(I&&!g){let e=!!A.routes[b],t=A.dynamicRoutes[L];if(t&&!1===t.fallback&&!e){if(T.experimental.adapterPath)return await v();throw new f.NoFallbackError}}let U=null;!I||D.isDev||g||(U="/index"===(U=b)?"/":U);let M=!0===D.isDev||!I,H=I&&!M;P&&$&&(0,o.setManifestsSingleton)({page:y,clientReferenceManifest:$,serverActionsManifest:P});let F=e.method||"GET",W=(0,n.getTracer)(),j=W.getActiveScopeSpan(),k={params:N,prerenderManifest:A,renderOpts:{experimental:{authInterrupts:!!T.experimental.authInterrupts},cacheComponents:!!T.cacheComponents,supportsDynamicResponse:M,incrementalCache:(0,i.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:T.cacheLife,waitUntil:a.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,r,a,i)=>D.onRequestError(e,t,a,i,O)},sharedContext:{buildId:S}},q=new d.NodeNextRequest(e),B=new d.NodeNextResponse(t),z=u.NextRequestAdapter.fromNodeNextRequest(q,(0,u.signalFromNodeResponse)(t));try{let o=async e=>D.handle(z,k).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let r=W.getRootSpanAttributes();if(!r)return;if(r.get("next.span_type")!==l.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${r.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let a=r.get("next.route");if(a){let t=`${F} ${a}`;e.setAttributes({"next.route":a,"http.route":a,"next.span_name":t}),e.updateName(t)}else e.updateName(`${F} ${y}`)}),s=!!(0,i.getRequestMeta)(e,"minimalMode"),d=async i=>{var n,d;let u=async({previousCacheEntry:r})=>{try{if(!s&&x&&C&&!r)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let n=await o(i);e.fetchMetrics=k.renderOpts.fetchMetrics;let d=k.renderOpts.pendingWaitUntil;d&&a.waitUntil&&(a.waitUntil(d),d=void 0);let u=k.renderOpts.collectedTags;if(!I)return await (0,p.sendResponse)(q,B,n,k.renderOpts.pendingWaitUntil),null;{let e=await n.blob(),t=(0,c.toNodeOutgoingHttpHeaders)(n.headers);u&&(t[E.NEXT_CACHE_TAGS_HEADER]=u),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let r=void 0!==k.renderOpts.collectedRevalidate&&!(k.renderOpts.collectedRevalidate>=E.INFINITE_CACHE)&&k.renderOpts.collectedRevalidate,a=void 0===k.renderOpts.collectedExpire||k.renderOpts.collectedExpire>=E.INFINITE_CACHE?void 0:k.renderOpts.collectedExpire;return{value:{kind:h.CachedRouteKind.APP_ROUTE,status:n.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:r,expire:a}}}}catch(t){throw(null==r?void 0:r.isStale)&&await D.onRequestError(e,t,{routerKind:"App Router",routePath:y,routeType:"route",revalidateReason:(0,_.getRevalidateReason)({isStaticGeneration:H,isOnDemandRevalidate:x})},!1,O),t}},l=await D.handleResponse({req:e,nextConfig:T,cacheKey:U,routeKind:r.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:A,isRoutePPREnabled:!1,isOnDemandRevalidate:x,revalidateOnlyGenerated:C,responseGenerator:u,waitUntil:a.waitUntil,isMinimalMode:s});if(!I)return null;if((null==l||null==(n=l.value)?void 0:n.kind)!==h.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==l||null==(d=l.value)?void 0:d.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});s||t.setHeader("x-nextjs-cache",x?"REVALIDATED":l.isMiss?"MISS":l.isStale?"STALE":"HIT"),g&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let f=(0,c.fromNodeOutgoingHttpHeaders)(l.value.headers);return s&&I||f.delete(E.NEXT_CACHE_TAGS_HEADER),!l.cacheControl||t.getHeader("Cache-Control")||f.get("Cache-Control")||f.set("Cache-Control",(0,m.getCacheControlHeader)(l.cacheControl)),await (0,p.sendResponse)(q,B,new Response(l.value.body,{headers:f,status:l.value.status||200})),null};j?await d(j):await W.withPropagatedContext(e.headers,()=>W.trace(l.BaseServerSpan.handleRequest,{spanName:`${F} ${y}`,kind:n.SpanKind.SERVER,attributes:{"http.method":F,"http.target":e.url}},d))}catch(t){if(t instanceof f.NoFallbackError||await D.onRequestError(e,t,{routerKind:"App Router",routePath:L,routeType:"route",revalidateReason:(0,_.getRevalidateReason)({isStaticGeneration:H,isOnDemandRevalidate:x})},!1,O),I)throw t;return await (0,p.sendResponse)(q,B,new Response(null,{status:500})),null}}e.s(["handler",()=>W,"patchFetch",()=>F,"routeModule",()=>D,"serverHooks",()=>H,"workAsyncStorage",()=>U,"workUnitAsyncStorage",()=>M],776798)}];

//# sourceMappingURL=node_modules_next_dist_esm_build_templates_app-route_0835602c.js.map