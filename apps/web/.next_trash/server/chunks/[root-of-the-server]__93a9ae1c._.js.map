{"version":3,"sources":["../../../src/lib/system/heartbeat.ts","../../../src/lib/blockchain/tokens.ts","../../../src/lib/blockchain/hotWallet.ts"],"sourcesContent":["import type { Sql } from \"postgres\";\r\n\r\nexport type HeartbeatStatus = \"ok\" | \"degraded\" | \"error\";\r\n\r\nexport async function upsertServiceHeartbeat(\r\n  sql: Sql,\r\n  args: {\r\n    service: string;\r\n    status?: HeartbeatStatus;\r\n    details?: Record<string, unknown>;\r\n  },\r\n): Promise<void> {\r\n  const service = String(args.service ?? \"\").trim();\r\n  if (!service) return;\r\n\r\n  const status: HeartbeatStatus = args.status ?? \"ok\";\r\n  const details = args.details ?? {};\r\n\r\n  await sql`\r\n    INSERT INTO app_service_heartbeat (service, status, details_json, last_seen_at, updated_at)\r\n    VALUES (\r\n      ${service},\r\n      ${status},\r\n      ${(sql as any).json(details)}::jsonb,\r\n      now(),\r\n      now()\r\n    )\r\n    ON CONFLICT (service) DO UPDATE\r\n      SET status = EXCLUDED.status,\r\n          details_json = EXCLUDED.details_json,\r\n          last_seen_at = EXCLUDED.last_seen_at,\r\n          updated_at = EXCLUDED.updated_at\r\n  `;\r\n}\r\n\r\nexport type HeartbeatRow = {\r\n  service: string;\r\n  status: HeartbeatStatus;\r\n  details_json: unknown;\r\n  last_seen_at: string;\r\n};\r\n\r\nexport async function listServiceHeartbeats(sql: Sql): Promise<HeartbeatRow[]> {\r\n  return await sql<HeartbeatRow[]>`\r\n    SELECT\r\n      service,\r\n      status,\r\n      details_json,\r\n      last_seen_at::text\r\n    FROM app_service_heartbeat\r\n    ORDER BY service ASC\r\n  `;\r\n}\r\n","/**\r\n * BEP-20 Token interactions on BSC\r\n *\r\n * Provides balance checks, transfer functions, and deposit detection\r\n * for USDT and native BNB.\r\n */\r\nimport { ethers } from \"ethers\";\r\nimport { getBscProvider, getBscReadProvider } from \"./wallet\";\r\nimport { isLikelyRpcTransportError, markRpcFail, markRpcOk, rankRpcUrls } from \"@/lib/blockchain/rpcHealth\";\r\n\r\n// ── Standard BEP-20 ABI (minimal) ───────────────────────────────────\r\nconst ERC20_ABI = [\r\n  \"function balanceOf(address owner) view returns (uint256)\",\r\n  \"function transfer(address to, uint256 amount) returns (bool)\",\r\n  \"function decimals() view returns (uint8)\",\r\n  \"function symbol() view returns (string)\",\r\n  \"event Transfer(address indexed from, address indexed to, uint256 value)\",\r\n] as const;\r\n\r\n// ── Known contract addresses ─────────────────────────────────────────\r\nexport type KnownToken = \"USDT\" | \"BNB\";\r\n\r\nconst MAINNET_TOKENS: Record<string, string> = {\r\n  USDT: \"0x55d398326f99059fF775485246999027B3197955\", // BSC-USD (Binance-Peg)\r\n};\r\n\r\nconst TESTNET_TOKENS: Record<string, string> = {\r\n  USDT: \"0x337610d27c682E347C9cD60BD4b3b107C9d34dDd\", // Testnet USDT mock\r\n};\r\n\r\nexport function getTokenAddress(symbol: string): string | null {\r\n  const isMainnet = process.env.NEXT_PUBLIC_USE_MAINNET !== \"false\";\r\n  const tokens = isMainnet ? MAINNET_TOKENS : TESTNET_TOKENS;\r\n  return tokens[symbol.toUpperCase()] ?? null;\r\n}\r\n\r\n// ── Balance queries ──────────────────────────────────────────────────\r\n\r\n/** Get native BNB balance */\r\nexport async function getBnbBalance(address: string): Promise<string> {\r\n  const provider = getBscReadProvider();\r\n  const bal = await provider.getBalance(address);\r\n  return ethers.formatEther(bal);\r\n}\r\n\r\n/** Get BEP-20 token balance */\r\nexport async function getTokenBalance(\r\n  tokenAddress: string,\r\n  walletAddress: string,\r\n): Promise<{ balance: string; decimals: number }> {\r\n  const provider = getBscReadProvider();\r\n  const contract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);\r\n  const [bal, decimals] = await Promise.all([\r\n    contract.balanceOf(walletAddress) as Promise<bigint>,\r\n    contract.decimals() as Promise<number>,\r\n  ]);\r\n  return {\r\n    balance: ethers.formatUnits(bal, decimals),\r\n    decimals,\r\n  };\r\n}\r\n\r\n/** Get all known token balances for a wallet */\r\nexport async function getAllBalances(walletAddress: string): Promise<\r\n  { symbol: string; balance: string; contractAddress: string | null }[]\r\n> {\r\n  const results: { symbol: string; balance: string; contractAddress: string | null }[] = [];\r\n\r\n  // BNB (native)\r\n  try {\r\n    const bnb = await getBnbBalance(walletAddress);\r\n    results.push({ symbol: \"BNB\", balance: bnb, contractAddress: null });\r\n  } catch {\r\n    results.push({ symbol: \"BNB\", balance: \"0\", contractAddress: null });\r\n  }\r\n\r\n  // BEP-20 tokens\r\n  for (const symbol of [\"USDT\"] as const) {\r\n    const addr = getTokenAddress(symbol);\r\n    if (!addr) continue;\r\n    try {\r\n      const { balance } = await getTokenBalance(addr, walletAddress);\r\n      results.push({ symbol, balance, contractAddress: addr });\r\n    } catch {\r\n      results.push({ symbol, balance: \"0\", contractAddress: addr });\r\n    }\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\n// ── Transfer functions ───────────────────────────────────────────────\r\n\r\n/** Send BEP-20 tokens from a wallet (requires private key) */\r\nexport async function sendToken(\r\n  tokenAddress: string,\r\n  privateKey: string,\r\n  to: string,\r\n  amount: string,\r\n  decimals: number = 18,\r\n): Promise<{ txHash: string }> {\r\n  // Prefer multi-RPC failover when BSC_RPC_URLS is configured.\r\n  const urls = rankRpcUrls(\"bsc\");\r\n  const chainId = Number(process.env.NEXT_PUBLIC_USE_MAINNET) === 0 ? 97 : 56;\r\n  const network = ethers.Network.from({ name: \"bnb\", chainId });\r\n\r\n  const amountWei = ethers.parseUnits(amount, decimals);\r\n  let lastErr: unknown = null;\r\n\r\n  // If only one URL is configured, keep the historical behavior.\r\n  if (urls.length <= 1) {\r\n    const provider = getBscProvider();\r\n    const signer = new ethers.Wallet(privateKey, provider);\r\n    const contract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);\r\n    const tx = (await contract.transfer(to, amountWei)) as ethers.TransactionResponse;\r\n    await tx.wait(1);\r\n    return { txHash: tx.hash };\r\n  }\r\n\r\n  for (const url of urls) {\r\n    const provider = new ethers.JsonRpcProvider(url, network, { staticNetwork: network });\r\n    const signer = new ethers.Wallet(privateKey, provider);\r\n    const contract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);\r\n    const t0 = Date.now();\r\n    try {\r\n      const tx = (await contract.transfer(to, amountWei)) as ethers.TransactionResponse;\r\n      markRpcOk(url, Date.now() - t0);\r\n      // Waiting can fail due to transport issues even when the tx broadcast succeeded.\r\n      await tx.wait(1).catch(() => undefined);\r\n      return { txHash: tx.hash };\r\n    } catch (e) {\r\n      markRpcFail(url);\r\n      lastErr = e;\r\n      if (!isLikelyRpcTransportError(e)) throw e;\r\n    }\r\n  }\r\n\r\n  throw lastErr instanceof Error ? lastErr : new Error(\"bsc_rpc_all_failed\");\r\n}\r\n\r\n/** Send native BNB */\r\nexport async function sendBnb(\r\n  privateKey: string,\r\n  to: string,\r\n  amount: string,\r\n): Promise<{ txHash: string }> {\r\n  const urls = rankRpcUrls(\"bsc\");\r\n  const chainId = Number(process.env.NEXT_PUBLIC_USE_MAINNET) === 0 ? 97 : 56;\r\n  const network = ethers.Network.from({ name: \"bnb\", chainId });\r\n\r\n  const value = ethers.parseEther(amount);\r\n  let lastErr: unknown = null;\r\n\r\n  if (urls.length <= 1) {\r\n    const provider = getBscProvider();\r\n    const signer = new ethers.Wallet(privateKey, provider);\r\n    const tx = await signer.sendTransaction({ to, value });\r\n    await tx.wait(1);\r\n    return { txHash: tx.hash };\r\n  }\r\n\r\n  for (const url of urls) {\r\n    const provider = new ethers.JsonRpcProvider(url, network, { staticNetwork: network });\r\n    const signer = new ethers.Wallet(privateKey, provider);\r\n    const t0 = Date.now();\r\n    try {\r\n      const tx = await signer.sendTransaction({ to, value });\r\n      markRpcOk(url, Date.now() - t0);\r\n      await tx.wait(1).catch(() => undefined);\r\n      return { txHash: tx.hash };\r\n    } catch (e) {\r\n      markRpcFail(url);\r\n      lastErr = e;\r\n      if (!isLikelyRpcTransportError(e)) throw e;\r\n    }\r\n  }\r\n\r\n  throw lastErr instanceof Error ? lastErr : new Error(\"bsc_rpc_all_failed\");\r\n}\r\n","/**\r\n * Hot Wallet accessor for withdrawal broadcasting.\r\n *\r\n * The hot wallet is defined by DEPLOYER_PRIVATE_KEY in .env.\r\n * It holds a minimized float and is only accessed server-side.\r\n *\r\n * AI never signs transactions.  AI never directly moves money.\r\n * Only this module and the broadcast handler touch the private key.\r\n */\r\nimport { ethers } from \"ethers\";\r\n\r\nlet _cachedAddress: string | null = null;\r\nlet _cachedKey: string | null = null;\r\n\r\nfunction getEnvKey(): string {\r\n  const k = process.env.DEPLOYER_PRIVATE_KEY;\r\n  if (!k) throw new Error(\"DEPLOYER_PRIVATE_KEY is not set\");\r\n  return k.startsWith(\"0x\") ? k : `0x${k}`;\r\n}\r\n\r\n/** Get the hot wallet address (public, safe to log). */\r\nexport function getHotWalletAddress(): string {\r\n  if (!_cachedAddress) {\r\n    const wallet = new ethers.Wallet(getEnvKey());\r\n    _cachedAddress = wallet.address.toLowerCase();\r\n  }\r\n  return _cachedAddress;\r\n}\r\n\r\n/**\r\n * Get the hot wallet private key.\r\n * NEVER log this value. Callers must use it only inside sendToken / sendBnb.\r\n */\r\nexport function getHotWalletKey(): string {\r\n  if (!_cachedKey) {\r\n    _cachedKey = getEnvKey();\r\n  }\r\n  return _cachedKey;\r\n}\r\n"],"names":[],"mappings":"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"}