{"version":3,"sources":["../../../node_modules/ccxt/js/src/static_dependencies/dydx-v4-client/cosmos/crypto/secp256k1/keys.js","../../../node_modules/ccxt/js/src/static_dependencies/dydx-v4-client/dydxprotocol/accountplus/tx.js","../../../node_modules/ccxt/js/src/static_dependencies/dydx-v4-client/dydxprotocol/subaccounts/asset_position.js","../../../node_modules/ccxt/js/src/static_dependencies/dydx-v4-client/dydxprotocol/subaccounts/perpetual_position.js","../../../node_modules/ccxt/js/src/static_dependencies/dydx-v4-client/dydxprotocol/subaccounts/subaccount.js","../../../node_modules/ccxt/js/src/static_dependencies/dydx-v4-client/dydxprotocol/clob/liquidations.js","../../../node_modules/ccxt/js/src/static_dependencies/dydx-v4-client/dydxprotocol/clob/order.js","../../../node_modules/ccxt/js/src/static_dependencies/dydx-v4-client/dydxprotocol/clob/clob_pair.js","../../../node_modules/ccxt/js/src/static_dependencies/dydx-v4-client/dydxprotocol/clob/equity_tier_limit_config.js","../../../node_modules/ccxt/js/src/static_dependencies/dydx-v4-client/dydxprotocol/clob/block_rate_limit_config.js","../../../node_modules/ccxt/js/src/static_dependencies/dydx-v4-client/dydxprotocol/clob/liquidations_config.js","../../../node_modules/ccxt/js/src/static_dependencies/dydx-v4-client/dydxprotocol/clob/matches.js","../../../node_modules/ccxt/js/src/static_dependencies/dydx-v4-client/dydxprotocol/clob/order_removals.js","../../../node_modules/ccxt/js/src/static_dependencies/dydx-v4-client/dydxprotocol/clob/tx.js","../../../node_modules/ccxt/js/src/static_dependencies/dydx-v4-client/dydxprotocol/sending/transfer.js","../../../node_modules/ccxt/js/src/static_dependencies/dydx-v4-client/dydxprotocol/sending/tx.js","../../../node_modules/ccxt/js/src/static_dependencies/dydx-v4-client/registry.js"],"sourcesContent":["// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nimport _m0 from \"protobufjs/minimal.js\";\nfunction createBasePubKey() {\n    return {\n        key: new Uint8Array()\n    };\n}\nexport const PubKey = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.key.length !== 0) {\n            writer.uint32(10).bytes(message.key);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePubKey();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBasePubKey();\n        message.key = object.key ?? new Uint8Array();\n        return message;\n    }\n};\nfunction createBasePrivKey() {\n    return {\n        key: new Uint8Array()\n    };\n}\nexport const PrivKey = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.key.length !== 0) {\n            writer.uint32(10).bytes(message.key);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePrivKey();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBasePrivKey();\n        message.key = object.key ?? new Uint8Array();\n        return message;\n    }\n};\n","// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nimport _m0 from \"protobufjs/minimal.js\";\nimport { Long } from \"../../helpers.js\";\nfunction createBaseMsgAddAuthenticator() {\n    return {\n        sender: \"\",\n        authenticatorType: \"\",\n        data: new Uint8Array()\n    };\n}\nexport const MsgAddAuthenticator = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.sender !== \"\") {\n            writer.uint32(10).string(message.sender);\n        }\n        if (message.authenticatorType !== \"\") {\n            writer.uint32(18).string(message.authenticatorType);\n        }\n        if (message.data.length !== 0) {\n            writer.uint32(26).bytes(message.data);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgAddAuthenticator();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sender = reader.string();\n                    break;\n                case 2:\n                    message.authenticatorType = reader.string();\n                    break;\n                case 3:\n                    message.data = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgAddAuthenticator();\n        message.sender = object.sender ?? \"\";\n        message.authenticatorType = object.authenticatorType ?? \"\";\n        message.data = object.data ?? new Uint8Array();\n        return message;\n    }\n};\nfunction createBaseMsgAddAuthenticatorResponse() {\n    return {\n        success: false\n    };\n}\nexport const MsgAddAuthenticatorResponse = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.success === true) {\n            writer.uint32(8).bool(message.success);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgAddAuthenticatorResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.success = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgAddAuthenticatorResponse();\n        message.success = object.success ?? false;\n        return message;\n    }\n};\nfunction createBaseMsgRemoveAuthenticator() {\n    return {\n        sender: \"\",\n        id: Long.UZERO\n    };\n}\nexport const MsgRemoveAuthenticator = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.sender !== \"\") {\n            writer.uint32(10).string(message.sender);\n        }\n        if (!message.id.isZero()) {\n            writer.uint32(16).uint64(message.id);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgRemoveAuthenticator();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sender = reader.string();\n                    break;\n                case 2:\n                    message.id = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgRemoveAuthenticator();\n        message.sender = object.sender ?? \"\";\n        message.id = object.id !== undefined && object.id !== null ? Long.fromValue(object.id) : Long.UZERO;\n        return message;\n    }\n};\nfunction createBaseMsgRemoveAuthenticatorResponse() {\n    return {\n        success: false\n    };\n}\nexport const MsgRemoveAuthenticatorResponse = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.success === true) {\n            writer.uint32(8).bool(message.success);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgRemoveAuthenticatorResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.success = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgRemoveAuthenticatorResponse();\n        message.success = object.success ?? false;\n        return message;\n    }\n};\nfunction createBaseMsgSetActiveState() {\n    return {\n        authority: \"\",\n        active: false\n    };\n}\nexport const MsgSetActiveState = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.authority !== \"\") {\n            writer.uint32(10).string(message.authority);\n        }\n        if (message.active === true) {\n            writer.uint32(16).bool(message.active);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgSetActiveState();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.authority = reader.string();\n                    break;\n                case 2:\n                    message.active = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgSetActiveState();\n        message.authority = object.authority ?? \"\";\n        message.active = object.active ?? false;\n        return message;\n    }\n};\nfunction createBaseMsgSetActiveStateResponse() {\n    return {};\n}\nexport const MsgSetActiveStateResponse = {\n    encode(_, writer = _m0.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgSetActiveStateResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgSetActiveStateResponse();\n        return message;\n    }\n};\nfunction createBaseTxExtension() {\n    return {\n        selectedAuthenticators: []\n    };\n}\nexport const TxExtension = {\n    encode(message, writer = _m0.Writer.create()) {\n        writer.uint32(10).fork();\n        for (const v of message.selectedAuthenticators) {\n            writer.uint64(v);\n        }\n        writer.ldelim();\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTxExtension();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if ((tag & 7) === 2) {\n                        const end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2) {\n                            message.selectedAuthenticators.push(reader.uint64());\n                        }\n                    }\n                    else {\n                        message.selectedAuthenticators.push(reader.uint64());\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseTxExtension();\n        message.selectedAuthenticators = object.selectedAuthenticators?.map(e => Long.fromValue(e)) || [];\n        return message;\n    }\n};\n","// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nimport { Long } from \"../../helpers.js\";\nimport * as _m0 from \"protobufjs/minimal.js\";\nfunction createBaseAssetPosition() {\n    return {\n        assetId: 0,\n        quantums: new Uint8Array(),\n        index: Long.UZERO\n    };\n}\nexport const AssetPosition = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.assetId !== 0) {\n            writer.uint32(8).uint32(message.assetId);\n        }\n        if (message.quantums.length !== 0) {\n            writer.uint32(18).bytes(message.quantums);\n        }\n        if (!message.index.isZero()) {\n            writer.uint32(24).uint64(message.index);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAssetPosition();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.assetId = reader.uint32();\n                    break;\n                case 2:\n                    message.quantums = reader.bytes();\n                    break;\n                case 3:\n                    message.index = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseAssetPosition();\n        message.assetId = object.assetId ?? 0;\n        message.quantums = object.quantums ?? new Uint8Array();\n        message.index = object.index !== undefined && object.index !== null ? Long.fromValue(object.index) : Long.UZERO;\n        return message;\n    }\n};\n","// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nimport * as _m0 from \"protobufjs/minimal.js\";\nfunction createBasePerpetualPosition() {\n    return {\n        perpetualId: 0,\n        quantums: new Uint8Array(),\n        fundingIndex: new Uint8Array(),\n        quoteBalance: new Uint8Array()\n    };\n}\nexport const PerpetualPosition = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.perpetualId !== 0) {\n            writer.uint32(8).uint32(message.perpetualId);\n        }\n        if (message.quantums.length !== 0) {\n            writer.uint32(18).bytes(message.quantums);\n        }\n        if (message.fundingIndex.length !== 0) {\n            writer.uint32(26).bytes(message.fundingIndex);\n        }\n        if (message.quoteBalance.length !== 0) {\n            writer.uint32(34).bytes(message.quoteBalance);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePerpetualPosition();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.perpetualId = reader.uint32();\n                    break;\n                case 2:\n                    message.quantums = reader.bytes();\n                    break;\n                case 3:\n                    message.fundingIndex = reader.bytes();\n                    break;\n                case 4:\n                    message.quoteBalance = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBasePerpetualPosition();\n        message.perpetualId = object.perpetualId ?? 0;\n        message.quantums = object.quantums ?? new Uint8Array();\n        message.fundingIndex = object.fundingIndex ?? new Uint8Array();\n        message.quoteBalance = object.quoteBalance ?? new Uint8Array();\n        return message;\n    }\n};\n","// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nimport { AssetPosition } from \"./asset_position.js\";\nimport { PerpetualPosition } from \"./perpetual_position.js\";\nimport _m0 from \"protobufjs/minimal.js\";\nfunction createBaseSubaccountId() {\n    return {\n        owner: \"\",\n        number: 0\n    };\n}\nexport const SubaccountId = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.owner !== \"\") {\n            writer.uint32(10).string(message.owner);\n        }\n        if (message.number !== 0) {\n            writer.uint32(16).uint32(message.number);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSubaccountId();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.owner = reader.string();\n                    break;\n                case 2:\n                    message.number = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseSubaccountId();\n        message.owner = object.owner ?? \"\";\n        message.number = object.number ?? 0;\n        return message;\n    }\n};\nfunction createBaseSubaccount() {\n    return {\n        id: undefined,\n        assetPositions: [],\n        perpetualPositions: [],\n        marginEnabled: false\n    };\n}\nexport const Subaccount = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.id !== undefined) {\n            SubaccountId.encode(message.id, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.assetPositions) {\n            AssetPosition.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        for (const v of message.perpetualPositions) {\n            PerpetualPosition.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.marginEnabled === true) {\n            writer.uint32(32).bool(message.marginEnabled);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSubaccount();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = SubaccountId.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.assetPositions.push(AssetPosition.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.perpetualPositions.push(PerpetualPosition.decode(reader, reader.uint32()));\n                    break;\n                case 4:\n                    message.marginEnabled = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseSubaccount();\n        message.id = object.id !== undefined && object.id !== null ? SubaccountId.fromPartial(object.id) : undefined;\n        message.assetPositions = object.assetPositions?.map(e => AssetPosition.fromPartial(e)) || [];\n        message.perpetualPositions = object.perpetualPositions?.map(e => PerpetualPosition.fromPartial(e)) || [];\n        message.marginEnabled = object.marginEnabled ?? false;\n        return message;\n    }\n};\n","// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nimport { SubaccountId } from \"../subaccounts/subaccount.js\";\nimport * as _m0 from \"protobufjs/minimal.js\";\nimport { Long } from \"../../helpers.js\";\nfunction createBasePerpetualLiquidationInfo() {\n    return {\n        subaccountId: undefined,\n        perpetualId: 0\n    };\n}\nexport const PerpetualLiquidationInfo = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.subaccountId !== undefined) {\n            SubaccountId.encode(message.subaccountId, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.perpetualId !== 0) {\n            writer.uint32(16).uint32(message.perpetualId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePerpetualLiquidationInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.subaccountId = SubaccountId.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.perpetualId = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBasePerpetualLiquidationInfo();\n        message.subaccountId = object.subaccountId !== undefined && object.subaccountId !== null ? SubaccountId.fromPartial(object.subaccountId) : undefined;\n        message.perpetualId = object.perpetualId ?? 0;\n        return message;\n    }\n};\nfunction createBaseSubaccountLiquidationInfo() {\n    return {\n        perpetualsLiquidated: [],\n        notionalLiquidated: Long.UZERO,\n        quantumsInsuranceLost: Long.UZERO\n    };\n}\nexport const SubaccountLiquidationInfo = {\n    encode(message, writer = _m0.Writer.create()) {\n        writer.uint32(10).fork();\n        for (const v of message.perpetualsLiquidated) {\n            writer.uint32(v);\n        }\n        writer.ldelim();\n        if (!message.notionalLiquidated.isZero()) {\n            writer.uint32(16).uint64(message.notionalLiquidated);\n        }\n        if (!message.quantumsInsuranceLost.isZero()) {\n            writer.uint32(24).uint64(message.quantumsInsuranceLost);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSubaccountLiquidationInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if ((tag & 7) === 2) {\n                        const end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2) {\n                            message.perpetualsLiquidated.push(reader.uint32());\n                        }\n                    }\n                    else {\n                        message.perpetualsLiquidated.push(reader.uint32());\n                    }\n                    break;\n                case 2:\n                    message.notionalLiquidated = reader.uint64();\n                    break;\n                case 3:\n                    message.quantumsInsuranceLost = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseSubaccountLiquidationInfo();\n        message.perpetualsLiquidated = object.perpetualsLiquidated?.map(e => e) || [];\n        message.notionalLiquidated = object.notionalLiquidated !== undefined && object.notionalLiquidated !== null ? Long.fromValue(object.notionalLiquidated) : Long.UZERO;\n        message.quantumsInsuranceLost = object.quantumsInsuranceLost !== undefined && object.quantumsInsuranceLost !== null ? Long.fromValue(object.quantumsInsuranceLost) : Long.UZERO;\n        return message;\n    }\n};\nfunction createBaseSubaccountOpenPositionInfo() {\n    return {\n        perpetualId: 0,\n        subaccountsWithLongPosition: [],\n        subaccountsWithShortPosition: []\n    };\n}\nexport const SubaccountOpenPositionInfo = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.perpetualId !== 0) {\n            writer.uint32(8).uint32(message.perpetualId);\n        }\n        for (const v of message.subaccountsWithLongPosition) {\n            SubaccountId.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        for (const v of message.subaccountsWithShortPosition) {\n            SubaccountId.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSubaccountOpenPositionInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.perpetualId = reader.uint32();\n                    break;\n                case 2:\n                    message.subaccountsWithLongPosition.push(SubaccountId.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.subaccountsWithShortPosition.push(SubaccountId.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseSubaccountOpenPositionInfo();\n        message.perpetualId = object.perpetualId ?? 0;\n        message.subaccountsWithLongPosition = object.subaccountsWithLongPosition?.map(e => SubaccountId.fromPartial(e)) || [];\n        message.subaccountsWithShortPosition = object.subaccountsWithShortPosition?.map(e => SubaccountId.fromPartial(e)) || [];\n        return message;\n    }\n};\n","// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nimport { SubaccountId } from \"../subaccounts/subaccount.js\";\nimport { PerpetualLiquidationInfo } from \"./liquidations.js\";\nimport _m0 from \"protobufjs/minimal.js\";\nimport { Long } from \"../../helpers.js\";\n/**\n * Represents the side of the orderbook the order will be placed on.\n * Note that Side.SIDE_UNSPECIFIED is an invalid order and cannot be\n * placed on the orderbook.\n */\nexport var Order_Side;\n(function (Order_Side) {\n    /** SIDE_UNSPECIFIED - Default value. This value is invalid and unused. */\n    Order_Side[Order_Side[\"SIDE_UNSPECIFIED\"] = 0] = \"SIDE_UNSPECIFIED\";\n    /** SIDE_BUY - SIDE_BUY is used to represent a BUY order. */\n    Order_Side[Order_Side[\"SIDE_BUY\"] = 1] = \"SIDE_BUY\";\n    /** SIDE_SELL - SIDE_SELL is used to represent a SELL order. */\n    Order_Side[Order_Side[\"SIDE_SELL\"] = 2] = \"SIDE_SELL\";\n    Order_Side[Order_Side[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(Order_Side || (Order_Side = {}));\nexport const Order_SideSDKType = Order_Side;\nexport function order_SideFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"SIDE_UNSPECIFIED\":\n            return Order_Side.SIDE_UNSPECIFIED;\n        case 1:\n        case \"SIDE_BUY\":\n            return Order_Side.SIDE_BUY;\n        case 2:\n        case \"SIDE_SELL\":\n            return Order_Side.SIDE_SELL;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return Order_Side.UNRECOGNIZED;\n    }\n}\nexport function order_SideToJSON(object) {\n    switch (object) {\n        case Order_Side.SIDE_UNSPECIFIED:\n            return \"SIDE_UNSPECIFIED\";\n        case Order_Side.SIDE_BUY:\n            return \"SIDE_BUY\";\n        case Order_Side.SIDE_SELL:\n            return \"SIDE_SELL\";\n        case Order_Side.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\n/**\n * TimeInForce indicates how long an order will remain active before it\n * is executed or expires.\n */\nexport var Order_TimeInForce;\n(function (Order_TimeInForce) {\n    /**\n     * TIME_IN_FORCE_UNSPECIFIED - TIME_IN_FORCE_UNSPECIFIED represents the default behavior where an\n     * order will first match with existing orders on the book, and any\n     * remaining size will be added to the book as a maker order.\n     */\n    Order_TimeInForce[Order_TimeInForce[\"TIME_IN_FORCE_UNSPECIFIED\"] = 0] = \"TIME_IN_FORCE_UNSPECIFIED\";\n    /**\n     * TIME_IN_FORCE_IOC - TIME_IN_FORCE_IOC enforces that an order only be matched with\n     * maker orders on the book. If the order has remaining size after\n     * matching with existing orders on the book, the remaining size\n     * is not placed on the book.\n     */\n    Order_TimeInForce[Order_TimeInForce[\"TIME_IN_FORCE_IOC\"] = 1] = \"TIME_IN_FORCE_IOC\";\n    /**\n     * TIME_IN_FORCE_POST_ONLY - TIME_IN_FORCE_POST_ONLY enforces that an order only be placed\n     * on the book as a maker order. Note this means that validators will cancel\n     * any newly-placed post only orders that would cross with other maker\n     * orders.\n     */\n    Order_TimeInForce[Order_TimeInForce[\"TIME_IN_FORCE_POST_ONLY\"] = 2] = \"TIME_IN_FORCE_POST_ONLY\";\n    /**\n     * TIME_IN_FORCE_FILL_OR_KILL - TIME_IN_FORCE_FILL_OR_KILL has been deprecated and will be removed in\n     * future versions.\n     */\n    Order_TimeInForce[Order_TimeInForce[\"TIME_IN_FORCE_FILL_OR_KILL\"] = 3] = \"TIME_IN_FORCE_FILL_OR_KILL\";\n    Order_TimeInForce[Order_TimeInForce[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(Order_TimeInForce || (Order_TimeInForce = {}));\nexport const Order_TimeInForceSDKType = Order_TimeInForce;\nexport function order_TimeInForceFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"TIME_IN_FORCE_UNSPECIFIED\":\n            return Order_TimeInForce.TIME_IN_FORCE_UNSPECIFIED;\n        case 1:\n        case \"TIME_IN_FORCE_IOC\":\n            return Order_TimeInForce.TIME_IN_FORCE_IOC;\n        case 2:\n        case \"TIME_IN_FORCE_POST_ONLY\":\n            return Order_TimeInForce.TIME_IN_FORCE_POST_ONLY;\n        case 3:\n        case \"TIME_IN_FORCE_FILL_OR_KILL\":\n            return Order_TimeInForce.TIME_IN_FORCE_FILL_OR_KILL;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return Order_TimeInForce.UNRECOGNIZED;\n    }\n}\nexport function order_TimeInForceToJSON(object) {\n    switch (object) {\n        case Order_TimeInForce.TIME_IN_FORCE_UNSPECIFIED:\n            return \"TIME_IN_FORCE_UNSPECIFIED\";\n        case Order_TimeInForce.TIME_IN_FORCE_IOC:\n            return \"TIME_IN_FORCE_IOC\";\n        case Order_TimeInForce.TIME_IN_FORCE_POST_ONLY:\n            return \"TIME_IN_FORCE_POST_ONLY\";\n        case Order_TimeInForce.TIME_IN_FORCE_FILL_OR_KILL:\n            return \"TIME_IN_FORCE_FILL_OR_KILL\";\n        case Order_TimeInForce.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nexport var Order_ConditionType;\n(function (Order_ConditionType) {\n    /**\n     * CONDITION_TYPE_UNSPECIFIED - CONDITION_TYPE_UNSPECIFIED represents the default behavior where an\n     * order will be placed immediately on the orderbook.\n     */\n    Order_ConditionType[Order_ConditionType[\"CONDITION_TYPE_UNSPECIFIED\"] = 0] = \"CONDITION_TYPE_UNSPECIFIED\";\n    /**\n     * CONDITION_TYPE_STOP_LOSS - CONDITION_TYPE_STOP_LOSS represents a stop order. A stop order will\n     * trigger when the oracle price moves at or above the trigger price for\n     * buys, and at or below the trigger price for sells.\n     */\n    Order_ConditionType[Order_ConditionType[\"CONDITION_TYPE_STOP_LOSS\"] = 1] = \"CONDITION_TYPE_STOP_LOSS\";\n    /**\n     * CONDITION_TYPE_TAKE_PROFIT - CONDITION_TYPE_TAKE_PROFIT represents a take profit order. A take profit\n     * order will trigger when the oracle price moves at or below the trigger\n     * price for buys and at or above the trigger price for sells.\n     */\n    Order_ConditionType[Order_ConditionType[\"CONDITION_TYPE_TAKE_PROFIT\"] = 2] = \"CONDITION_TYPE_TAKE_PROFIT\";\n    Order_ConditionType[Order_ConditionType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(Order_ConditionType || (Order_ConditionType = {}));\nexport const Order_ConditionTypeSDKType = Order_ConditionType;\nexport function order_ConditionTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"CONDITION_TYPE_UNSPECIFIED\":\n            return Order_ConditionType.CONDITION_TYPE_UNSPECIFIED;\n        case 1:\n        case \"CONDITION_TYPE_STOP_LOSS\":\n            return Order_ConditionType.CONDITION_TYPE_STOP_LOSS;\n        case 2:\n        case \"CONDITION_TYPE_TAKE_PROFIT\":\n            return Order_ConditionType.CONDITION_TYPE_TAKE_PROFIT;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return Order_ConditionType.UNRECOGNIZED;\n    }\n}\nexport function order_ConditionTypeToJSON(object) {\n    switch (object) {\n        case Order_ConditionType.CONDITION_TYPE_UNSPECIFIED:\n            return \"CONDITION_TYPE_UNSPECIFIED\";\n        case Order_ConditionType.CONDITION_TYPE_STOP_LOSS:\n            return \"CONDITION_TYPE_STOP_LOSS\";\n        case Order_ConditionType.CONDITION_TYPE_TAKE_PROFIT:\n            return \"CONDITION_TYPE_TAKE_PROFIT\";\n        case Order_ConditionType.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nfunction createBaseOrderId() {\n    return {\n        subaccountId: undefined,\n        clientId: 0,\n        orderFlags: 0,\n        clobPairId: 0\n    };\n}\nexport const OrderId = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.subaccountId !== undefined) {\n            SubaccountId.encode(message.subaccountId, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.clientId !== 0) {\n            writer.uint32(21).fixed32(message.clientId);\n        }\n        if (message.orderFlags !== 0) {\n            writer.uint32(24).uint32(message.orderFlags);\n        }\n        if (message.clobPairId !== 0) {\n            writer.uint32(32).uint32(message.clobPairId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseOrderId();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.subaccountId = SubaccountId.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.clientId = reader.fixed32();\n                    break;\n                case 3:\n                    message.orderFlags = reader.uint32();\n                    break;\n                case 4:\n                    message.clobPairId = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseOrderId();\n        message.subaccountId = object.subaccountId !== undefined && object.subaccountId !== null ? SubaccountId.fromPartial(object.subaccountId) : undefined;\n        message.clientId = object.clientId ?? 0;\n        message.orderFlags = object.orderFlags ?? 0;\n        message.clobPairId = object.clobPairId ?? 0;\n        return message;\n    }\n};\nfunction createBaseOrdersFilledDuringLatestBlock() {\n    return {\n        orderIds: []\n    };\n}\nexport const OrdersFilledDuringLatestBlock = {\n    encode(message, writer = _m0.Writer.create()) {\n        for (const v of message.orderIds) {\n            OrderId.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseOrdersFilledDuringLatestBlock();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.orderIds.push(OrderId.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseOrdersFilledDuringLatestBlock();\n        message.orderIds = object.orderIds?.map(e => OrderId.fromPartial(e)) || [];\n        return message;\n    }\n};\nfunction createBasePotentiallyPrunableOrders() {\n    return {\n        orderIds: []\n    };\n}\nexport const PotentiallyPrunableOrders = {\n    encode(message, writer = _m0.Writer.create()) {\n        for (const v of message.orderIds) {\n            OrderId.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePotentiallyPrunableOrders();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.orderIds.push(OrderId.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBasePotentiallyPrunableOrders();\n        message.orderIds = object.orderIds?.map(e => OrderId.fromPartial(e)) || [];\n        return message;\n    }\n};\nfunction createBaseOrderFillState() {\n    return {\n        fillAmount: Long.UZERO,\n        prunableBlockHeight: 0\n    };\n}\nexport const OrderFillState = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (!message.fillAmount.isZero()) {\n            writer.uint32(8).uint64(message.fillAmount);\n        }\n        if (message.prunableBlockHeight !== 0) {\n            writer.uint32(16).uint32(message.prunableBlockHeight);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseOrderFillState();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.fillAmount = reader.uint64();\n                    break;\n                case 2:\n                    message.prunableBlockHeight = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseOrderFillState();\n        message.fillAmount = object.fillAmount !== undefined && object.fillAmount !== null ? Long.fromValue(object.fillAmount) : Long.UZERO;\n        message.prunableBlockHeight = object.prunableBlockHeight ?? 0;\n        return message;\n    }\n};\nfunction createBaseStatefulOrderTimeSliceValue() {\n    return {\n        orderIds: []\n    };\n}\nexport const StatefulOrderTimeSliceValue = {\n    encode(message, writer = _m0.Writer.create()) {\n        for (const v of message.orderIds) {\n            OrderId.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseStatefulOrderTimeSliceValue();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.orderIds.push(OrderId.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseStatefulOrderTimeSliceValue();\n        message.orderIds = object.orderIds?.map(e => OrderId.fromPartial(e)) || [];\n        return message;\n    }\n};\nfunction createBaseLongTermOrderPlacement() {\n    return {\n        order: undefined,\n        placementIndex: undefined\n    };\n}\nexport const LongTermOrderPlacement = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.order !== undefined) {\n            Order.encode(message.order, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.placementIndex !== undefined) {\n            TransactionOrdering.encode(message.placementIndex, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseLongTermOrderPlacement();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.order = Order.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.placementIndex = TransactionOrdering.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseLongTermOrderPlacement();\n        message.order = object.order !== undefined && object.order !== null ? Order.fromPartial(object.order) : undefined;\n        message.placementIndex = object.placementIndex !== undefined && object.placementIndex !== null ? TransactionOrdering.fromPartial(object.placementIndex) : undefined;\n        return message;\n    }\n};\nfunction createBaseTwapOrderPlacement() {\n    return {\n        order: undefined,\n        remainingLegs: 0,\n        remainingQuantums: Long.UZERO\n    };\n}\nexport const TwapOrderPlacement = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.order !== undefined) {\n            Order.encode(message.order, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.remainingLegs !== 0) {\n            writer.uint32(16).uint32(message.remainingLegs);\n        }\n        if (!message.remainingQuantums.isZero()) {\n            writer.uint32(24).uint64(message.remainingQuantums);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTwapOrderPlacement();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.order = Order.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.remainingLegs = reader.uint32();\n                    break;\n                case 3:\n                    message.remainingQuantums = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseTwapOrderPlacement();\n        message.order = object.order !== undefined && object.order !== null ? Order.fromPartial(object.order) : undefined;\n        message.remainingLegs = object.remainingLegs ?? 0;\n        message.remainingQuantums = object.remainingQuantums !== undefined && object.remainingQuantums !== null ? Long.fromValue(object.remainingQuantums) : Long.UZERO;\n        return message;\n    }\n};\nfunction createBaseConditionalOrderPlacement() {\n    return {\n        order: undefined,\n        placementIndex: undefined,\n        triggerIndex: undefined\n    };\n}\nexport const ConditionalOrderPlacement = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.order !== undefined) {\n            Order.encode(message.order, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.placementIndex !== undefined) {\n            TransactionOrdering.encode(message.placementIndex, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.triggerIndex !== undefined) {\n            TransactionOrdering.encode(message.triggerIndex, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseConditionalOrderPlacement();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.order = Order.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.placementIndex = TransactionOrdering.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.triggerIndex = TransactionOrdering.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseConditionalOrderPlacement();\n        message.order = object.order !== undefined && object.order !== null ? Order.fromPartial(object.order) : undefined;\n        message.placementIndex = object.placementIndex !== undefined && object.placementIndex !== null ? TransactionOrdering.fromPartial(object.placementIndex) : undefined;\n        message.triggerIndex = object.triggerIndex !== undefined && object.triggerIndex !== null ? TransactionOrdering.fromPartial(object.triggerIndex) : undefined;\n        return message;\n    }\n};\nfunction createBaseOrder() {\n    return {\n        orderId: undefined,\n        side: 0,\n        quantums: Long.UZERO,\n        subticks: Long.UZERO,\n        goodTilBlock: undefined,\n        goodTilBlockTime: undefined,\n        timeInForce: 0,\n        reduceOnly: false,\n        clientMetadata: 0,\n        conditionType: 0,\n        conditionalOrderTriggerSubticks: Long.UZERO,\n        twapParameters: undefined,\n        builderCodeParameters: undefined,\n        orderRouterAddress: \"\"\n    };\n}\nexport const Order = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.orderId !== undefined) {\n            OrderId.encode(message.orderId, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.side !== 0) {\n            writer.uint32(16).int32(message.side);\n        }\n        if (!message.quantums.isZero()) {\n            writer.uint32(24).uint64(message.quantums);\n        }\n        if (!message.subticks.isZero()) {\n            writer.uint32(32).uint64(message.subticks);\n        }\n        if (message.goodTilBlock !== undefined) {\n            writer.uint32(40).uint32(message.goodTilBlock);\n        }\n        if (message.goodTilBlockTime !== undefined) {\n            writer.uint32(53).fixed32(message.goodTilBlockTime);\n        }\n        if (message.timeInForce !== 0) {\n            writer.uint32(56).int32(message.timeInForce);\n        }\n        if (message.reduceOnly === true) {\n            writer.uint32(64).bool(message.reduceOnly);\n        }\n        if (message.clientMetadata !== 0) {\n            writer.uint32(72).uint32(message.clientMetadata);\n        }\n        if (message.conditionType !== 0) {\n            writer.uint32(80).int32(message.conditionType);\n        }\n        if (!message.conditionalOrderTriggerSubticks.isZero()) {\n            writer.uint32(88).uint64(message.conditionalOrderTriggerSubticks);\n        }\n        if (message.twapParameters !== undefined) {\n            TwapParameters.encode(message.twapParameters, writer.uint32(98).fork()).ldelim();\n        }\n        if (message.builderCodeParameters !== undefined) {\n            BuilderCodeParameters.encode(message.builderCodeParameters, writer.uint32(106).fork()).ldelim();\n        }\n        if (message.orderRouterAddress !== \"\") {\n            writer.uint32(114).string(message.orderRouterAddress);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseOrder();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.orderId = OrderId.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.side = reader.int32();\n                    break;\n                case 3:\n                    message.quantums = reader.uint64();\n                    break;\n                case 4:\n                    message.subticks = reader.uint64();\n                    break;\n                case 5:\n                    message.goodTilBlock = reader.uint32();\n                    break;\n                case 6:\n                    message.goodTilBlockTime = reader.fixed32();\n                    break;\n                case 7:\n                    message.timeInForce = reader.int32();\n                    break;\n                case 8:\n                    message.reduceOnly = reader.bool();\n                    break;\n                case 9:\n                    message.clientMetadata = reader.uint32();\n                    break;\n                case 10:\n                    message.conditionType = reader.int32();\n                    break;\n                case 11:\n                    message.conditionalOrderTriggerSubticks = reader.uint64();\n                    break;\n                case 12:\n                    message.twapParameters = TwapParameters.decode(reader, reader.uint32());\n                    break;\n                case 13:\n                    message.builderCodeParameters = BuilderCodeParameters.decode(reader, reader.uint32());\n                    break;\n                case 14:\n                    message.orderRouterAddress = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseOrder();\n        message.orderId = object.orderId !== undefined && object.orderId !== null ? OrderId.fromPartial(object.orderId) : undefined;\n        message.side = object.side ?? 0;\n        message.quantums = object.quantums !== undefined && object.quantums !== null ? Long.fromValue(object.quantums) : Long.UZERO;\n        message.subticks = object.subticks !== undefined && object.subticks !== null ? Long.fromValue(object.subticks) : Long.UZERO;\n        message.goodTilBlock = object.goodTilBlock ?? undefined;\n        message.goodTilBlockTime = object.goodTilBlockTime ?? undefined;\n        message.timeInForce = object.timeInForce ?? 0;\n        message.reduceOnly = object.reduceOnly ?? false;\n        message.clientMetadata = object.clientMetadata ?? 0;\n        message.conditionType = object.conditionType ?? 0;\n        message.conditionalOrderTriggerSubticks = object.conditionalOrderTriggerSubticks !== undefined && object.conditionalOrderTriggerSubticks !== null ? Long.fromValue(object.conditionalOrderTriggerSubticks) : Long.UZERO;\n        message.twapParameters = object.twapParameters !== undefined && object.twapParameters !== null ? TwapParameters.fromPartial(object.twapParameters) : undefined;\n        message.builderCodeParameters = object.builderCodeParameters !== undefined && object.builderCodeParameters !== null ? BuilderCodeParameters.fromPartial(object.builderCodeParameters) : undefined;\n        message.orderRouterAddress = object.orderRouterAddress ?? \"\";\n        return message;\n    }\n};\nfunction createBaseTwapParameters() {\n    return {\n        duration: 0,\n        interval: 0,\n        priceTolerance: 0\n    };\n}\nexport const TwapParameters = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.duration !== 0) {\n            writer.uint32(8).uint32(message.duration);\n        }\n        if (message.interval !== 0) {\n            writer.uint32(16).uint32(message.interval);\n        }\n        if (message.priceTolerance !== 0) {\n            writer.uint32(24).uint32(message.priceTolerance);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTwapParameters();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.duration = reader.uint32();\n                    break;\n                case 2:\n                    message.interval = reader.uint32();\n                    break;\n                case 3:\n                    message.priceTolerance = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseTwapParameters();\n        message.duration = object.duration ?? 0;\n        message.interval = object.interval ?? 0;\n        message.priceTolerance = object.priceTolerance ?? 0;\n        return message;\n    }\n};\nfunction createBaseBuilderCodeParameters() {\n    return {\n        builderAddress: \"\",\n        feePpm: 0\n    };\n}\nexport const BuilderCodeParameters = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.builderAddress !== \"\") {\n            writer.uint32(10).string(message.builderAddress);\n        }\n        if (message.feePpm !== 0) {\n            writer.uint32(16).uint32(message.feePpm);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseBuilderCodeParameters();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.builderAddress = reader.string();\n                    break;\n                case 2:\n                    message.feePpm = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseBuilderCodeParameters();\n        message.builderAddress = object.builderAddress ?? \"\";\n        message.feePpm = object.feePpm ?? 0;\n        return message;\n    }\n};\nfunction createBaseTransactionOrdering() {\n    return {\n        blockHeight: 0,\n        transactionIndex: 0\n    };\n}\nexport const TransactionOrdering = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.blockHeight !== 0) {\n            writer.uint32(8).uint32(message.blockHeight);\n        }\n        if (message.transactionIndex !== 0) {\n            writer.uint32(16).uint32(message.transactionIndex);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTransactionOrdering();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.blockHeight = reader.uint32();\n                    break;\n                case 2:\n                    message.transactionIndex = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseTransactionOrdering();\n        message.blockHeight = object.blockHeight ?? 0;\n        message.transactionIndex = object.transactionIndex ?? 0;\n        return message;\n    }\n};\nfunction createBaseStreamLiquidationOrder() {\n    return {\n        liquidationInfo: undefined,\n        clobPairId: 0,\n        isBuy: false,\n        quantums: Long.UZERO,\n        subticks: Long.UZERO\n    };\n}\nexport const StreamLiquidationOrder = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.liquidationInfo !== undefined) {\n            PerpetualLiquidationInfo.encode(message.liquidationInfo, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.clobPairId !== 0) {\n            writer.uint32(16).uint32(message.clobPairId);\n        }\n        if (message.isBuy === true) {\n            writer.uint32(24).bool(message.isBuy);\n        }\n        if (!message.quantums.isZero()) {\n            writer.uint32(32).uint64(message.quantums);\n        }\n        if (!message.subticks.isZero()) {\n            writer.uint32(40).uint64(message.subticks);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseStreamLiquidationOrder();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.liquidationInfo = PerpetualLiquidationInfo.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.clobPairId = reader.uint32();\n                    break;\n                case 3:\n                    message.isBuy = reader.bool();\n                    break;\n                case 4:\n                    message.quantums = reader.uint64();\n                    break;\n                case 5:\n                    message.subticks = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseStreamLiquidationOrder();\n        message.liquidationInfo = object.liquidationInfo !== undefined && object.liquidationInfo !== null ? PerpetualLiquidationInfo.fromPartial(object.liquidationInfo) : undefined;\n        message.clobPairId = object.clobPairId ?? 0;\n        message.isBuy = object.isBuy ?? false;\n        message.quantums = object.quantums !== undefined && object.quantums !== null ? Long.fromValue(object.quantums) : Long.UZERO;\n        message.subticks = object.subticks !== undefined && object.subticks !== null ? Long.fromValue(object.subticks) : Long.UZERO;\n        return message;\n    }\n};\n","// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nimport _m0 from \"protobufjs/minimal.js\";\nimport { Long } from \"../../helpers.js\";\n/** Status of the CLOB. */\nexport var ClobPair_Status;\n(function (ClobPair_Status) {\n    /** STATUS_UNSPECIFIED - Default value. This value is invalid and unused. */\n    ClobPair_Status[ClobPair_Status[\"STATUS_UNSPECIFIED\"] = 0] = \"STATUS_UNSPECIFIED\";\n    /** STATUS_ACTIVE - STATUS_ACTIVE represents an active clob pair. */\n    ClobPair_Status[ClobPair_Status[\"STATUS_ACTIVE\"] = 1] = \"STATUS_ACTIVE\";\n    /**\n     * STATUS_PAUSED - STATUS_PAUSED behavior is unfinalized.\n     * TODO(DEC-600): update this documentation.\n     */\n    ClobPair_Status[ClobPair_Status[\"STATUS_PAUSED\"] = 2] = \"STATUS_PAUSED\";\n    /**\n     * STATUS_CANCEL_ONLY - STATUS_CANCEL_ONLY behavior is unfinalized.\n     * TODO(DEC-600): update this documentation.\n     */\n    ClobPair_Status[ClobPair_Status[\"STATUS_CANCEL_ONLY\"] = 3] = \"STATUS_CANCEL_ONLY\";\n    /**\n     * STATUS_POST_ONLY - STATUS_POST_ONLY behavior is unfinalized.\n     * TODO(DEC-600): update this documentation.\n     */\n    ClobPair_Status[ClobPair_Status[\"STATUS_POST_ONLY\"] = 4] = \"STATUS_POST_ONLY\";\n    /**\n     * STATUS_INITIALIZING - STATUS_INITIALIZING represents a newly-added clob pair.\n     * Clob pairs in this state only accept orders which are\n     * both short-term and post-only.\n     */\n    ClobPair_Status[ClobPair_Status[\"STATUS_INITIALIZING\"] = 5] = \"STATUS_INITIALIZING\";\n    /**\n     * STATUS_FINAL_SETTLEMENT - STATUS_FINAL_SETTLEMENT represents a clob pair which is deactivated\n     * and trading has ceased. All open positions will be closed by the\n     * protocol. Open stateful orders will be cancelled. Open short-term\n     * orders will be left to expire.\n     */\n    ClobPair_Status[ClobPair_Status[\"STATUS_FINAL_SETTLEMENT\"] = 6] = \"STATUS_FINAL_SETTLEMENT\";\n    ClobPair_Status[ClobPair_Status[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ClobPair_Status || (ClobPair_Status = {}));\nexport const ClobPair_StatusSDKType = ClobPair_Status;\nexport function clobPair_StatusFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"STATUS_UNSPECIFIED\":\n            return ClobPair_Status.STATUS_UNSPECIFIED;\n        case 1:\n        case \"STATUS_ACTIVE\":\n            return ClobPair_Status.STATUS_ACTIVE;\n        case 2:\n        case \"STATUS_PAUSED\":\n            return ClobPair_Status.STATUS_PAUSED;\n        case 3:\n        case \"STATUS_CANCEL_ONLY\":\n            return ClobPair_Status.STATUS_CANCEL_ONLY;\n        case 4:\n        case \"STATUS_POST_ONLY\":\n            return ClobPair_Status.STATUS_POST_ONLY;\n        case 5:\n        case \"STATUS_INITIALIZING\":\n            return ClobPair_Status.STATUS_INITIALIZING;\n        case 6:\n        case \"STATUS_FINAL_SETTLEMENT\":\n            return ClobPair_Status.STATUS_FINAL_SETTLEMENT;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return ClobPair_Status.UNRECOGNIZED;\n    }\n}\nexport function clobPair_StatusToJSON(object) {\n    switch (object) {\n        case ClobPair_Status.STATUS_UNSPECIFIED:\n            return \"STATUS_UNSPECIFIED\";\n        case ClobPair_Status.STATUS_ACTIVE:\n            return \"STATUS_ACTIVE\";\n        case ClobPair_Status.STATUS_PAUSED:\n            return \"STATUS_PAUSED\";\n        case ClobPair_Status.STATUS_CANCEL_ONLY:\n            return \"STATUS_CANCEL_ONLY\";\n        case ClobPair_Status.STATUS_POST_ONLY:\n            return \"STATUS_POST_ONLY\";\n        case ClobPair_Status.STATUS_INITIALIZING:\n            return \"STATUS_INITIALIZING\";\n        case ClobPair_Status.STATUS_FINAL_SETTLEMENT:\n            return \"STATUS_FINAL_SETTLEMENT\";\n        case ClobPair_Status.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nfunction createBasePerpetualClobMetadata() {\n    return {\n        perpetualId: 0\n    };\n}\nexport const PerpetualClobMetadata = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.perpetualId !== 0) {\n            writer.uint32(8).uint32(message.perpetualId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePerpetualClobMetadata();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.perpetualId = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBasePerpetualClobMetadata();\n        message.perpetualId = object.perpetualId ?? 0;\n        return message;\n    }\n};\nfunction createBaseSpotClobMetadata() {\n    return {\n        baseAssetId: 0,\n        quoteAssetId: 0\n    };\n}\nexport const SpotClobMetadata = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.baseAssetId !== 0) {\n            writer.uint32(8).uint32(message.baseAssetId);\n        }\n        if (message.quoteAssetId !== 0) {\n            writer.uint32(16).uint32(message.quoteAssetId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSpotClobMetadata();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.baseAssetId = reader.uint32();\n                    break;\n                case 2:\n                    message.quoteAssetId = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseSpotClobMetadata();\n        message.baseAssetId = object.baseAssetId ?? 0;\n        message.quoteAssetId = object.quoteAssetId ?? 0;\n        return message;\n    }\n};\nfunction createBaseClobPair() {\n    return {\n        id: 0,\n        perpetualClobMetadata: undefined,\n        spotClobMetadata: undefined,\n        stepBaseQuantums: Long.UZERO,\n        subticksPerTick: 0,\n        quantumConversionExponent: 0,\n        status: 0\n    };\n}\nexport const ClobPair = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.id !== 0) {\n            writer.uint32(8).uint32(message.id);\n        }\n        if (message.perpetualClobMetadata !== undefined) {\n            PerpetualClobMetadata.encode(message.perpetualClobMetadata, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.spotClobMetadata !== undefined) {\n            SpotClobMetadata.encode(message.spotClobMetadata, writer.uint32(26).fork()).ldelim();\n        }\n        if (!message.stepBaseQuantums.isZero()) {\n            writer.uint32(32).uint64(message.stepBaseQuantums);\n        }\n        if (message.subticksPerTick !== 0) {\n            writer.uint32(40).uint32(message.subticksPerTick);\n        }\n        if (message.quantumConversionExponent !== 0) {\n            writer.uint32(48).sint32(message.quantumConversionExponent);\n        }\n        if (message.status !== 0) {\n            writer.uint32(56).int32(message.status);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseClobPair();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.uint32();\n                    break;\n                case 2:\n                    message.perpetualClobMetadata = PerpetualClobMetadata.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.spotClobMetadata = SpotClobMetadata.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.stepBaseQuantums = reader.uint64();\n                    break;\n                case 5:\n                    message.subticksPerTick = reader.uint32();\n                    break;\n                case 6:\n                    message.quantumConversionExponent = reader.sint32();\n                    break;\n                case 7:\n                    message.status = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseClobPair();\n        message.id = object.id ?? 0;\n        message.perpetualClobMetadata = object.perpetualClobMetadata !== undefined && object.perpetualClobMetadata !== null ? PerpetualClobMetadata.fromPartial(object.perpetualClobMetadata) : undefined;\n        message.spotClobMetadata = object.spotClobMetadata !== undefined && object.spotClobMetadata !== null ? SpotClobMetadata.fromPartial(object.spotClobMetadata) : undefined;\n        message.stepBaseQuantums = object.stepBaseQuantums !== undefined && object.stepBaseQuantums !== null ? Long.fromValue(object.stepBaseQuantums) : Long.UZERO;\n        message.subticksPerTick = object.subticksPerTick ?? 0;\n        message.quantumConversionExponent = object.quantumConversionExponent ?? 0;\n        message.status = object.status ?? 0;\n        return message;\n    }\n};\n","// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nimport _m0 from \"protobufjs/minimal.js\";\nfunction createBaseEquityTierLimitConfiguration() {\n    return {\n        shortTermOrderEquityTiers: [],\n        statefulOrderEquityTiers: []\n    };\n}\nexport const EquityTierLimitConfiguration = {\n    encode(message, writer = _m0.Writer.create()) {\n        for (const v of message.shortTermOrderEquityTiers) {\n            EquityTierLimit.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.statefulOrderEquityTiers) {\n            EquityTierLimit.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEquityTierLimitConfiguration();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.shortTermOrderEquityTiers.push(EquityTierLimit.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.statefulOrderEquityTiers.push(EquityTierLimit.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseEquityTierLimitConfiguration();\n        message.shortTermOrderEquityTiers = object.shortTermOrderEquityTiers?.map(e => EquityTierLimit.fromPartial(e)) || [];\n        message.statefulOrderEquityTiers = object.statefulOrderEquityTiers?.map(e => EquityTierLimit.fromPartial(e)) || [];\n        return message;\n    }\n};\nfunction createBaseEquityTierLimit() {\n    return {\n        usdTncRequired: new Uint8Array(),\n        limit: 0\n    };\n}\nexport const EquityTierLimit = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.usdTncRequired.length !== 0) {\n            writer.uint32(10).bytes(message.usdTncRequired);\n        }\n        if (message.limit !== 0) {\n            writer.uint32(16).uint32(message.limit);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEquityTierLimit();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.usdTncRequired = reader.bytes();\n                    break;\n                case 2:\n                    message.limit = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseEquityTierLimit();\n        message.usdTncRequired = object.usdTncRequired ?? new Uint8Array();\n        message.limit = object.limit ?? 0;\n        return message;\n    }\n};\n","// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nimport _m0 from \"protobufjs/minimal.js\";\nfunction createBaseBlockRateLimitConfiguration() {\n    return {\n        maxShortTermOrdersPerNBlocks: [],\n        maxStatefulOrdersPerNBlocks: [],\n        maxShortTermOrderCancellationsPerNBlocks: [],\n        maxShortTermOrdersAndCancelsPerNBlocks: []\n    };\n}\nexport const BlockRateLimitConfiguration = {\n    encode(message, writer = _m0.Writer.create()) {\n        for (const v of message.maxShortTermOrdersPerNBlocks) {\n            MaxPerNBlocksRateLimit.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.maxStatefulOrdersPerNBlocks) {\n            MaxPerNBlocksRateLimit.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        for (const v of message.maxShortTermOrderCancellationsPerNBlocks) {\n            MaxPerNBlocksRateLimit.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        for (const v of message.maxShortTermOrdersAndCancelsPerNBlocks) {\n            MaxPerNBlocksRateLimit.encode(v, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseBlockRateLimitConfiguration();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.maxShortTermOrdersPerNBlocks.push(MaxPerNBlocksRateLimit.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.maxStatefulOrdersPerNBlocks.push(MaxPerNBlocksRateLimit.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.maxShortTermOrderCancellationsPerNBlocks.push(MaxPerNBlocksRateLimit.decode(reader, reader.uint32()));\n                    break;\n                case 4:\n                    message.maxShortTermOrdersAndCancelsPerNBlocks.push(MaxPerNBlocksRateLimit.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseBlockRateLimitConfiguration();\n        message.maxShortTermOrdersPerNBlocks = object.maxShortTermOrdersPerNBlocks?.map(e => MaxPerNBlocksRateLimit.fromPartial(e)) || [];\n        message.maxStatefulOrdersPerNBlocks = object.maxStatefulOrdersPerNBlocks?.map(e => MaxPerNBlocksRateLimit.fromPartial(e)) || [];\n        message.maxShortTermOrderCancellationsPerNBlocks = object.maxShortTermOrderCancellationsPerNBlocks?.map(e => MaxPerNBlocksRateLimit.fromPartial(e)) || [];\n        message.maxShortTermOrdersAndCancelsPerNBlocks = object.maxShortTermOrdersAndCancelsPerNBlocks?.map(e => MaxPerNBlocksRateLimit.fromPartial(e)) || [];\n        return message;\n    }\n};\nfunction createBaseMaxPerNBlocksRateLimit() {\n    return {\n        numBlocks: 0,\n        limit: 0\n    };\n}\nexport const MaxPerNBlocksRateLimit = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.numBlocks !== 0) {\n            writer.uint32(8).uint32(message.numBlocks);\n        }\n        if (message.limit !== 0) {\n            writer.uint32(16).uint32(message.limit);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMaxPerNBlocksRateLimit();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.numBlocks = reader.uint32();\n                    break;\n                case 2:\n                    message.limit = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMaxPerNBlocksRateLimit();\n        message.numBlocks = object.numBlocks ?? 0;\n        message.limit = object.limit ?? 0;\n        return message;\n    }\n};\n","// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nimport _m0 from \"protobufjs/minimal.js\";\nimport { Long } from \"../../helpers.js\";\nfunction createBaseLiquidationsConfig() {\n    return {\n        maxLiquidationFeePpm: 0,\n        positionBlockLimits: undefined,\n        subaccountBlockLimits: undefined,\n        fillablePriceConfig: undefined\n    };\n}\nexport const LiquidationsConfig = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.maxLiquidationFeePpm !== 0) {\n            writer.uint32(8).uint32(message.maxLiquidationFeePpm);\n        }\n        if (message.positionBlockLimits !== undefined) {\n            PositionBlockLimits.encode(message.positionBlockLimits, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.subaccountBlockLimits !== undefined) {\n            SubaccountBlockLimits.encode(message.subaccountBlockLimits, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.fillablePriceConfig !== undefined) {\n            FillablePriceConfig.encode(message.fillablePriceConfig, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseLiquidationsConfig();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.maxLiquidationFeePpm = reader.uint32();\n                    break;\n                case 2:\n                    message.positionBlockLimits = PositionBlockLimits.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.subaccountBlockLimits = SubaccountBlockLimits.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.fillablePriceConfig = FillablePriceConfig.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseLiquidationsConfig();\n        message.maxLiquidationFeePpm = object.maxLiquidationFeePpm ?? 0;\n        message.positionBlockLimits = object.positionBlockLimits !== undefined && object.positionBlockLimits !== null ? PositionBlockLimits.fromPartial(object.positionBlockLimits) : undefined;\n        message.subaccountBlockLimits = object.subaccountBlockLimits !== undefined && object.subaccountBlockLimits !== null ? SubaccountBlockLimits.fromPartial(object.subaccountBlockLimits) : undefined;\n        message.fillablePriceConfig = object.fillablePriceConfig !== undefined && object.fillablePriceConfig !== null ? FillablePriceConfig.fromPartial(object.fillablePriceConfig) : undefined;\n        return message;\n    }\n};\nfunction createBasePositionBlockLimits() {\n    return {\n        minPositionNotionalLiquidated: Long.UZERO,\n        maxPositionPortionLiquidatedPpm: 0\n    };\n}\nexport const PositionBlockLimits = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (!message.minPositionNotionalLiquidated.isZero()) {\n            writer.uint32(8).uint64(message.minPositionNotionalLiquidated);\n        }\n        if (message.maxPositionPortionLiquidatedPpm !== 0) {\n            writer.uint32(16).uint32(message.maxPositionPortionLiquidatedPpm);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePositionBlockLimits();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.minPositionNotionalLiquidated = reader.uint64();\n                    break;\n                case 2:\n                    message.maxPositionPortionLiquidatedPpm = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBasePositionBlockLimits();\n        message.minPositionNotionalLiquidated = object.minPositionNotionalLiquidated !== undefined && object.minPositionNotionalLiquidated !== null ? Long.fromValue(object.minPositionNotionalLiquidated) : Long.UZERO;\n        message.maxPositionPortionLiquidatedPpm = object.maxPositionPortionLiquidatedPpm ?? 0;\n        return message;\n    }\n};\nfunction createBaseSubaccountBlockLimits() {\n    return {\n        maxNotionalLiquidated: Long.UZERO,\n        maxQuantumsInsuranceLost: Long.UZERO\n    };\n}\nexport const SubaccountBlockLimits = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (!message.maxNotionalLiquidated.isZero()) {\n            writer.uint32(8).uint64(message.maxNotionalLiquidated);\n        }\n        if (!message.maxQuantumsInsuranceLost.isZero()) {\n            writer.uint32(16).uint64(message.maxQuantumsInsuranceLost);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSubaccountBlockLimits();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.maxNotionalLiquidated = reader.uint64();\n                    break;\n                case 2:\n                    message.maxQuantumsInsuranceLost = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseSubaccountBlockLimits();\n        message.maxNotionalLiquidated = object.maxNotionalLiquidated !== undefined && object.maxNotionalLiquidated !== null ? Long.fromValue(object.maxNotionalLiquidated) : Long.UZERO;\n        message.maxQuantumsInsuranceLost = object.maxQuantumsInsuranceLost !== undefined && object.maxQuantumsInsuranceLost !== null ? Long.fromValue(object.maxQuantumsInsuranceLost) : Long.UZERO;\n        return message;\n    }\n};\nfunction createBaseFillablePriceConfig() {\n    return {\n        bankruptcyAdjustmentPpm: 0,\n        spreadToMaintenanceMarginRatioPpm: 0\n    };\n}\nexport const FillablePriceConfig = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.bankruptcyAdjustmentPpm !== 0) {\n            writer.uint32(8).uint32(message.bankruptcyAdjustmentPpm);\n        }\n        if (message.spreadToMaintenanceMarginRatioPpm !== 0) {\n            writer.uint32(16).uint32(message.spreadToMaintenanceMarginRatioPpm);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseFillablePriceConfig();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bankruptcyAdjustmentPpm = reader.uint32();\n                    break;\n                case 2:\n                    message.spreadToMaintenanceMarginRatioPpm = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseFillablePriceConfig();\n        message.bankruptcyAdjustmentPpm = object.bankruptcyAdjustmentPpm ?? 0;\n        message.spreadToMaintenanceMarginRatioPpm = object.spreadToMaintenanceMarginRatioPpm ?? 0;\n        return message;\n    }\n};\n","// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nimport { OrderId } from \"./order.js\";\nimport { SubaccountId } from \"../subaccounts/subaccount.js\";\nimport _m0 from \"protobufjs/minimal.js\";\nimport { Long } from \"../../helpers.js\";\nfunction createBaseClobMatch() {\n    return {\n        matchOrders: undefined,\n        matchPerpetualLiquidation: undefined,\n        matchPerpetualDeleveraging: undefined\n    };\n}\nexport const ClobMatch = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.matchOrders !== undefined) {\n            MatchOrders.encode(message.matchOrders, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.matchPerpetualLiquidation !== undefined) {\n            MatchPerpetualLiquidation.encode(message.matchPerpetualLiquidation, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.matchPerpetualDeleveraging !== undefined) {\n            MatchPerpetualDeleveraging.encode(message.matchPerpetualDeleveraging, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseClobMatch();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.matchOrders = MatchOrders.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.matchPerpetualLiquidation = MatchPerpetualLiquidation.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.matchPerpetualDeleveraging = MatchPerpetualDeleveraging.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseClobMatch();\n        message.matchOrders = object.matchOrders !== undefined && object.matchOrders !== null ? MatchOrders.fromPartial(object.matchOrders) : undefined;\n        message.matchPerpetualLiquidation = object.matchPerpetualLiquidation !== undefined && object.matchPerpetualLiquidation !== null ? MatchPerpetualLiquidation.fromPartial(object.matchPerpetualLiquidation) : undefined;\n        message.matchPerpetualDeleveraging = object.matchPerpetualDeleveraging !== undefined && object.matchPerpetualDeleveraging !== null ? MatchPerpetualDeleveraging.fromPartial(object.matchPerpetualDeleveraging) : undefined;\n        return message;\n    }\n};\nfunction createBaseMakerFill() {\n    return {\n        fillAmount: Long.UZERO,\n        makerOrderId: undefined\n    };\n}\nexport const MakerFill = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (!message.fillAmount.isZero()) {\n            writer.uint32(8).uint64(message.fillAmount);\n        }\n        if (message.makerOrderId !== undefined) {\n            OrderId.encode(message.makerOrderId, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMakerFill();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.fillAmount = reader.uint64();\n                    break;\n                case 2:\n                    message.makerOrderId = OrderId.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMakerFill();\n        message.fillAmount = object.fillAmount !== undefined && object.fillAmount !== null ? Long.fromValue(object.fillAmount) : Long.UZERO;\n        message.makerOrderId = object.makerOrderId !== undefined && object.makerOrderId !== null ? OrderId.fromPartial(object.makerOrderId) : undefined;\n        return message;\n    }\n};\nfunction createBaseMatchOrders() {\n    return {\n        takerOrderId: undefined,\n        fills: []\n    };\n}\nexport const MatchOrders = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.takerOrderId !== undefined) {\n            OrderId.encode(message.takerOrderId, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.fills) {\n            MakerFill.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMatchOrders();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.takerOrderId = OrderId.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.fills.push(MakerFill.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMatchOrders();\n        message.takerOrderId = object.takerOrderId !== undefined && object.takerOrderId !== null ? OrderId.fromPartial(object.takerOrderId) : undefined;\n        message.fills = object.fills?.map(e => MakerFill.fromPartial(e)) || [];\n        return message;\n    }\n};\nfunction createBaseMatchPerpetualLiquidation() {\n    return {\n        liquidated: undefined,\n        clobPairId: 0,\n        perpetualId: 0,\n        totalSize: Long.UZERO,\n        isBuy: false,\n        fills: []\n    };\n}\nexport const MatchPerpetualLiquidation = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.liquidated !== undefined) {\n            SubaccountId.encode(message.liquidated, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.clobPairId !== 0) {\n            writer.uint32(16).uint32(message.clobPairId);\n        }\n        if (message.perpetualId !== 0) {\n            writer.uint32(24).uint32(message.perpetualId);\n        }\n        if (!message.totalSize.isZero()) {\n            writer.uint32(32).uint64(message.totalSize);\n        }\n        if (message.isBuy === true) {\n            writer.uint32(40).bool(message.isBuy);\n        }\n        for (const v of message.fills) {\n            MakerFill.encode(v, writer.uint32(50).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMatchPerpetualLiquidation();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.liquidated = SubaccountId.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.clobPairId = reader.uint32();\n                    break;\n                case 3:\n                    message.perpetualId = reader.uint32();\n                    break;\n                case 4:\n                    message.totalSize = reader.uint64();\n                    break;\n                case 5:\n                    message.isBuy = reader.bool();\n                    break;\n                case 6:\n                    message.fills.push(MakerFill.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMatchPerpetualLiquidation();\n        message.liquidated = object.liquidated !== undefined && object.liquidated !== null ? SubaccountId.fromPartial(object.liquidated) : undefined;\n        message.clobPairId = object.clobPairId ?? 0;\n        message.perpetualId = object.perpetualId ?? 0;\n        message.totalSize = object.totalSize !== undefined && object.totalSize !== null ? Long.fromValue(object.totalSize) : Long.UZERO;\n        message.isBuy = object.isBuy ?? false;\n        message.fills = object.fills?.map(e => MakerFill.fromPartial(e)) || [];\n        return message;\n    }\n};\nfunction createBaseMatchPerpetualDeleveraging() {\n    return {\n        liquidated: undefined,\n        perpetualId: 0,\n        fills: [],\n        isFinalSettlement: false\n    };\n}\nexport const MatchPerpetualDeleveraging = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.liquidated !== undefined) {\n            SubaccountId.encode(message.liquidated, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.perpetualId !== 0) {\n            writer.uint32(16).uint32(message.perpetualId);\n        }\n        for (const v of message.fills) {\n            MatchPerpetualDeleveraging_Fill.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.isFinalSettlement === true) {\n            writer.uint32(32).bool(message.isFinalSettlement);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMatchPerpetualDeleveraging();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.liquidated = SubaccountId.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.perpetualId = reader.uint32();\n                    break;\n                case 3:\n                    message.fills.push(MatchPerpetualDeleveraging_Fill.decode(reader, reader.uint32()));\n                    break;\n                case 4:\n                    message.isFinalSettlement = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMatchPerpetualDeleveraging();\n        message.liquidated = object.liquidated !== undefined && object.liquidated !== null ? SubaccountId.fromPartial(object.liquidated) : undefined;\n        message.perpetualId = object.perpetualId ?? 0;\n        message.fills = object.fills?.map(e => MatchPerpetualDeleveraging_Fill.fromPartial(e)) || [];\n        message.isFinalSettlement = object.isFinalSettlement ?? false;\n        return message;\n    }\n};\nfunction createBaseMatchPerpetualDeleveraging_Fill() {\n    return {\n        offsettingSubaccountId: undefined,\n        fillAmount: Long.UZERO\n    };\n}\nexport const MatchPerpetualDeleveraging_Fill = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.offsettingSubaccountId !== undefined) {\n            SubaccountId.encode(message.offsettingSubaccountId, writer.uint32(10).fork()).ldelim();\n        }\n        if (!message.fillAmount.isZero()) {\n            writer.uint32(16).uint64(message.fillAmount);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMatchPerpetualDeleveraging_Fill();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.offsettingSubaccountId = SubaccountId.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.fillAmount = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMatchPerpetualDeleveraging_Fill();\n        message.offsettingSubaccountId = object.offsettingSubaccountId !== undefined && object.offsettingSubaccountId !== null ? SubaccountId.fromPartial(object.offsettingSubaccountId) : undefined;\n        message.fillAmount = object.fillAmount !== undefined && object.fillAmount !== null ? Long.fromValue(object.fillAmount) : Long.UZERO;\n        return message;\n    }\n};\n","// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nimport { OrderId } from \"./order.js\";\nimport _m0 from \"protobufjs/minimal.js\";\nexport var OrderRemoval_RemovalReason;\n(function (OrderRemoval_RemovalReason) {\n    /**\n     * REMOVAL_REASON_UNSPECIFIED - REMOVAL_REASON_UNSPECIFIED represents an unspecified removal reason. This\n     * removal reason is used as a catchall and should never appear on an\n     * OrderRemoval in the operations queue.\n     */\n    OrderRemoval_RemovalReason[OrderRemoval_RemovalReason[\"REMOVAL_REASON_UNSPECIFIED\"] = 0] = \"REMOVAL_REASON_UNSPECIFIED\";\n    /**\n     * REMOVAL_REASON_UNDERCOLLATERALIZED - REMOVAL_REASON_UNDERCOLLATERALIZED represents a removal of an order which\n     * if filled in isolation with respect to the current state of the\n     * subaccount would leave the subaccount undercollateralized.\n     */\n    OrderRemoval_RemovalReason[OrderRemoval_RemovalReason[\"REMOVAL_REASON_UNDERCOLLATERALIZED\"] = 1] = \"REMOVAL_REASON_UNDERCOLLATERALIZED\";\n    /**\n     * REMOVAL_REASON_INVALID_REDUCE_ONLY - REMOVAL_REASON_INVALID_REDUCE_ONLY represents a removal of a reduce-only\n     * order which if filled in isolation with respect to the current state of\n     * the subaccount would cause the subaccount's existing position to increase\n     * or change sides.\n     */\n    OrderRemoval_RemovalReason[OrderRemoval_RemovalReason[\"REMOVAL_REASON_INVALID_REDUCE_ONLY\"] = 2] = \"REMOVAL_REASON_INVALID_REDUCE_ONLY\";\n    /**\n     * REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER - REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER represents a removal of\n     * a stateful post-only order that was deemed invalid because it crossed\n     * maker orders on the book of the proposer.\n     */\n    OrderRemoval_RemovalReason[OrderRemoval_RemovalReason[\"REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER\"] = 3] = \"REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER\";\n    /**\n     * REMOVAL_REASON_INVALID_SELF_TRADE - REMOVAL_REASON_INVALID_SELF_TRADE represents a removal of a stateful\n     * order that was deemed invalid because it constituted a self trade on the\n     * proposers orderbook.\n     */\n    OrderRemoval_RemovalReason[OrderRemoval_RemovalReason[\"REMOVAL_REASON_INVALID_SELF_TRADE\"] = 4] = \"REMOVAL_REASON_INVALID_SELF_TRADE\";\n    /**\n     * REMOVAL_REASON_CONDITIONAL_FOK_COULD_NOT_BE_FULLY_FILLED - REMOVAL_REASON_CONDITIONAL_FOK_COULD_NOT_BE_FULLY_FILLED represents a\n     * removal of a conditional FOK order that was deemed invalid because it\n     * could not be completely filled. Conditional FOK orders should always be\n     * fully-filled or removed in the block after they are triggered.\n     */\n    OrderRemoval_RemovalReason[OrderRemoval_RemovalReason[\"REMOVAL_REASON_CONDITIONAL_FOK_COULD_NOT_BE_FULLY_FILLED\"] = 5] = \"REMOVAL_REASON_CONDITIONAL_FOK_COULD_NOT_BE_FULLY_FILLED\";\n    /**\n     * REMOVAL_REASON_CONDITIONAL_IOC_WOULD_REST_ON_BOOK - REMOVAL_REASON_CONDITIONAL_IOC_WOULD_REST_ON_BOOK represents a removal\n     * of a conditional IOC order.\n     * Conditional IOC orders should always have their remaining size removed\n     * in the block after they are triggered.\n     */\n    OrderRemoval_RemovalReason[OrderRemoval_RemovalReason[\"REMOVAL_REASON_CONDITIONAL_IOC_WOULD_REST_ON_BOOK\"] = 6] = \"REMOVAL_REASON_CONDITIONAL_IOC_WOULD_REST_ON_BOOK\";\n    /**\n     * REMOVAL_REASON_FULLY_FILLED - REMOVAL_REASON_FULLY_FILLED represents a removal of an order that\n     * was fully filled and should therefore be removed from state.\n     */\n    OrderRemoval_RemovalReason[OrderRemoval_RemovalReason[\"REMOVAL_REASON_FULLY_FILLED\"] = 7] = \"REMOVAL_REASON_FULLY_FILLED\";\n    /**\n     * REMOVAL_REASON_VIOLATES_ISOLATED_SUBACCOUNT_CONSTRAINTS - REMOVAL_REASON_FULLY_FILLED represents a removal of an order that\n     *  would lead to the subaccount violating isolated subaccount constraints.\n     */\n    OrderRemoval_RemovalReason[OrderRemoval_RemovalReason[\"REMOVAL_REASON_VIOLATES_ISOLATED_SUBACCOUNT_CONSTRAINTS\"] = 8] = \"REMOVAL_REASON_VIOLATES_ISOLATED_SUBACCOUNT_CONSTRAINTS\";\n    /**\n     * REMOVAL_REASON_PERMISSIONED_KEY_EXPIRED - REMOVAL_REASON_PERMISSIONED_KEY_EXPIRED represents a removal of an order\n     * that was placed using an expired permissioned key.\n     */\n    OrderRemoval_RemovalReason[OrderRemoval_RemovalReason[\"REMOVAL_REASON_PERMISSIONED_KEY_EXPIRED\"] = 9] = \"REMOVAL_REASON_PERMISSIONED_KEY_EXPIRED\";\n    OrderRemoval_RemovalReason[OrderRemoval_RemovalReason[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(OrderRemoval_RemovalReason || (OrderRemoval_RemovalReason = {}));\nexport const OrderRemoval_RemovalReasonSDKType = OrderRemoval_RemovalReason;\nexport function orderRemoval_RemovalReasonFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"REMOVAL_REASON_UNSPECIFIED\":\n            return OrderRemoval_RemovalReason.REMOVAL_REASON_UNSPECIFIED;\n        case 1:\n        case \"REMOVAL_REASON_UNDERCOLLATERALIZED\":\n            return OrderRemoval_RemovalReason.REMOVAL_REASON_UNDERCOLLATERALIZED;\n        case 2:\n        case \"REMOVAL_REASON_INVALID_REDUCE_ONLY\":\n            return OrderRemoval_RemovalReason.REMOVAL_REASON_INVALID_REDUCE_ONLY;\n        case 3:\n        case \"REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER\":\n            return OrderRemoval_RemovalReason.REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER;\n        case 4:\n        case \"REMOVAL_REASON_INVALID_SELF_TRADE\":\n            return OrderRemoval_RemovalReason.REMOVAL_REASON_INVALID_SELF_TRADE;\n        case 5:\n        case \"REMOVAL_REASON_CONDITIONAL_FOK_COULD_NOT_BE_FULLY_FILLED\":\n            return OrderRemoval_RemovalReason.REMOVAL_REASON_CONDITIONAL_FOK_COULD_NOT_BE_FULLY_FILLED;\n        case 6:\n        case \"REMOVAL_REASON_CONDITIONAL_IOC_WOULD_REST_ON_BOOK\":\n            return OrderRemoval_RemovalReason.REMOVAL_REASON_CONDITIONAL_IOC_WOULD_REST_ON_BOOK;\n        case 7:\n        case \"REMOVAL_REASON_FULLY_FILLED\":\n            return OrderRemoval_RemovalReason.REMOVAL_REASON_FULLY_FILLED;\n        case 8:\n        case \"REMOVAL_REASON_VIOLATES_ISOLATED_SUBACCOUNT_CONSTRAINTS\":\n            return OrderRemoval_RemovalReason.REMOVAL_REASON_VIOLATES_ISOLATED_SUBACCOUNT_CONSTRAINTS;\n        case 9:\n        case \"REMOVAL_REASON_PERMISSIONED_KEY_EXPIRED\":\n            return OrderRemoval_RemovalReason.REMOVAL_REASON_PERMISSIONED_KEY_EXPIRED;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return OrderRemoval_RemovalReason.UNRECOGNIZED;\n    }\n}\nexport function orderRemoval_RemovalReasonToJSON(object) {\n    switch (object) {\n        case OrderRemoval_RemovalReason.REMOVAL_REASON_UNSPECIFIED:\n            return \"REMOVAL_REASON_UNSPECIFIED\";\n        case OrderRemoval_RemovalReason.REMOVAL_REASON_UNDERCOLLATERALIZED:\n            return \"REMOVAL_REASON_UNDERCOLLATERALIZED\";\n        case OrderRemoval_RemovalReason.REMOVAL_REASON_INVALID_REDUCE_ONLY:\n            return \"REMOVAL_REASON_INVALID_REDUCE_ONLY\";\n        case OrderRemoval_RemovalReason.REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER:\n            return \"REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER\";\n        case OrderRemoval_RemovalReason.REMOVAL_REASON_INVALID_SELF_TRADE:\n            return \"REMOVAL_REASON_INVALID_SELF_TRADE\";\n        case OrderRemoval_RemovalReason.REMOVAL_REASON_CONDITIONAL_FOK_COULD_NOT_BE_FULLY_FILLED:\n            return \"REMOVAL_REASON_CONDITIONAL_FOK_COULD_NOT_BE_FULLY_FILLED\";\n        case OrderRemoval_RemovalReason.REMOVAL_REASON_CONDITIONAL_IOC_WOULD_REST_ON_BOOK:\n            return \"REMOVAL_REASON_CONDITIONAL_IOC_WOULD_REST_ON_BOOK\";\n        case OrderRemoval_RemovalReason.REMOVAL_REASON_FULLY_FILLED:\n            return \"REMOVAL_REASON_FULLY_FILLED\";\n        case OrderRemoval_RemovalReason.REMOVAL_REASON_VIOLATES_ISOLATED_SUBACCOUNT_CONSTRAINTS:\n            return \"REMOVAL_REASON_VIOLATES_ISOLATED_SUBACCOUNT_CONSTRAINTS\";\n        case OrderRemoval_RemovalReason.REMOVAL_REASON_PERMISSIONED_KEY_EXPIRED:\n            return \"REMOVAL_REASON_PERMISSIONED_KEY_EXPIRED\";\n        case OrderRemoval_RemovalReason.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nfunction createBaseOrderRemoval() {\n    return {\n        orderId: undefined,\n        removalReason: 0\n    };\n}\nexport const OrderRemoval = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.orderId !== undefined) {\n            OrderId.encode(message.orderId, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.removalReason !== 0) {\n            writer.uint32(16).int32(message.removalReason);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseOrderRemoval();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.orderId = OrderId.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.removalReason = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseOrderRemoval();\n        message.orderId = object.orderId !== undefined && object.orderId !== null ? OrderId.fromPartial(object.orderId) : undefined;\n        message.removalReason = object.removalReason ?? 0;\n        return message;\n    }\n};\n","// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nimport { Order, OrderId } from \"./order.js\";\nimport { SubaccountId } from \"../subaccounts/subaccount.js\";\nimport { ClobPair } from \"./clob_pair.js\";\nimport { EquityTierLimitConfiguration } from \"./equity_tier_limit_config.js\";\nimport { BlockRateLimitConfiguration } from \"./block_rate_limit_config.js\";\nimport { LiquidationsConfig } from \"./liquidations_config.js\";\nimport { ClobMatch } from \"./matches.js\";\nimport { OrderRemoval } from \"./order_removals.js\";\nimport _m0 from \"protobufjs/minimal.js\";\nfunction createBaseMsgCreateClobPair() {\n    return {\n        authority: \"\",\n        clobPair: undefined\n    };\n}\nexport const MsgCreateClobPair = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.authority !== \"\") {\n            writer.uint32(10).string(message.authority);\n        }\n        if (message.clobPair !== undefined) {\n            ClobPair.encode(message.clobPair, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgCreateClobPair();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.authority = reader.string();\n                    break;\n                case 2:\n                    message.clobPair = ClobPair.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgCreateClobPair();\n        message.authority = object.authority ?? \"\";\n        message.clobPair = object.clobPair !== undefined && object.clobPair !== null ? ClobPair.fromPartial(object.clobPair) : undefined;\n        return message;\n    }\n};\nfunction createBaseMsgCreateClobPairResponse() {\n    return {};\n}\nexport const MsgCreateClobPairResponse = {\n    encode(_, writer = _m0.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgCreateClobPairResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgCreateClobPairResponse();\n        return message;\n    }\n};\nfunction createBaseMsgProposedOperations() {\n    return {\n        operationsQueue: []\n    };\n}\nexport const MsgProposedOperations = {\n    encode(message, writer = _m0.Writer.create()) {\n        for (const v of message.operationsQueue) {\n            OperationRaw.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgProposedOperations();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.operationsQueue.push(OperationRaw.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgProposedOperations();\n        message.operationsQueue = object.operationsQueue?.map(e => OperationRaw.fromPartial(e)) || [];\n        return message;\n    }\n};\nfunction createBaseMsgProposedOperationsResponse() {\n    return {};\n}\nexport const MsgProposedOperationsResponse = {\n    encode(_, writer = _m0.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgProposedOperationsResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgProposedOperationsResponse();\n        return message;\n    }\n};\nfunction createBaseMsgPlaceOrder() {\n    return {\n        order: undefined\n    };\n}\nexport const MsgPlaceOrder = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.order !== undefined) {\n            Order.encode(message.order, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgPlaceOrder();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.order = Order.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgPlaceOrder();\n        message.order = object.order !== undefined && object.order !== null ? Order.fromPartial(object.order) : undefined;\n        return message;\n    }\n};\nfunction createBaseMsgPlaceOrderResponse() {\n    return {};\n}\nexport const MsgPlaceOrderResponse = {\n    encode(_, writer = _m0.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgPlaceOrderResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgPlaceOrderResponse();\n        return message;\n    }\n};\nfunction createBaseMsgCancelOrder() {\n    return {\n        orderId: undefined,\n        goodTilBlock: undefined,\n        goodTilBlockTime: undefined\n    };\n}\nexport const MsgCancelOrder = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.orderId !== undefined) {\n            OrderId.encode(message.orderId, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.goodTilBlock !== undefined) {\n            writer.uint32(16).uint32(message.goodTilBlock);\n        }\n        if (message.goodTilBlockTime !== undefined) {\n            writer.uint32(29).fixed32(message.goodTilBlockTime);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgCancelOrder();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.orderId = OrderId.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.goodTilBlock = reader.uint32();\n                    break;\n                case 3:\n                    message.goodTilBlockTime = reader.fixed32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgCancelOrder();\n        message.orderId = object.orderId !== undefined && object.orderId !== null ? OrderId.fromPartial(object.orderId) : undefined;\n        message.goodTilBlock = object.goodTilBlock ?? undefined;\n        message.goodTilBlockTime = object.goodTilBlockTime ?? undefined;\n        return message;\n    }\n};\nfunction createBaseMsgCancelOrderResponse() {\n    return {};\n}\nexport const MsgCancelOrderResponse = {\n    encode(_, writer = _m0.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgCancelOrderResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgCancelOrderResponse();\n        return message;\n    }\n};\nfunction createBaseMsgBatchCancel() {\n    return {\n        subaccountId: undefined,\n        shortTermCancels: [],\n        goodTilBlock: 0\n    };\n}\nexport const MsgBatchCancel = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.subaccountId !== undefined) {\n            SubaccountId.encode(message.subaccountId, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.shortTermCancels) {\n            OrderBatch.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.goodTilBlock !== 0) {\n            writer.uint32(24).uint32(message.goodTilBlock);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgBatchCancel();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.subaccountId = SubaccountId.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.shortTermCancels.push(OrderBatch.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.goodTilBlock = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgBatchCancel();\n        message.subaccountId = object.subaccountId !== undefined && object.subaccountId !== null ? SubaccountId.fromPartial(object.subaccountId) : undefined;\n        message.shortTermCancels = object.shortTermCancels?.map(e => OrderBatch.fromPartial(e)) || [];\n        message.goodTilBlock = object.goodTilBlock ?? 0;\n        return message;\n    }\n};\nfunction createBaseOrderBatch() {\n    return {\n        clobPairId: 0,\n        clientIds: []\n    };\n}\nexport const OrderBatch = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.clobPairId !== 0) {\n            writer.uint32(8).uint32(message.clobPairId);\n        }\n        writer.uint32(18).fork();\n        for (const v of message.clientIds) {\n            writer.uint32(v);\n        }\n        writer.ldelim();\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseOrderBatch();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.clobPairId = reader.uint32();\n                    break;\n                case 2:\n                    if ((tag & 7) === 2) {\n                        const end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2) {\n                            message.clientIds.push(reader.uint32());\n                        }\n                    }\n                    else {\n                        message.clientIds.push(reader.uint32());\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseOrderBatch();\n        message.clobPairId = object.clobPairId ?? 0;\n        message.clientIds = object.clientIds?.map(e => e) || [];\n        return message;\n    }\n};\nfunction createBaseMsgBatchCancelResponse() {\n    return {\n        shortTermSucceeded: [],\n        shortTermFailed: []\n    };\n}\nexport const MsgBatchCancelResponse = {\n    encode(message, writer = _m0.Writer.create()) {\n        for (const v of message.shortTermSucceeded) {\n            OrderBatch.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.shortTermFailed) {\n            OrderBatch.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgBatchCancelResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.shortTermSucceeded.push(OrderBatch.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.shortTermFailed.push(OrderBatch.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgBatchCancelResponse();\n        message.shortTermSucceeded = object.shortTermSucceeded?.map(e => OrderBatch.fromPartial(e)) || [];\n        message.shortTermFailed = object.shortTermFailed?.map(e => OrderBatch.fromPartial(e)) || [];\n        return message;\n    }\n};\nfunction createBaseMsgUpdateClobPair() {\n    return {\n        authority: \"\",\n        clobPair: undefined\n    };\n}\nexport const MsgUpdateClobPair = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.authority !== \"\") {\n            writer.uint32(10).string(message.authority);\n        }\n        if (message.clobPair !== undefined) {\n            ClobPair.encode(message.clobPair, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgUpdateClobPair();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.authority = reader.string();\n                    break;\n                case 2:\n                    message.clobPair = ClobPair.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgUpdateClobPair();\n        message.authority = object.authority ?? \"\";\n        message.clobPair = object.clobPair !== undefined && object.clobPair !== null ? ClobPair.fromPartial(object.clobPair) : undefined;\n        return message;\n    }\n};\nfunction createBaseMsgUpdateClobPairResponse() {\n    return {};\n}\nexport const MsgUpdateClobPairResponse = {\n    encode(_, writer = _m0.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgUpdateClobPairResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgUpdateClobPairResponse();\n        return message;\n    }\n};\nfunction createBaseOperationRaw() {\n    return {\n        match: undefined,\n        shortTermOrderPlacement: undefined,\n        orderRemoval: undefined\n    };\n}\nexport const OperationRaw = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.match !== undefined) {\n            ClobMatch.encode(message.match, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.shortTermOrderPlacement !== undefined) {\n            writer.uint32(18).bytes(message.shortTermOrderPlacement);\n        }\n        if (message.orderRemoval !== undefined) {\n            OrderRemoval.encode(message.orderRemoval, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseOperationRaw();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.match = ClobMatch.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.shortTermOrderPlacement = reader.bytes();\n                    break;\n                case 3:\n                    message.orderRemoval = OrderRemoval.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseOperationRaw();\n        message.match = object.match !== undefined && object.match !== null ? ClobMatch.fromPartial(object.match) : undefined;\n        message.shortTermOrderPlacement = object.shortTermOrderPlacement ?? undefined;\n        message.orderRemoval = object.orderRemoval !== undefined && object.orderRemoval !== null ? OrderRemoval.fromPartial(object.orderRemoval) : undefined;\n        return message;\n    }\n};\nfunction createBaseMsgUpdateEquityTierLimitConfiguration() {\n    return {\n        authority: \"\",\n        equityTierLimitConfig: undefined\n    };\n}\nexport const MsgUpdateEquityTierLimitConfiguration = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.authority !== \"\") {\n            writer.uint32(10).string(message.authority);\n        }\n        if (message.equityTierLimitConfig !== undefined) {\n            EquityTierLimitConfiguration.encode(message.equityTierLimitConfig, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgUpdateEquityTierLimitConfiguration();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.authority = reader.string();\n                    break;\n                case 2:\n                    message.equityTierLimitConfig = EquityTierLimitConfiguration.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgUpdateEquityTierLimitConfiguration();\n        message.authority = object.authority ?? \"\";\n        message.equityTierLimitConfig = object.equityTierLimitConfig !== undefined && object.equityTierLimitConfig !== null ? EquityTierLimitConfiguration.fromPartial(object.equityTierLimitConfig) : undefined;\n        return message;\n    }\n};\nfunction createBaseMsgUpdateEquityTierLimitConfigurationResponse() {\n    return {};\n}\nexport const MsgUpdateEquityTierLimitConfigurationResponse = {\n    encode(_, writer = _m0.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgUpdateEquityTierLimitConfigurationResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgUpdateEquityTierLimitConfigurationResponse();\n        return message;\n    }\n};\nfunction createBaseMsgUpdateBlockRateLimitConfiguration() {\n    return {\n        authority: \"\",\n        blockRateLimitConfig: undefined\n    };\n}\nexport const MsgUpdateBlockRateLimitConfiguration = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.authority !== \"\") {\n            writer.uint32(10).string(message.authority);\n        }\n        if (message.blockRateLimitConfig !== undefined) {\n            BlockRateLimitConfiguration.encode(message.blockRateLimitConfig, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgUpdateBlockRateLimitConfiguration();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.authority = reader.string();\n                    break;\n                case 3:\n                    message.blockRateLimitConfig = BlockRateLimitConfiguration.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgUpdateBlockRateLimitConfiguration();\n        message.authority = object.authority ?? \"\";\n        message.blockRateLimitConfig = object.blockRateLimitConfig !== undefined && object.blockRateLimitConfig !== null ? BlockRateLimitConfiguration.fromPartial(object.blockRateLimitConfig) : undefined;\n        return message;\n    }\n};\nfunction createBaseMsgUpdateBlockRateLimitConfigurationResponse() {\n    return {};\n}\nexport const MsgUpdateBlockRateLimitConfigurationResponse = {\n    encode(_, writer = _m0.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgUpdateBlockRateLimitConfigurationResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgUpdateBlockRateLimitConfigurationResponse();\n        return message;\n    }\n};\nfunction createBaseMsgUpdateLiquidationsConfig() {\n    return {\n        authority: \"\",\n        liquidationsConfig: undefined\n    };\n}\nexport const MsgUpdateLiquidationsConfig = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.authority !== \"\") {\n            writer.uint32(10).string(message.authority);\n        }\n        if (message.liquidationsConfig !== undefined) {\n            LiquidationsConfig.encode(message.liquidationsConfig, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgUpdateLiquidationsConfig();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.authority = reader.string();\n                    break;\n                case 2:\n                    message.liquidationsConfig = LiquidationsConfig.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgUpdateLiquidationsConfig();\n        message.authority = object.authority ?? \"\";\n        message.liquidationsConfig = object.liquidationsConfig !== undefined && object.liquidationsConfig !== null ? LiquidationsConfig.fromPartial(object.liquidationsConfig) : undefined;\n        return message;\n    }\n};\nfunction createBaseMsgUpdateLiquidationsConfigResponse() {\n    return {};\n}\nexport const MsgUpdateLiquidationsConfigResponse = {\n    encode(_, writer = _m0.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgUpdateLiquidationsConfigResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgUpdateLiquidationsConfigResponse();\n        return message;\n    }\n};\n","// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nimport { SubaccountId } from \"../subaccounts/subaccount.js\";\nimport { Coin } from \"../../cosmos/base/v1beta1/coin.js\";\nimport { Long } from \"../../helpers.js\";\nimport _m0 from \"protobufjs/minimal.js\";\nfunction createBaseTransfer() {\n    return {\n        sender: undefined,\n        recipient: undefined,\n        assetId: 0,\n        amount: Long.UZERO\n    };\n}\nexport const Transfer = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.sender !== undefined) {\n            SubaccountId.encode(message.sender, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.recipient !== undefined) {\n            SubaccountId.encode(message.recipient, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.assetId !== 0) {\n            writer.uint32(24).uint32(message.assetId);\n        }\n        if (!message.amount.isZero()) {\n            writer.uint32(32).uint64(message.amount);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTransfer();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sender = SubaccountId.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.recipient = SubaccountId.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.assetId = reader.uint32();\n                    break;\n                case 4:\n                    message.amount = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseTransfer();\n        message.sender = object.sender !== undefined && object.sender !== null ? SubaccountId.fromPartial(object.sender) : undefined;\n        message.recipient = object.recipient !== undefined && object.recipient !== null ? SubaccountId.fromPartial(object.recipient) : undefined;\n        message.assetId = object.assetId ?? 0;\n        message.amount = object.amount !== undefined && object.amount !== null ? Long.fromValue(object.amount) : Long.UZERO;\n        return message;\n    }\n};\nfunction createBaseMsgDepositToSubaccount() {\n    return {\n        sender: \"\",\n        recipient: undefined,\n        assetId: 0,\n        quantums: Long.UZERO\n    };\n}\nexport const MsgDepositToSubaccount = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.sender !== \"\") {\n            writer.uint32(10).string(message.sender);\n        }\n        if (message.recipient !== undefined) {\n            SubaccountId.encode(message.recipient, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.assetId !== 0) {\n            writer.uint32(24).uint32(message.assetId);\n        }\n        if (!message.quantums.isZero()) {\n            writer.uint32(32).uint64(message.quantums);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgDepositToSubaccount();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sender = reader.string();\n                    break;\n                case 2:\n                    message.recipient = SubaccountId.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.assetId = reader.uint32();\n                    break;\n                case 4:\n                    message.quantums = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgDepositToSubaccount();\n        message.sender = object.sender ?? \"\";\n        message.recipient = object.recipient !== undefined && object.recipient !== null ? SubaccountId.fromPartial(object.recipient) : undefined;\n        message.assetId = object.assetId ?? 0;\n        message.quantums = object.quantums !== undefined && object.quantums !== null ? Long.fromValue(object.quantums) : Long.UZERO;\n        return message;\n    }\n};\nfunction createBaseMsgWithdrawFromSubaccount() {\n    return {\n        sender: undefined,\n        recipient: \"\",\n        assetId: 0,\n        quantums: Long.UZERO\n    };\n}\nexport const MsgWithdrawFromSubaccount = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.sender !== undefined) {\n            SubaccountId.encode(message.sender, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.recipient !== \"\") {\n            writer.uint32(10).string(message.recipient);\n        }\n        if (message.assetId !== 0) {\n            writer.uint32(24).uint32(message.assetId);\n        }\n        if (!message.quantums.isZero()) {\n            writer.uint32(32).uint64(message.quantums);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgWithdrawFromSubaccount();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 2:\n                    message.sender = SubaccountId.decode(reader, reader.uint32());\n                    break;\n                case 1:\n                    message.recipient = reader.string();\n                    break;\n                case 3:\n                    message.assetId = reader.uint32();\n                    break;\n                case 4:\n                    message.quantums = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgWithdrawFromSubaccount();\n        message.sender = object.sender !== undefined && object.sender !== null ? SubaccountId.fromPartial(object.sender) : undefined;\n        message.recipient = object.recipient ?? \"\";\n        message.assetId = object.assetId ?? 0;\n        message.quantums = object.quantums !== undefined && object.quantums !== null ? Long.fromValue(object.quantums) : Long.UZERO;\n        return message;\n    }\n};\nfunction createBaseMsgSendFromModuleToAccount() {\n    return {\n        authority: \"\",\n        senderModuleName: \"\",\n        recipient: \"\",\n        coin: undefined\n    };\n}\nexport const MsgSendFromModuleToAccount = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.authority !== \"\") {\n            writer.uint32(10).string(message.authority);\n        }\n        if (message.senderModuleName !== \"\") {\n            writer.uint32(18).string(message.senderModuleName);\n        }\n        if (message.recipient !== \"\") {\n            writer.uint32(26).string(message.recipient);\n        }\n        if (message.coin !== undefined) {\n            Coin.encode(message.coin, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgSendFromModuleToAccount();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.authority = reader.string();\n                    break;\n                case 2:\n                    message.senderModuleName = reader.string();\n                    break;\n                case 3:\n                    message.recipient = reader.string();\n                    break;\n                case 4:\n                    message.coin = Coin.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgSendFromModuleToAccount();\n        message.authority = object.authority ?? \"\";\n        message.senderModuleName = object.senderModuleName ?? \"\";\n        message.recipient = object.recipient ?? \"\";\n        message.coin = object.coin !== undefined && object.coin !== null ? Coin.fromPartial(object.coin) : undefined;\n        return message;\n    }\n};\n","// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nimport { Transfer } from \"./transfer.js\";\nimport _m0 from \"protobufjs/minimal.js\";\nfunction createBaseMsgCreateTransfer() {\n    return {\n        transfer: undefined\n    };\n}\nexport const MsgCreateTransfer = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.transfer !== undefined) {\n            Transfer.encode(message.transfer, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgCreateTransfer();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.transfer = Transfer.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(object) {\n        const message = createBaseMsgCreateTransfer();\n        message.transfer = object.transfer !== undefined && object.transfer !== null ? Transfer.fromPartial(object.transfer) : undefined;\n        return message;\n    }\n};\nfunction createBaseMsgCreateTransferResponse() {\n    return {};\n}\nexport const MsgCreateTransferResponse = {\n    encode(_, writer = _m0.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgCreateTransferResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgCreateTransferResponse();\n        return message;\n    }\n};\nfunction createBaseMsgDepositToSubaccountResponse() {\n    return {};\n}\nexport const MsgDepositToSubaccountResponse = {\n    encode(_, writer = _m0.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgDepositToSubaccountResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgDepositToSubaccountResponse();\n        return message;\n    }\n};\nfunction createBaseMsgWithdrawFromSubaccountResponse() {\n    return {};\n}\nexport const MsgWithdrawFromSubaccountResponse = {\n    encode(_, writer = _m0.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgWithdrawFromSubaccountResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgWithdrawFromSubaccountResponse();\n        return message;\n    }\n};\nfunction createBaseMsgSendFromModuleToAccountResponse() {\n    return {};\n}\nexport const MsgSendFromModuleToAccountResponse = {\n    encode(_, writer = _m0.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgSendFromModuleToAccountResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgSendFromModuleToAccountResponse();\n        return message;\n    }\n};\n","// ----------------------------------------------------------------------------\n\n// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:\n// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code\n// EDIT THE CORRESPONDENT .ts FILE INSTEAD\n\nimport { PubKey } from './cosmos/crypto/secp256k1/keys.js';\nimport { TxExtension } from './dydxprotocol/accountplus/tx.js';\nimport { MsgPlaceOrder, MsgCancelOrder, MsgBatchCancel, } from './dydxprotocol/clob/tx.js';\nimport { MsgWithdrawFromSubaccount, MsgDepositToSubaccount, } from './dydxprotocol/sending/transfer.js';\nimport { MsgCreateTransfer } from './dydxprotocol/sending/tx.js';\nimport { Any } from \"./google/protobuf/any.js\";\nexport const registry = {\n    // clob\n    '/dydxprotocol.clob.MsgPlaceOrder': MsgPlaceOrder,\n    '/dydxprotocol.clob.MsgCancelOrder': MsgCancelOrder,\n    '/dydxprotocol.clob.MsgBatchCancel': MsgBatchCancel,\n    // sending\n    '/dydxprotocol.sending.MsgCreateTransfer': MsgCreateTransfer,\n    '/dydxprotocol.sending.MsgWithdrawFromSubaccount': MsgWithdrawFromSubaccount,\n    '/dydxprotocol.sending.MsgDepositToSubaccount': MsgDepositToSubaccount,\n    '/dydxprotocol.accountplus.TxExtension': TxExtension,\n    '/cosmos.crypto.secp256k1.PubKey': PubKey,\n};\nexport function encodeAsAny(encodeObject) {\n    const { typeUrl, value } = encodeObject;\n    const type = registry[typeUrl];\n    if (!type) {\n        throw new Error(`Unsupport type url: ${typeUrl}`);\n    }\n    const encodedMsg = type.encode(type.fromPartial(value)).finish();\n    return Any.fromPartial({\n        typeUrl: typeUrl,\n        value: encodedMsg,\n    });\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]}