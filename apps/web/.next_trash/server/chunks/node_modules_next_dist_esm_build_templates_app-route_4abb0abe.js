module.exports=[878756,e=>{"use strict";var t=e.i(747909),a=e.i(174017),n=e.i(996250),s=e.i(759756),r=e.i(561916),i=e.i(174677),o=e.i(869741),l=e.i(316795),u=e.i(487718),d=e.i(995169),c=e.i(47587),p=e.i(666012),m=e.i(570101),_=e.i(626937),h=e.i(10372),b=e.i(193695);e.i(52474);var x=e.i(600220),R=e.i(469719),E=e.i(89171),g=e.i(843793),f=e.i(977775),A=e.i(364608),N=e.i(184883),y=e.i(844297),S=e.i(194748),T=e.i(430848),w=e.i(29984);let C="00000000-0000-0000-0000-000000000001";function v(e,t){let a=process.env[e],n=a?Number(a):NaN;return Number.isFinite(n)?n:t}function I(e,t){let a=process.env[e];if(null==a)return t;let n=a.trim().toLowerCase();return"1"===n||"true"===n||"yes"===n||"on"===n||"0"!==n&&"false"!==n&&"no"!==n&&"off"!==n&&t}function O(e,t,a){return Math.max(t,Math.min(a,e))}function U(e){let t=0x811c9dc5;for(let a=0;a<e.length;a++)t^=e.charCodeAt(a),t=Math.imul(t,0x1000193);return(t>>>0)/0xffffffff}async function $(e,t,a){let n=await e`
        WITH asset AS (
            SELECT id
            FROM ex_asset
            WHERE chain = 'bsc' AND symbol = ${a} AND is_enabled = true
            LIMIT 1
        ),
        acct AS (
            SELECT id
            FROM ex_ledger_account
            WHERE user_id = ${t}::uuid
                AND asset_id = (SELECT id FROM asset)
            LIMIT 1
        ),
        posted AS (
            SELECT coalesce(sum(amount), 0)::numeric AS posted
            FROM ex_journal_line
            WHERE account_id = (SELECT id FROM acct)
        ),
        held AS (
            SELECT coalesce(sum(remaining_amount), 0)::numeric AS held
            FROM ex_hold
            WHERE account_id = (SELECT id FROM acct)
                AND status = 'active'
        )
        SELECT (posted.posted - held.held)::text AS available
        FROM posted, held
    `,s=Number(n[0]?.available??"0");return Number.isFinite(s)&&s>0?s:0}let M=R.z.object({opp:R.z.object({symbol:R.z.string().trim().min(1),buyExchange:R.z.string().trim().min(1),sellExchange:R.z.string().trim().min(1),buyAsk:R.z.coerce.number().positive(),sellBid:R.z.coerce.number().positive()})});async function D(e){let t=(0,g.getSql)(),a=(0,f.getActingUserId)(e),n=(0,f.requireActingUserIdInProd)(a);if(n)return E.NextResponse.json({error:n},{status:401});if(!a)return E.NextResponse.json({error:"Unauthorized"},{status:401});let s=I("ARB_INTERNAL_SETTLEMENT_ENABLED",!0);if(!s&&"1"!==process.env.ARB_AUTOTRADE_ENABLED)return E.NextResponse.json({error:"autotrade_disabled",message:"Auto-trade is currently disabled. The arbitrage page is scanner-only until enabled by the operator."},{status:403});try{let n,r,i=await (0,A.requireActiveUser)(t,a);if(i)return E.NextResponse.json({error:i},{status:403});let o=M.safeParse(await e.json().catch(()=>({})));if(!o.success)return E.NextResponse.json({error:"invalid_input",detail:o.error.flatten()},{status:400});let l=o.data.opp,u=l.buyExchange.toLowerCase(),d=l.sellExchange.toLowerCase(),c="tradesynapse"===u,p="tradesynapse"===d,m=s?"internal":"external",_=new Set(["binance","bybit"]);if(!c&&!_.has(u)&&"external"===m)return E.NextResponse.json({error:`unsupported_buy_exchange:${u}`},{status:400});if(!p&&!_.has(d)&&"external"===m)return E.NextResponse.json({error:`unsupported_sell_exchange:${d}`},{status:400});let h="internal"===m?[]:[...c?[]:[u],...p?[]:[d]],b=h.length?await t`
                    SELECT exchange, api_key_enc, api_secret_enc, passphrase_enc, created_at
                    FROM user_exchange_connection
                    WHERE user_id = ${a}
                        AND status = 'active'
                        AND exchange IN (${t(h)})
                    ORDER BY created_at DESC
                `:[],x=e=>{let t=b.find(t=>t.exchange===e);return t?{apiKey:(0,y.decryptCredential)(t.api_key_enc),apiSecret:(0,y.decryptCredential)(t.api_secret_enc),passphrase:t.passphrase_enc?(0,y.decryptCredential)(t.passphrase_enc):void 0}:null},R=c?null:x(u),g=p?null:x(d);if("external"===m&&!c&&!R)return E.NextResponse.json({error:`missing_connection:${u}`},{status:400});if("external"===m&&!p&&!g)return E.NextResponse.json({error:`missing_connection:${d}`},{status:400});let f={buy:null,sell:null},N=O(v("ARB_MIN_NOTIONAL_USD",25),5,500),D=O(v("ARB_NOTIONAL_USD_CAP",1e3),N,1e5),P=O(v("ARB_NOTIONAL_USD",N),N,D),k=await $(t,a,"USDT");if("internal"===m&&k+1e-9<N)return E.NextResponse.json({error:"insufficient_usdt",message:`Deposit/hold at least $${N.toFixed(2)} USDT to unlock auto-trade.`,requiredUsd:N,availableUsdt:k},{status:403});let[F,B]=await Promise.all([(0,w.getExchangeTicker)(u,l.symbol),(0,w.getExchangeTicker)(d,l.symbol)]),L=Number.parseFloat(String(F.ask)),j=Number.parseFloat(String(B.bid));if(!Number.isFinite(L)||!Number.isFinite(j)||L<=0||j<=0)return E.NextResponse.json({error:"quote_unavailable",message:"Could not fetch executable bid/ask for this symbol right now."},{status:502});let q=Math.max(0,v("ARB_MAX_PRICE_DRIFT_PCT",.25)),H=(L-l.buyAsk)/l.buyAsk*100,K=(l.sellBid-j)/l.sellBid*100;if(Number.isFinite(H)&&H>q)return E.NextResponse.json({error:"stale_price",message:`Buy price moved by ${H.toFixed(3)}% (limit ${q}%). Re-scan and try again.`,quote:{buyAsk:L,sellBid:j,ts:new Date().toISOString()}},{status:409});if(Number.isFinite(K)&&K>q)return E.NextResponse.json({error:"stale_price",message:`Sell price moved by ${K.toFixed(3)}% (limit ${q}%). Re-scan and try again.`,quote:{buyAsk:L,sellBid:j,ts:new Date().toISOString()}},{status:409});if("internal"===m){let e=O(v("ARB_ACTION_WINDOW_SECS",90),15,600),n=Math.floor(Date.now()/1e3/e),s=O(v("ARB_ACTIONABLE_BASE_PCT",18),1,95)/100,r=Math.max(0,v("ARB_TAKER_FEE_BPS",10)),i=2*r/100,o=Math.max(0,v("ARB_LATENCY_BPS",2))/100,c=(j-L)/L*100,p=Math.max(0,Math.min(.45,(c-.1)*.12)),m=Math.min(.9,s+p);if(!(U(`${a}:${l.symbol}:${u}:${d}:${n}`)<m))return E.NextResponse.json({error:"execution_window_closed",message:"This opportunity is currently in cooldown. Keep scanning for the next actionable window."},{status:409});let _=Math.max(0,v("ARB_INTERNAL_UNCERTAINTY_BPS",18)),h=Math.max(0,v("ARB_INTERNAL_HOUSE_EDGE_BPS",4)),b=U(`${a}:${l.symbol}:${Date.now()}:${L}:${j}`),x=(2*b-1)*_/100,R=h/100,g=c-i-o-R+x,f=v("ARB_MIN_NET_SPREAD_PCT",.05);if(!Number.isFinite(g)||g<f)return E.NextResponse.json({error:"not_profitable",message:`Net spread ${g.toFixed(3)}% below minimum ${f}% (fees+latency assumed ${(i+o).toFixed(3)}%).`,quote:{buyAsk:L,sellBid:j,grossSpreadPct:c,netSpreadPct:g,ts:new Date().toISOString()}},{status:409});let A=g/100*P,N=O(v("ARB_INTERNAL_MAX_GAIN_PCT",.75),.01,10),y=O(v("ARB_INTERNAL_MAX_LOSS_PCT",.95),.01,10),w=N/100*P,I=-(y/100*P),M=Math.max(I,Math.min(w,A));if(k+M<0)return E.NextResponse.json({error:"insufficient_usdt_risk",message:"This execution would overdraw your USDT balance.",sizing:{userUsdt:k,pnlUsd:M,notionalUsdExec:P}},{status:409});let D=await t.begin(async e=>{let t=await (0,T.chargeGasFee)(e,{userId:a,action:"arbitrage_execute",reference:l.symbol});if(t)return{ok:!1,error:t.code,details:t.details};let n=await e`
                            SELECT id::text AS id
                            FROM ex_asset
                            WHERE chain = 'bsc' AND symbol = 'USDT' AND is_enabled = true
                            LIMIT 1
                        `,s=n[0]?.id;if(!s)return{ok:!1,error:"usdt_asset_not_found"};let r=await e`
                            INSERT INTO ex_ledger_account (user_id, asset_id)
                            VALUES
                                                            (${a}::uuid, ${s}::uuid),
                                                            (${C}::uuid, ${s}::uuid)
                            ON CONFLICT (user_id, asset_id) DO UPDATE SET user_id = EXCLUDED.user_id
                            RETURNING user_id::text AS user_id, id::text AS id
                        `,i=r.find(e=>e.user_id===a)?.id,o=r.find(e=>e.user_id===C)?.id;if(!i||!o)return{ok:!1,error:"usdt_accounts_not_found"};let p=await $(e,C,"USDT");if(M>0&&p+1e-9<M)return{ok:!1,error:"settlement_pool_depleted"};let m=(await e`
                            INSERT INTO ex_journal_entry (type, reference, metadata_json)
                            VALUES (
                              'arb_internal_settlement',
                              ${`${l.symbol} ${u}->${d}`},
                              ${JSON.stringify({symbol:l.symbol,buyExchange:u,sellExchange:d,buyAsk:L,sellBid:j,grossSpreadPct:c,netSpreadPct:g,notionalUsdExec:P,pnlUsd:M,mode:"internal"})}::jsonb
                            )
                            RETURNING id::text AS id
                        `)[0].id;await e`
                            INSERT INTO ex_journal_line (entry_id, account_id, asset_id, amount)
                            VALUES
                            (${m}::uuid, ${i}::uuid, ${s}::uuid, (${M}::numeric)),
                            (${m}::uuid, ${o}::uuid, ${s}::uuid, ((${M}::numeric) * -1))
                        `;let _=await $(e,a,"USDT"),h=await $(e,C,"USDT");return await (0,S.createNotification)(e,{userId:a,type:M>=0?"trade_won":"trade_lost",title:M>=0?"Arbitrage settled":"Arbitrage settled (loss)",body:`${l.symbol} ${u}->${d} \xb7 ${M>=0?"+":""}$${M.toFixed(2)} USDT`,metadata:{symbol:l.symbol,buyExchange:u,sellExchange:d,pnlUsd:M,netSpreadPct:g,mode:"internal"}}),{ok:!0,entryId:m,updatedUsdt:_,notionalUsdExec:P,grossSpreadPct:c,netSpreadPct:g,pnlUsd:M,systemAvailBefore:p,systemAvailAfter:h}});if(!D.ok)return E.NextResponse.json({error:D.error,message:"Internal settlement failed.",details:D.details},{status:"insufficient_gas"===D.error?409:500});return E.NextResponse.json({success:!0,data:{mode:"internal",buy:{exchange:u,status:"quoted",price:L},sell:{exchange:d,status:"quoted",price:j},quote:{buyAsk:L,sellBid:j,grossSpreadPct:D.grossSpreadPct,netSpreadPct:D.netSpreadPct,ts:new Date().toISOString()},sizing:{notionalUsdTarget:P,notionalUsdExec:D.notionalUsdExec},settlement:{entryId:D.entryId,pnlUsd:D.pnlUsd,model:{uncertaintyBps:_,houseEdgeBps:h,maxGainPct:N,maxLossPct:y}},balances:{usdtAvailable:D.updatedUsdt,settlementPoolUsdt:D.systemAvailAfter}}})}let z=I("ARB_AUTOTRADE_REQUIRE_CONSTRAINTS",!0),[W,G]=await Promise.all([(0,w.getExchangeMarketConstraints)(u,l.symbol),(0,w.getExchangeMarketConstraints)(d,l.symbol)]);if(f.constraints={buy:W,sell:G},z&&(!W.ok||!G.ok))return E.NextResponse.json({error:"constraints_unavailable",message:"Could not verify min/precision constraints for this symbol on one or both exchanges; auto-trade aborted.",constraints:f.constraints},{status:409});let[X,V]=await Promise.all([(0,w.getExchangeBalances)(u,R),(0,w.getExchangeBalances)(d,g)]),Y=X.find(e=>"USDT"===String(e.asset).toUpperCase())?.free??0,Q=(n=Number(Y),Number.isFinite(n)&&n>0?n:0),J=l.symbol.toUpperCase().replace("USDT",""),Z=V.find(e=>String(e.asset).toUpperCase()===J)?.free??0,ee=(r=Number(Z),Number.isFinite(r)&&r>0?r:0);f.balances={buy:{exchange:u,usdtFree:Q},sell:{exchange:d,base:J,baseFree:ee}};let et=L>0?Q/L:0,ea=L>0?P/L:0,en=Math.max(0,Math.min(ea,et,ee));if(!(en>0))return E.NextResponse.json({error:"insufficient_balances",message:"Not enough free balance on one or both exchanges to execute this opportunity.",balances:f.balances},{status:409});let es=Math.max(0,Math.floor(v("ARB_AUTOTRADE_FALLBACK_QTY_PRECISION",6))),er=W.ok&&G.ok?Math.min(W.amountPrecision??es,G.amountPrecision??es):es,ei=function(e,t){if(!Number.isFinite(e))return 0;let a=Math.max(0,Math.min(18,Math.floor(t))),n=10**a;return Math.floor(e*n)/n}(en,er),eo=W.ok&&G.ok?Math.max(W.amountMin??0,G.amountMin??0):0;if(eo>0&&ei<eo)return E.NextResponse.json({error:"min_qty_not_met",message:`Executable quantity ${ei} is below minimum ${eo} on one or both venues.`,constraints:f.constraints,balances:f.balances},{status:409});let el=ei*L,eu=ei*j,ed=W.ok?W.costMin??0:0,ec=G.ok?G.costMin??0:0;if(ed>0&&el<ed||ec>0&&eu<ec)return E.NextResponse.json({error:"min_notional_not_met",message:"Executable notional is below the exchange minimum on one or both venues.",detail:{buyNotionalUsd:el,sellNotionalUsd:eu,costMinBuy:ed,costMinSell:ec},constraints:f.constraints},{status:409});let[ep,em]=await Promise.all([(0,w.getAuthenticatedTradingFee)(u,R,l.symbol).catch(()=>null),(0,w.getAuthenticatedTradingFee)(d,g,l.symbol).catch(()=>null)]),e_=Math.max(0,v("ARB_TAKER_FEE_BPS",10)),eh=ep?.taker??null,eb=em?.taker??null,ex=null!=eh&&null!=eb?(eh+eb)*100:2*e_/100,eR=(j-L)/L*100,eE=eR-ex,eg=v("ARB_MIN_NET_SPREAD_PCT",.05);if(f.fees={buy:ep,sell:em,feePct:ex},!Number.isFinite(eE)||eE<eg)return E.NextResponse.json({error:"not_profitable",message:`Net spread ${eE.toFixed(3)}% below minimum ${eg}% (fees assumed ${ex.toFixed(3)}%).`,quote:{buyAsk:L,sellBid:j,grossSpreadPct:eR,netSpreadPct:eE,ts:new Date().toISOString()},fees:f.fees},{status:409});let ef=ei*L;f.sizing={notionalUsdTarget:P,notionalUsdExec:ef,qtyPrecision:er},f.quote={buyAsk:L,sellBid:j,grossSpreadPct:eR,netSpreadPct:eE,ts:new Date().toISOString()};let eA=ei.toFixed(er);try{c?f.buy={status:"filled",price:l.buyAsk,exchange:"tradesynapse"}:f.buy=await (0,w.placeExchangeOrder)(u,R,{symbol:l.symbol,side:"buy",type:"market",quantity:eA}),f.buy&&(p?f.sell={status:"filled",price:l.sellBid,exchange:"tradesynapse"}:f.sell=await (0,w.placeExchangeOrder)(d,g,{symbol:l.symbol,side:"sell",type:"market",quantity:eA}))}catch(e){return console.error("Arbitrage execution failed:",e),E.NextResponse.json({success:!1,message:"Execution halted",error:e instanceof Error?e.message:String(e),partialResults:f},{status:500})}return E.NextResponse.json({success:!0,data:f})}catch(t){let e=(0,N.responseForDbError)("exchange.arbitrage.execute",t);if(e)return e;throw t}}e.s(["POST",()=>D,"dynamic",0,"force-dynamic","runtime",0,"nodejs"],159092);var P=e.i(159092);let k=new t.AppRouteRouteModule({definition:{kind:a.RouteKind.APP_ROUTE,page:"/api/exchange/arbitrage/execute/route",pathname:"/api/exchange/arbitrage/execute",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/src/app/api/exchange/arbitrage/execute/route.ts",nextConfigOutput:"",userland:P}),{workAsyncStorage:F,workUnitAsyncStorage:B,serverHooks:L}=k;function j(){return(0,n.patchFetch)({workAsyncStorage:F,workUnitAsyncStorage:B})}async function q(e,t,n){k.isDev&&(0,s.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let R="/api/exchange/arbitrage/execute/route";R=R.replace(/\/index$/,"")||"/";let E=await k.prepare(e,t,{srcPage:R,multiZoneDraftMode:!1});if(!E)return t.statusCode=400,t.end("Bad Request"),null==n.waitUntil||n.waitUntil.call(n,Promise.resolve()),null;let{buildId:g,params:f,nextConfig:A,parsedUrl:N,isDraftMode:y,prerenderManifest:S,routerServerContext:T,isOnDemandRevalidate:w,revalidateOnlyGenerated:C,resolvedPathname:v,clientReferenceManifest:I,serverActionsManifest:O}=E,U=(0,o.normalizeAppPath)(R),$=!!(S.dynamicRoutes[U]||S.routes[v]),M=async()=>((null==T?void 0:T.render404)?await T.render404(e,t,N,!1):t.end("This page could not be found"),null);if($&&!y){let e=!!S.routes[v],t=S.dynamicRoutes[U];if(t&&!1===t.fallback&&!e){if(A.experimental.adapterPath)return await M();throw new b.NoFallbackError}}let D=null;!$||k.isDev||y||(D="/index"===(D=v)?"/":D);let P=!0===k.isDev||!$,F=$&&!P;O&&I&&(0,i.setManifestsSingleton)({page:R,clientReferenceManifest:I,serverActionsManifest:O});let B=e.method||"GET",L=(0,r.getTracer)(),j=L.getActiveScopeSpan(),q={params:f,prerenderManifest:S,renderOpts:{experimental:{authInterrupts:!!A.experimental.authInterrupts},cacheComponents:!!A.cacheComponents,supportsDynamicResponse:P,incrementalCache:(0,s.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:A.cacheLife,waitUntil:n.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,a,n,s)=>k.onRequestError(e,t,n,s,T)},sharedContext:{buildId:g}},H=new l.NodeNextRequest(e),K=new l.NodeNextResponse(t),z=u.NextRequestAdapter.fromNodeNextRequest(H,(0,u.signalFromNodeResponse)(t));try{let i=async e=>k.handle(z,q).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let a=L.getRootSpanAttributes();if(!a)return;if(a.get("next.span_type")!==d.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${a.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let n=a.get("next.route");if(n){let t=`${B} ${n}`;e.setAttributes({"next.route":n,"http.route":n,"next.span_name":t}),e.updateName(t)}else e.updateName(`${B} ${R}`)}),o=!!(0,s.getRequestMeta)(e,"minimalMode"),l=async s=>{var r,l;let u=async({previousCacheEntry:a})=>{try{if(!o&&w&&C&&!a)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let r=await i(s);e.fetchMetrics=q.renderOpts.fetchMetrics;let l=q.renderOpts.pendingWaitUntil;l&&n.waitUntil&&(n.waitUntil(l),l=void 0);let u=q.renderOpts.collectedTags;if(!$)return await (0,p.sendResponse)(H,K,r,q.renderOpts.pendingWaitUntil),null;{let e=await r.blob(),t=(0,m.toNodeOutgoingHttpHeaders)(r.headers);u&&(t[h.NEXT_CACHE_TAGS_HEADER]=u),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let a=void 0!==q.renderOpts.collectedRevalidate&&!(q.renderOpts.collectedRevalidate>=h.INFINITE_CACHE)&&q.renderOpts.collectedRevalidate,n=void 0===q.renderOpts.collectedExpire||q.renderOpts.collectedExpire>=h.INFINITE_CACHE?void 0:q.renderOpts.collectedExpire;return{value:{kind:x.CachedRouteKind.APP_ROUTE,status:r.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:a,expire:n}}}}catch(t){throw(null==a?void 0:a.isStale)&&await k.onRequestError(e,t,{routerKind:"App Router",routePath:R,routeType:"route",revalidateReason:(0,c.getRevalidateReason)({isStaticGeneration:F,isOnDemandRevalidate:w})},!1,T),t}},d=await k.handleResponse({req:e,nextConfig:A,cacheKey:D,routeKind:a.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:S,isRoutePPREnabled:!1,isOnDemandRevalidate:w,revalidateOnlyGenerated:C,responseGenerator:u,waitUntil:n.waitUntil,isMinimalMode:o});if(!$)return null;if((null==d||null==(r=d.value)?void 0:r.kind)!==x.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==d||null==(l=d.value)?void 0:l.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});o||t.setHeader("x-nextjs-cache",w?"REVALIDATED":d.isMiss?"MISS":d.isStale?"STALE":"HIT"),y&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let b=(0,m.fromNodeOutgoingHttpHeaders)(d.value.headers);return o&&$||b.delete(h.NEXT_CACHE_TAGS_HEADER),!d.cacheControl||t.getHeader("Cache-Control")||b.get("Cache-Control")||b.set("Cache-Control",(0,_.getCacheControlHeader)(d.cacheControl)),await (0,p.sendResponse)(H,K,new Response(d.value.body,{headers:b,status:d.value.status||200})),null};j?await l(j):await L.withPropagatedContext(e.headers,()=>L.trace(d.BaseServerSpan.handleRequest,{spanName:`${B} ${R}`,kind:r.SpanKind.SERVER,attributes:{"http.method":B,"http.target":e.url}},l))}catch(t){if(t instanceof b.NoFallbackError||await k.onRequestError(e,t,{routerKind:"App Router",routePath:U,routeType:"route",revalidateReason:(0,c.getRevalidateReason)({isStaticGeneration:F,isOnDemandRevalidate:w})},!1,T),$)throw t;return await (0,p.sendResponse)(H,K,new Response(null,{status:500})),null}}e.s(["handler",()=>q,"patchFetch",()=>j,"routeModule",()=>k,"serverHooks",()=>L,"workAsyncStorage",()=>F,"workUnitAsyncStorage",()=>B],878756)}];

//# sourceMappingURL=node_modules_next_dist_esm_build_templates_app-route_4abb0abe.js.map