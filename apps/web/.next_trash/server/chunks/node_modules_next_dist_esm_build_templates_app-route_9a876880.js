module.exports=[496508,e=>{"use strict";var t=e.i(747909),r=e.i(174017),a=e.i(996250),n=e.i(759756),i=e.i(561916),u=e.i(174677),s=e.i(869741),o=e.i(316795),d=e.i(487718),l=e.i(995169),c=e.i(47587),_=e.i(666012),p=e.i(570101),E=e.i(626937),m=e.i(10372),f=e.i(193695);e.i(52474);var h=e.i(600220),R=e.i(89171),y=e.i(843793),w=e.i(184883),g=e.i(344263),b=e.i(630862),S=e.i(991654),T=e.i(194748),A=e.i(24672),x=e.i(358217);async function v(e,t,r){return(await e`
    INSERT INTO ex_ledger_account (user_id, asset_id)
    VALUES (${t}::uuid, ${r}::uuid)
    ON CONFLICT (user_id, asset_id) DO UPDATE SET user_id = EXCLUDED.user_id
    RETURNING id::text AS id
  `)[0].id}async function N(e,t){await e`
    INSERT INTO app_user (id, status, kyc_level, country)
    VALUES (${t}::uuid, 'active', 'none', NULL)
    ON CONFLICT (id) DO NOTHING
  `}async function C(e,t){let r=await e`
    WITH posted AS (
      SELECT coalesce(sum(amount), 0)::numeric AS posted
      FROM ex_journal_line
      WHERE account_id = ${t}::uuid
    ),
    held AS (
      SELECT coalesce(sum(remaining_amount), 0)::numeric AS held
      FROM ex_hold
      WHERE account_id = ${t}::uuid AND status = 'active'
    )
    SELECT (posted.posted - held.held)::text AS available
    FROM posted, held
  `;return r[0]?.available??"0"}let I="00000000-0000-0000-0000-000000000002",O="00000000-0000-0000-0000-000000000001";async function $(e){let t,r=function(e){let t=process.env.EXCHANGE_CRON_SECRET??process.env.CRON_SECRET;if(!t)return"cron_secret_not_configured";let r=e.headers.get("x-cron-secret")??e.nextUrl.searchParams.get("secret");return r&&r===t?null:"cron_unauthorized"}(e);if(r)return R.NextResponse.json({error:r},{status:"cron_unauthorized"===r?401:500});let a="1"!==(t=String(process.env.EXCHANGE_ENABLE_RECURRING_BUYS??"").trim())&&"true"!==t.toLowerCase()?"recurring_buys_disabled":null;if(a)return R.NextResponse.json({ok:!1,error:a},{status:403});let n=(0,y.getSql)(),i=Math.max(1,Math.min(200,Number(new URL(e.url).searchParams.get("max")??"50")||50)),u="exchange:recurring-buys",s=`${process.env.RAILWAY_SERVICE_NAME??process.env.SERVICE_NAME??"web"}:${crypto.randomUUID()}`,o=await (0,x.tryAcquireJobLock)(n,{key:u,holderId:s,ttlMs:12e4});if(!o.acquired)return R.NextResponse.json({ok:!1,error:"job_in_progress",held_until:o.held_until,holder_id:o.holder_id},{status:429});let d=0,l=0,c=0,_=0;try{for(let e of(await (0,w.retryOnceOnTransientDbError)(async()=>await n`
        SELECT id::text AS id
        FROM app_recurring_buy_plan
        WHERE status = 'active'
          AND next_run_at <= now()
        ORDER BY next_run_at ASC
        LIMIT ${i}
      `))){d+=1;try{let t=await n.begin(async t=>{var r;let a=await t`
            SELECT
              id::text AS id,
              user_id::text AS user_id,
              status,
              from_symbol,
              to_symbol,
              amount_in::text AS amount_in,
              cadence,
              next_run_at,
              auth_expires_at
            FROM app_recurring_buy_plan
            WHERE id = ${e.id}::uuid
              AND status = 'active'
              AND next_run_at <= now()
            LIMIT 1
            FOR UPDATE SKIP LOCKED
          `;if(!a.length)return{status:"skipped",reason:"not_due_or_locked"};let n=a[0],i=n.next_run_at,u=(await t`
            INSERT INTO app_recurring_buy_run (
              plan_id, user_id, scheduled_for, status, from_symbol, to_symbol, amount_in
            )
            VALUES (
              ${n.id}::uuid,
              ${n.user_id}::uuid,
              ${i.toISOString()}::timestamptz,
              'failed',
              ${String(n.from_symbol)},
              ${String(n.to_symbol)},
              ${String(n.amount_in)}::numeric(38,18)
            )
            RETURNING id::text AS id
          `)[0].id,s=n.auth_expires_at?new Date(n.auth_expires_at).getTime():null;if(null!=s&&s<=Date.now()){await t`
              UPDATE app_recurring_buy_plan
              SET status = 'paused',
                  last_run_at = now(),
                  last_run_status = 'failed',
                  last_run_error = 'auth_expired',
                  updated_at = now()
              WHERE id = ${n.id}::uuid
            `,await t`
              UPDATE app_recurring_buy_run
              SET status = 'skipped',
                  error = 'auth_expired',
                  finished_at = now()
              WHERE id = ${u}::uuid
            `;try{await (0,T.createNotification)(t,{userId:n.user_id,type:"system",title:"Recurring buy paused",body:"Your recurring buy needs re-authorization. Open Account → Notifications/Automation and resume it.",metadata:{kind:"recurring_buy",plan_id:n.id}})}catch{}return{status:"skipped",reason:"auth_expired"}}let o=String(n.from_symbol).trim().toUpperCase(),d=String(n.to_symbol).trim().toUpperCase(),l=String(n.amount_in).trim(),c=await t`
            SELECT id::text AS id, symbol
            FROM ex_asset
            WHERE chain = 'bsc'
              AND is_enabled = true
              AND symbol = ANY(${[o,d]})
          `,_=c.find(e=>e.symbol.toUpperCase()===o)??null,p=c.find(e=>e.symbol.toUpperCase()===d)??null;if(!_||!p)return await t`
              UPDATE app_recurring_buy_run
              SET status = 'failed', error = 'asset_not_found', finished_at = now()
              WHERE id = ${u}::uuid
            `,await t`
              UPDATE app_recurring_buy_plan
              SET last_run_at = now(), last_run_status = 'failed', last_run_error = 'asset_not_found',
                  next_run_at = now() + interval '6 hours', updated_at = now()
              WHERE id = ${n.id}::uuid
            `,{status:"failed",reason:"asset_not_found"};let E=(0,g.convertFeeBps)(),m=await (0,g.quoteConvert)(t,{fromSymbol:o,toSymbol:d,amountIn:l,feeBps:E});if(!m)return await t`
              UPDATE app_recurring_buy_run
              SET status = 'failed', error = 'quote_unavailable', finished_at = now()
              WHERE id = ${u}::uuid
            `,await t`
              UPDATE app_recurring_buy_plan
              SET last_run_at = now(), last_run_status = 'failed', last_run_error = 'quote_unavailable',
                  next_run_at = now() + interval '1 hour', updated_at = now()
              WHERE id = ${n.id}::uuid
            `,{status:"failed",reason:"quote_unavailable"};let f=await v(t,n.user_id,_.id),h=await C(t,f);if((0,b.toBigInt3818)(h)<(0,b.toBigInt3818)(m.amountIn))return await t`
              UPDATE app_recurring_buy_run
              SET status = 'skipped', error = 'insufficient_balance', finished_at = now()
              WHERE id = ${u}::uuid
            `,await t`
              UPDATE app_recurring_buy_plan
              SET last_run_at = now(), last_run_status = 'failed', last_run_error = 'insufficient_balance',
                  next_run_at = now() + interval '6 hours', updated_at = now()
              WHERE id = ${n.id}::uuid
            `,{status:"skipped",reason:"insufficient_balance"};await Promise.all([N(t,I),N(t,O)]);let[R,y,w,A]=await Promise.all([v(t,n.user_id,p.id),v(t,I,_.id),v(t,I,p.id),v(t,O,_.id)]),x=await C(t,w);if((0,b.toBigInt3818)(x)<(0,b.toBigInt3818)(m.amountOut))return await t`
              UPDATE app_recurring_buy_run
              SET status = 'failed', error = 'liquidity_unavailable', finished_at = now()
              WHERE id = ${u}::uuid
            `,await t`
              UPDATE app_recurring_buy_plan
              SET last_run_at = now(), last_run_status = 'failed', last_run_error = 'liquidity_unavailable',
                  next_run_at = now() + interval '2 hours', updated_at = now()
              WHERE id = ${n.id}::uuid
            `,{status:"failed",reason:"liquidity_unavailable"};let $=`dca:${n.id}:${Date.now()}`,U=(await t`
            INSERT INTO ex_journal_entry (type, reference, metadata_json)
            VALUES (
              'convert',
              ${$},
              ${t.json({user_id:n.user_id,automation:"recurring_buy",plan_id:n.id,from:o,to:d,amount_in:m.amountIn,fee_in:m.feeIn,net_in:m.netIn,amount_out:m.amountOut,rate_to_per_from:m.rateToPerFrom,fee_bps:E,price_source:m.priceSource})}::jsonb
            )
            RETURNING id::text AS id, created_at::text AS created_at
          `)[0].id;for(let e of(0,g.buildConvertJournalLines)({userFromAcct:f,userToAcct:R,systemFromAcct:y,systemToAcct:w,treasuryFromAcct:A,fromAssetId:_.id,toAssetId:p.id,quote:m}))await t`
              INSERT INTO ex_journal_line (entry_id, account_id, asset_id, amount)
              VALUES (${U}::uuid, ${e.accountId}::uuid, ${e.assetId}::uuid, (${e.amount}::numeric))
            `;await (0,S.recordInternalChainTx)(t,{entryId:U,type:"convert",userId:n.user_id,metadata:{automation:"recurring_buy",plan_id:n.id,from:o,to:d,amount_in:m.amountIn,amount_out:m.amountOut,fee_bps:E,price_source:m.priceSource}});let D=new Date(Date.now()+(r=String(n.cadence),"weekly"===r?6048e5:864e5));await t`
            UPDATE app_recurring_buy_run
            SET status = 'success',
                error = NULL,
                entry_id = ${U}::uuid,
                amount_out = ${m.amountOut}::numeric(38,18),
                rate_to_per_from = ${m.rateToPerFrom}::numeric(38,18),
                finished_at = now()
            WHERE id = ${u}::uuid
          `,await t`
            UPDATE app_recurring_buy_plan
            SET last_run_at = now(),
                last_run_status = 'success',
                last_run_error = NULL,
                last_entry_id = ${U}::uuid,
                next_run_at = ${D.toISOString()}::timestamptz,
                updated_at = now()
            WHERE id = ${n.id}::uuid
          `;try{await (0,T.createNotification)(t,{userId:n.user_id,type:"system",title:"Recurring buy executed",body:`${m.amountIn} ${o} → ${m.amountOut} ${d}`,metadata:{kind:"recurring_buy",plan_id:n.id,entry_id:U,href:"/wallet"}})}catch{}return{status:"success",entryId:U}});"success"===t.status?l+=1:"failed"===t.status?c+=1:_+=1}catch{c+=1}}try{await (0,A.upsertServiceHeartbeat)(n,{service:"cron:recurring-buys",status:"ok",details:{processed:d,succeeded:l,failed:c,skipped:_}})}catch{}return R.NextResponse.json({ok:!0,processed:d,succeeded:l,failed:c,skipped:_})}catch(e){try{await (0,A.upsertServiceHeartbeat)(n,{service:"cron:recurring-buys",status:"error",details:{message:e instanceof Error?e.message:String(e)}})}catch{}if((0,w.responseForDbError)("exchange.cron.recurring-buys",e))return R.NextResponse.json({ok:!1,error:"db_error"},{status:500});return R.NextResponse.json({ok:!1,error:"internal_error"},{status:500})}finally{try{await (0,x.releaseJobLock)(n,{key:u,holderId:s})}catch{}}}async function U(e){return $(e)}e.s(["GET",()=>U,"POST",()=>$,"dynamic",0,"force-dynamic","runtime",0,"nodejs"],911346);var D=e.i(911346);let P=new t.AppRouteRouteModule({definition:{kind:r.RouteKind.APP_ROUTE,page:"/api/exchange/cron/recurring-buys/route",pathname:"/api/exchange/cron/recurring-buys",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/src/app/api/exchange/cron/recurring-buys/route.ts",nextConfigOutput:"",userland:D}),{workAsyncStorage:H,workUnitAsyncStorage:L,serverHooks:k}=P;function M(){return(0,a.patchFetch)({workAsyncStorage:H,workUnitAsyncStorage:L})}async function q(e,t,a){P.isDev&&(0,n.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let R="/api/exchange/cron/recurring-buys/route";R=R.replace(/\/index$/,"")||"/";let y=await P.prepare(e,t,{srcPage:R,multiZoneDraftMode:!1});if(!y)return t.statusCode=400,t.end("Bad Request"),null==a.waitUntil||a.waitUntil.call(a,Promise.resolve()),null;let{buildId:w,params:g,nextConfig:b,parsedUrl:S,isDraftMode:T,prerenderManifest:A,routerServerContext:x,isOnDemandRevalidate:v,revalidateOnlyGenerated:N,resolvedPathname:C,clientReferenceManifest:I,serverActionsManifest:O}=y,$=(0,s.normalizeAppPath)(R),U=!!(A.dynamicRoutes[$]||A.routes[C]),D=async()=>((null==x?void 0:x.render404)?await x.render404(e,t,S,!1):t.end("This page could not be found"),null);if(U&&!T){let e=!!A.routes[C],t=A.dynamicRoutes[$];if(t&&!1===t.fallback&&!e){if(b.experimental.adapterPath)return await D();throw new f.NoFallbackError}}let H=null;!U||P.isDev||T||(H="/index"===(H=C)?"/":H);let L=!0===P.isDev||!U,k=U&&!L;O&&I&&(0,u.setManifestsSingleton)({page:R,clientReferenceManifest:I,serverActionsManifest:O});let M=e.method||"GET",q=(0,i.getTracer)(),j=q.getActiveScopeSpan(),F={params:g,prerenderManifest:A,renderOpts:{experimental:{authInterrupts:!!b.experimental.authInterrupts},cacheComponents:!!b.cacheComponents,supportsDynamicResponse:L,incrementalCache:(0,n.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:b.cacheLife,waitUntil:a.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,r,a,n)=>P.onRequestError(e,t,a,n,x)},sharedContext:{buildId:w}},W=new o.NodeNextRequest(e),B=new o.NodeNextResponse(t),G=d.NextRequestAdapter.fromNodeNextRequest(W,(0,d.signalFromNodeResponse)(t));try{let u=async e=>P.handle(G,F).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let r=q.getRootSpanAttributes();if(!r)return;if(r.get("next.span_type")!==l.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${r.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let a=r.get("next.route");if(a){let t=`${M} ${a}`;e.setAttributes({"next.route":a,"http.route":a,"next.span_name":t}),e.updateName(t)}else e.updateName(`${M} ${R}`)}),s=!!(0,n.getRequestMeta)(e,"minimalMode"),o=async n=>{var i,o;let d=async({previousCacheEntry:r})=>{try{if(!s&&v&&N&&!r)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let i=await u(n);e.fetchMetrics=F.renderOpts.fetchMetrics;let o=F.renderOpts.pendingWaitUntil;o&&a.waitUntil&&(a.waitUntil(o),o=void 0);let d=F.renderOpts.collectedTags;if(!U)return await (0,_.sendResponse)(W,B,i,F.renderOpts.pendingWaitUntil),null;{let e=await i.blob(),t=(0,p.toNodeOutgoingHttpHeaders)(i.headers);d&&(t[m.NEXT_CACHE_TAGS_HEADER]=d),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let r=void 0!==F.renderOpts.collectedRevalidate&&!(F.renderOpts.collectedRevalidate>=m.INFINITE_CACHE)&&F.renderOpts.collectedRevalidate,a=void 0===F.renderOpts.collectedExpire||F.renderOpts.collectedExpire>=m.INFINITE_CACHE?void 0:F.renderOpts.collectedExpire;return{value:{kind:h.CachedRouteKind.APP_ROUTE,status:i.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:r,expire:a}}}}catch(t){throw(null==r?void 0:r.isStale)&&await P.onRequestError(e,t,{routerKind:"App Router",routePath:R,routeType:"route",revalidateReason:(0,c.getRevalidateReason)({isStaticGeneration:k,isOnDemandRevalidate:v})},!1,x),t}},l=await P.handleResponse({req:e,nextConfig:b,cacheKey:H,routeKind:r.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:A,isRoutePPREnabled:!1,isOnDemandRevalidate:v,revalidateOnlyGenerated:N,responseGenerator:d,waitUntil:a.waitUntil,isMinimalMode:s});if(!U)return null;if((null==l||null==(i=l.value)?void 0:i.kind)!==h.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==l||null==(o=l.value)?void 0:o.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});s||t.setHeader("x-nextjs-cache",v?"REVALIDATED":l.isMiss?"MISS":l.isStale?"STALE":"HIT"),T&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let f=(0,p.fromNodeOutgoingHttpHeaders)(l.value.headers);return s&&U||f.delete(m.NEXT_CACHE_TAGS_HEADER),!l.cacheControl||t.getHeader("Cache-Control")||f.get("Cache-Control")||f.set("Cache-Control",(0,E.getCacheControlHeader)(l.cacheControl)),await (0,_.sendResponse)(W,B,new Response(l.value.body,{headers:f,status:l.value.status||200})),null};j?await o(j):await q.withPropagatedContext(e.headers,()=>q.trace(l.BaseServerSpan.handleRequest,{spanName:`${M} ${R}`,kind:i.SpanKind.SERVER,attributes:{"http.method":M,"http.target":e.url}},o))}catch(t){if(t instanceof f.NoFallbackError||await P.onRequestError(e,t,{routerKind:"App Router",routePath:$,routeType:"route",revalidateReason:(0,c.getRevalidateReason)({isStaticGeneration:k,isOnDemandRevalidate:v})},!1,x),U)throw t;return await (0,_.sendResponse)(W,B,new Response(null,{status:500})),null}}e.s(["handler",()=>q,"patchFetch",()=>M,"routeModule",()=>P,"serverHooks",()=>k,"workAsyncStorage",()=>H,"workUnitAsyncStorage",()=>L],496508)}];

//# sourceMappingURL=node_modules_next_dist_esm_build_templates_app-route_9a876880.js.map