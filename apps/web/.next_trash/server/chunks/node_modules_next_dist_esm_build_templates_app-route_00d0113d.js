module.exports=[401997,e=>{"use strict";var t=e.i(747909),a=e.i(174017),r=e.i(996250),n=e.i(759756),i=e.i(561916),o=e.i(174677),s=e.i(869741),l=e.i(316795),d=e.i(487718),u=e.i(995169),c=e.i(47587),p=e.i(666012),m=e.i(570101),h=e.i(626937),_=e.i(10372),R=e.i(193695);e.i(52474);var E=e.i(600220),g=e.i(469719),f=e.i(300959),v=e.i(843793),y=e.i(184883);let S=new Map,x=0;function A(e){let t=S.get(e)??0;t<=1?S.delete(e):S.set(e,t-1),x=Math.max(0,x-1)}let w=g.z.object({market_id:g.z.string().uuid(),topics:g.z.string().optional().default("top,depth,trades").transform(e=>e.split(",").map(e=>e.trim()).filter(Boolean)),levels:g.z.coerce.number().int().min(1).max(50).optional().default(10),trades_limit:g.z.coerce.number().int().min(1).max(200).optional().default(25),trades_delta:g.z.union([g.z.literal("0"),g.z.literal("1")]).optional().default("1").transform(e=>"1"===e),poll_ms:g.z.coerce.number().int().min(250).max(5e3).optional().default(1e3),heartbeat_ms:g.z.coerce.number().int().min(5e3).max(6e4).optional().default(15e3)});function C(e,t){return`event: ${e}
data: ${JSON.stringify(t)}

`}function O(e){return`: ${e}

`}function k(e){return`retry: ${e}

`}async function D(e){let t,a=(0,v.getSql)(),r=new URL(e.url);try{t=w.parse({market_id:r.searchParams.get("market_id"),topics:r.searchParams.get("topics")??void 0,levels:r.searchParams.get("levels")??void 0,trades_limit:r.searchParams.get("trades_limit")??void 0,trades_delta:r.searchParams.get("trades_delta")??void 0,poll_ms:r.searchParams.get("poll_ms")??void 0,heartbeat_ms:r.searchParams.get("heartbeat_ms")??void 0})}catch(e){return(0,f.apiZodError)(e)??(0,f.apiError)("invalid_input")}let n=new Set(t.topics),i=e.headers.get("x-real-ip")??e.headers.get("x-forwarded-for")?.split(",")[0]?.trim()??"unknown";if(!function(e){if(x>=500)return!1;let t=S.get(e)??0;return!(t>=10)&&(S.set(e,t+1),x++,!0)}(i))return Response.json({error:"rate_limit_exceeded",message:"Too many concurrent SSE connections"},{status:429,headers:{"Retry-After":"5"}});let o=null;try{o=(await (0,y.retryOnceOnTransientDbError)(async()=>({market:(await a`
        SELECT id, chain, symbol, status
        FROM ex_market
        WHERE id = ${t.market_id}::uuid
        LIMIT 1
      `)[0]??null}))).market}catch(e){return A(i),(0,y.responseForDbError)("exchange.marketdata.stream.connect",e)??(0,f.apiError)("upstream_unavailable")}if(!o)return A(i),(0,f.apiError)("market_not_found");let s=new TextEncoder,l="",d="",u="",c=null,p=new ReadableStream({start(r){let p=!1,m=null,h=null,_=null,R=null,E=e=>{p||r.enqueue(s.encode(e))},g=()=>{if(!p){p=!0,A(i),m&&clearInterval(m),h&&clearInterval(h);try{r.close()}catch{}}};c=g;let f=async()=>{try{await (0,y.retryOnceOnTransientDbError)(async()=>{if(n.has("top")){let e=await a`
                SELECT
                  price::text AS price,
                  sum(remaining_quantity)::text AS quantity,
                  count(*)::int AS order_count
                FROM ex_order
                WHERE market_id = ${t.market_id}::uuid
                  AND side = 'buy'
                  AND status IN ('open','partially_filled')
                  AND remaining_quantity > 0
                GROUP BY price
                ORDER BY price DESC
                LIMIT 1
              `,r=await a`
                SELECT
                  price::text AS price,
                  sum(remaining_quantity)::text AS quantity,
                  count(*)::int AS order_count
                FROM ex_order
                WHERE market_id = ${t.market_id}::uuid
                  AND side = 'sell'
                  AND status IN ('open','partially_filled')
                  AND remaining_quantity > 0
                GROUP BY price
                ORDER BY price ASC
                LIMIT 1
              `,n=e[0]??null,i=r[0]??null,o=`${n?.price??""}|${n?.quantity??""}|${i?.price??""}|${i?.quantity??""}`;o!==l&&(l=o,E(C("top",{top:{bid:n,ask:i},ts:new Date().toISOString()})))}if(n.has("depth")){let e=await a`
                SELECT
                  price::text AS price,
                  sum(remaining_quantity)::text AS quantity,
                  count(*)::int AS order_count
                FROM ex_order
                WHERE market_id = ${t.market_id}::uuid
                  AND side = 'buy'
                  AND status IN ('open','partially_filled')
                  AND remaining_quantity > 0
                GROUP BY price
                ORDER BY price DESC
                LIMIT ${t.levels}
              `,r=await a`
                SELECT
                  price::text AS price,
                  sum(remaining_quantity)::text AS quantity,
                  count(*)::int AS order_count
                FROM ex_order
                WHERE market_id = ${t.market_id}::uuid
                  AND side = 'sell'
                  AND status IN ('open','partially_filled')
                  AND remaining_quantity > 0
                GROUP BY price
                ORDER BY price ASC
                LIMIT ${t.levels}
              `,n=`${e.map(e=>`${e.price}:${e.quantity}`).join(",")}|${r.map(e=>`${e.price}:${e.quantity}`).join(",")}`;n!==d&&(d=n,E(C("depth",{depth:{bids:e,asks:r},levels:t.levels,ts:new Date().toISOString()})))}if(n.has("trades")){if(!_||!R||!t.trades_delta){let e=await a`
                  SELECT
                    id,
                    price::text AS price,
                    quantity::text AS quantity,
                    maker_order_id,
                    taker_order_id,
                    created_at
                  FROM ex_execution
                  WHERE market_id = ${t.market_id}::uuid
                  ORDER BY created_at DESC, id DESC
                  LIMIT ${t.trades_limit}
                `,r=e[0]??null;r&&(_=r.created_at,R=r.id);let n=e.map(e=>e.id).join(",");n!==u&&(u=n,E(C("trades",{trades:e,mode:"snapshot",ts:new Date().toISOString()})));return}let e=await a`
                SELECT
                  id,
                  price::text AS price,
                  quantity::text AS quantity,
                  maker_order_id,
                  taker_order_id,
                  created_at
                FROM ex_execution
                WHERE market_id = ${t.market_id}::uuid
                  AND (created_at, id) > (${_}::timestamptz, ${R}::uuid)
                ORDER BY created_at ASC, id ASC
                LIMIT 200
              `;if(e.length>0){let t=e[e.length-1];_=t.created_at,R=t.id;let a=[...e].reverse();E(C("trades",{trades:a,mode:"delta",ts:new Date().toISOString()}))}}})}catch(e){if((0,y.isTransientDbError)(e)){E(k(3e3)),E(O(`db_unavailable ${e?.message??String(e)}`)),g();return}E(O(`poll_error ${e?.message??String(e)}`))}};m=setInterval(()=>{f()},t.poll_ms),h=setInterval(()=>{E(O(`ping ${Date.now()}`))},t.heartbeat_ms),e.signal.addEventListener("abort",()=>g()),E(k(2e3)),E(O("connected")),E(C("market",{market:o,ts:new Date().toISOString()})),f()},cancel(){c?.()}});return new Response(p,{headers:{"Content-Type":"text/event-stream; charset=utf-8","Cache-Control":"no-cache, no-transform",Connection:"keep-alive","X-Accel-Buffering":"no"}})}e.s(["GET",()=>D,"dynamic",0,"force-dynamic","runtime",0,"nodejs"],613846);var T=e.i(613846);let b=new t.AppRouteRouteModule({definition:{kind:a.RouteKind.APP_ROUTE,page:"/api/exchange/marketdata/stream/route",pathname:"/api/exchange/marketdata/stream",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/src/app/api/exchange/marketdata/stream/route.ts",nextConfigOutput:"",userland:T}),{workAsyncStorage:I,workUnitAsyncStorage:N,serverHooks:$}=b;function q(){return(0,r.patchFetch)({workAsyncStorage:I,workUnitAsyncStorage:N})}async function P(e,t,r){b.isDev&&(0,n.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let g="/api/exchange/marketdata/stream/route";g=g.replace(/\/index$/,"")||"/";let f=await b.prepare(e,t,{srcPage:g,multiZoneDraftMode:!1});if(!f)return t.statusCode=400,t.end("Bad Request"),null==r.waitUntil||r.waitUntil.call(r,Promise.resolve()),null;let{buildId:v,params:y,nextConfig:S,parsedUrl:x,isDraftMode:A,prerenderManifest:w,routerServerContext:C,isOnDemandRevalidate:O,revalidateOnlyGenerated:k,resolvedPathname:D,clientReferenceManifest:T,serverActionsManifest:I}=f,N=(0,s.normalizeAppPath)(g),$=!!(w.dynamicRoutes[N]||w.routes[D]),q=async()=>((null==C?void 0:C.render404)?await C.render404(e,t,x,!1):t.end("This page could not be found"),null);if($&&!A){let e=!!w.routes[D],t=w.dynamicRoutes[N];if(t&&!1===t.fallback&&!e){if(S.experimental.adapterPath)return await q();throw new R.NoFallbackError}}let P=null;!$||b.isDev||A||(P="/index"===(P=D)?"/":P);let M=!0===b.isDev||!$,H=$&&!M;I&&T&&(0,o.setManifestsSingleton)({page:g,clientReferenceManifest:T,serverActionsManifest:I});let L=e.method||"GET",U=(0,i.getTracer)(),B=U.getActiveScopeSpan(),F={params:y,prerenderManifest:w,renderOpts:{experimental:{authInterrupts:!!S.experimental.authInterrupts},cacheComponents:!!S.cacheComponents,supportsDynamicResponse:M,incrementalCache:(0,n.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:S.cacheLife,waitUntil:r.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,a,r,n)=>b.onRequestError(e,t,r,n,C)},sharedContext:{buildId:v}},j=new l.NodeNextRequest(e),z=new l.NodeNextResponse(t),Y=d.NextRequestAdapter.fromNodeNextRequest(j,(0,d.signalFromNodeResponse)(t));try{let o=async e=>b.handle(Y,F).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let a=U.getRootSpanAttributes();if(!a)return;if(a.get("next.span_type")!==u.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${a.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let r=a.get("next.route");if(r){let t=`${L} ${r}`;e.setAttributes({"next.route":r,"http.route":r,"next.span_name":t}),e.updateName(t)}else e.updateName(`${L} ${g}`)}),s=!!(0,n.getRequestMeta)(e,"minimalMode"),l=async n=>{var i,l;let d=async({previousCacheEntry:a})=>{try{if(!s&&O&&k&&!a)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let i=await o(n);e.fetchMetrics=F.renderOpts.fetchMetrics;let l=F.renderOpts.pendingWaitUntil;l&&r.waitUntil&&(r.waitUntil(l),l=void 0);let d=F.renderOpts.collectedTags;if(!$)return await (0,p.sendResponse)(j,z,i,F.renderOpts.pendingWaitUntil),null;{let e=await i.blob(),t=(0,m.toNodeOutgoingHttpHeaders)(i.headers);d&&(t[_.NEXT_CACHE_TAGS_HEADER]=d),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let a=void 0!==F.renderOpts.collectedRevalidate&&!(F.renderOpts.collectedRevalidate>=_.INFINITE_CACHE)&&F.renderOpts.collectedRevalidate,r=void 0===F.renderOpts.collectedExpire||F.renderOpts.collectedExpire>=_.INFINITE_CACHE?void 0:F.renderOpts.collectedExpire;return{value:{kind:E.CachedRouteKind.APP_ROUTE,status:i.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:a,expire:r}}}}catch(t){throw(null==a?void 0:a.isStale)&&await b.onRequestError(e,t,{routerKind:"App Router",routePath:g,routeType:"route",revalidateReason:(0,c.getRevalidateReason)({isStaticGeneration:H,isOnDemandRevalidate:O})},!1,C),t}},u=await b.handleResponse({req:e,nextConfig:S,cacheKey:P,routeKind:a.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:w,isRoutePPREnabled:!1,isOnDemandRevalidate:O,revalidateOnlyGenerated:k,responseGenerator:d,waitUntil:r.waitUntil,isMinimalMode:s});if(!$)return null;if((null==u||null==(i=u.value)?void 0:i.kind)!==E.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==u||null==(l=u.value)?void 0:l.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});s||t.setHeader("x-nextjs-cache",O?"REVALIDATED":u.isMiss?"MISS":u.isStale?"STALE":"HIT"),A&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let R=(0,m.fromNodeOutgoingHttpHeaders)(u.value.headers);return s&&$||R.delete(_.NEXT_CACHE_TAGS_HEADER),!u.cacheControl||t.getHeader("Cache-Control")||R.get("Cache-Control")||R.set("Cache-Control",(0,h.getCacheControlHeader)(u.cacheControl)),await (0,p.sendResponse)(j,z,new Response(u.value.body,{headers:R,status:u.value.status||200})),null};B?await l(B):await U.withPropagatedContext(e.headers,()=>U.trace(u.BaseServerSpan.handleRequest,{spanName:`${L} ${g}`,kind:i.SpanKind.SERVER,attributes:{"http.method":L,"http.target":e.url}},l))}catch(t){if(t instanceof R.NoFallbackError||await b.onRequestError(e,t,{routerKind:"App Router",routePath:N,routeType:"route",revalidateReason:(0,c.getRevalidateReason)({isStaticGeneration:H,isOnDemandRevalidate:O})},!1,C),$)throw t;return await (0,p.sendResponse)(j,z,new Response(null,{status:500})),null}}e.s(["handler",()=>P,"patchFetch",()=>q,"routeModule",()=>b,"serverHooks",()=>$,"workAsyncStorage",()=>I,"workUnitAsyncStorage",()=>N],401997)}];

//# sourceMappingURL=node_modules_next_dist_esm_build_templates_app-route_00d0113d.js.map