{"version":3,"sources":["../../../src/lib/blockchain/depositIngest.ts"],"sourcesContent":["import { ethers } from \"ethers\";\r\nimport type { Sql } from \"postgres\";\r\n\r\nimport { getBscReadProvider } from \"@/lib/blockchain/wallet\";\r\nimport { createNotification } from \"@/lib/notifications\";\r\n\r\nconst SYSTEM_USER_ID = \"00000000-0000-0000-0000-000000000001\";\r\n\r\nlet _depositEventCols:\r\n  | null\r\n  | {\r\n      hasStatus: boolean;\r\n      hasCreditedAt: boolean;\r\n      hasConfirmedAt: boolean;\r\n    } = null;\r\n\r\nasync function getDepositEventCols(sql: Sql): Promise<{\r\n  hasStatus: boolean;\r\n  hasCreditedAt: boolean;\r\n  hasConfirmedAt: boolean;\r\n}> {\r\n  if (_depositEventCols) return _depositEventCols;\r\n\r\n  const rows = await sql<\r\n    {\r\n      has_status: boolean;\r\n      has_credited_at: boolean;\r\n      has_confirmed_at: boolean;\r\n    }[]\r\n  >`\r\n    SELECT\r\n      EXISTS (\r\n        SELECT 1\r\n        FROM information_schema.columns\r\n        WHERE table_schema = 'public'\r\n          AND table_name = 'ex_chain_deposit_event'\r\n          AND column_name = 'status'\r\n      ) AS has_status,\r\n      EXISTS (\r\n        SELECT 1\r\n        FROM information_schema.columns\r\n        WHERE table_schema = 'public'\r\n          AND table_name = 'ex_chain_deposit_event'\r\n          AND column_name = 'credited_at'\r\n      ) AS has_credited_at,\r\n      EXISTS (\r\n        SELECT 1\r\n        FROM information_schema.columns\r\n        WHERE table_schema = 'public'\r\n          AND table_name = 'ex_chain_deposit_event'\r\n          AND column_name = 'confirmed_at'\r\n      ) AS has_confirmed_at\r\n  `;\r\n\r\n  const row = rows[0];\r\n  _depositEventCols = {\r\n    hasStatus: Boolean(row?.has_status),\r\n    hasCreditedAt: Boolean(row?.has_credited_at),\r\n    hasConfirmedAt: Boolean(row?.has_confirmed_at),\r\n  };\r\n  return _depositEventCols;\r\n}\r\n\r\nfunction envInt(name: string, fallback: number): number {\r\n  const raw = (process.env[name] ?? \"\").trim();\r\n  const n = Number(raw);\r\n  return Number.isFinite(n) ? Math.trunc(n) : fallback;\r\n}\r\n\r\nfunction clamp(n: number, min: number, max: number): number {\r\n  return Math.max(min, Math.min(max, n));\r\n}\r\n\r\nfunction chunk<T>(items: T[], size: number): T[][] {\r\n  const s = Math.max(1, Math.floor(size));\r\n  const out: T[][] = [];\r\n  for (let i = 0; i < items.length; i += s) out.push(items.slice(i, i + s));\r\n  return out;\r\n}\r\n\r\nfunction sleep(ms: number): Promise<void> {\r\n  return new Promise((resolve) => setTimeout(resolve, Math.max(0, Math.floor(ms))));\r\n}\r\n\r\nfunction isRateLimitError(err: unknown): boolean {\r\n  const msg = err instanceof Error ? err.message : String(err);\r\n  const lower = msg.toLowerCase();\r\n  return (\r\n    lower.includes(\"rate limit\") ||\r\n    lower.includes(\"triggered rate limit\") ||\r\n    lower.includes(\"-32005\")\r\n  );\r\n}\r\n\r\nfunction isUnsupportedArrayParamError(err: unknown): boolean {\r\n  const msg = err instanceof Error ? err.message : String(err);\r\n  const lower = msg.toLowerCase();\r\n  return (\r\n    lower.includes(\"invalid params\") &&\r\n    (lower.includes(\"variadic\") || lower.includes(\"array type\") || lower.includes(\"invalid variadic\"))\r\n  );\r\n}\r\n\r\nfunction isUnsupportedTopicsShapeError(err: unknown): boolean {\r\n  // Some RPC providers reject `topics` arrays that include `null` placeholders\r\n  // or mixed (string|null|array) entries, despite being valid per JSON-RPC.\r\n  // We treat these similarly and fall back to `topics: [topic0]`.\r\n  return isUnsupportedArrayParamError(err);\r\n}\r\n\r\nfunction isBlockRangeTooLargeError(err: unknown): boolean {\r\n  const msg = err instanceof Error ? err.message : String(err);\r\n  const lower = msg.toLowerCase();\r\n  return (\r\n    lower.includes(\"block range is too large\") ||\r\n    lower.includes(\"range is too large\") ||\r\n    lower.includes(\"block range too large\") ||\r\n    lower.includes(\"fromblock\") && lower.includes(\"toblock\") && lower.includes(\"too large\")\r\n  );\r\n}\r\n\r\nasync function getLogsRangeSafe(\r\n  provider: ethers.AbstractProvider,\r\n  filter: Omit<ethers.Filter, \"fromBlock\" | \"toBlock\"> & { fromBlock: number; toBlock: number },\r\n  opts?: { maxDepth?: number },\r\n): Promise<ethers.Log[]> {\r\n  const maxDepth = clamp(opts?.maxDepth ?? 12, 4, 24);\r\n\r\n  const walk = async (fromBlock: number, toBlock: number, depth: number): Promise<ethers.Log[]> => {\r\n    try {\r\n      return await getLogsWithRetry(provider, { ...filter, fromBlock, toBlock }, { maxAttempts: 6, baseDelayMs: 800 });\r\n    } catch (e) {\r\n      if (!isBlockRangeTooLargeError(e) || fromBlock >= toBlock || depth >= maxDepth) throw e;\r\n      const mid = Math.floor((fromBlock + toBlock) / 2);\r\n      // Split sequentially to avoid fanning out too many concurrent RPC calls\r\n      // (which can cause rate limiting or edge timeouts in serverless contexts).\r\n      const a = await walk(fromBlock, mid, depth + 1);\r\n      const b = await walk(mid + 1, toBlock, depth + 1);\r\n      return a.concat(b);\r\n    }\r\n  };\r\n\r\n  return await walk(filter.fromBlock, filter.toBlock, 0);\r\n}\r\n\r\nfunction coerceTopicsForCompatibility(topics: (string | string[] | null)[]): (string | string[] | null)[] {\r\n  // Some RPC providers are picky about “OR” arrays with a single element.\r\n  // Coerce [\"0x...\"] -> \"0x...\".\r\n  return topics.map((t) => {\r\n    if (Array.isArray(t) && t.length === 1) return t[0] ?? null;\r\n    return t;\r\n  });\r\n}\r\n\r\nasync function getLogsWithRetry(\r\n  provider: ethers.AbstractProvider,\r\n  args: ethers.Filter,\r\n  opts?: { maxAttempts?: number; baseDelayMs?: number },\r\n): Promise<ethers.Log[]> {\r\n  const maxAttempts = clamp(opts?.maxAttempts ?? 4, 1, 8);\r\n  const baseDelayMs = clamp(opts?.baseDelayMs ?? 500, 50, 10_000);\r\n\r\n  let lastErr: unknown;\r\n  for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {\r\n    try {\r\n      return await provider.getLogs(args);\r\n    } catch (e) {\r\n      lastErr = e;\r\n      if (!isRateLimitError(e) || attempt === maxAttempts) throw e;\r\n      // Exponential backoff with small jitter.\r\n      const jitter = Math.floor(Math.random() * 150);\r\n      const delay = baseDelayMs * attempt * attempt + jitter;\r\n      await sleep(delay);\r\n    }\r\n  }\r\n\r\n  throw lastErr instanceof Error ? lastErr : new Error(String(lastErr));\r\n}\r\n\r\nasync function getLogsBatchedOrSplit(\r\n  provider: ethers.AbstractProvider,\r\n  args: {\r\n    addresses: string[];\r\n    fromBlock: number;\r\n    toBlock: number;\r\n    topics: (string | string[] | null)[];\r\n  },\r\n): Promise<ethers.Log[]> {\r\n  const throttleMs = clamp(envInt(\"BSC_DEPOSIT_LOG_THROTTLE_MS\", 0), 0, 10_000);\r\n  const topics = coerceTopicsForCompatibility(args.topics);\r\n  const topic0 = typeof topics[0] === \"string\" ? (topics[0] as string) : null;\r\n\r\n  const filterBase = {\r\n    fromBlock: args.fromBlock,\r\n    toBlock: args.toBlock,\r\n    topics,\r\n  } as const;\r\n\r\n  // Fast path: try a single batched query (address array) if supported.\r\n  try {\r\n    const logs = await getLogsRangeSafe(provider, {\r\n      ...filterBase,\r\n      address: args.addresses,\r\n    } as any);\r\n    if (throttleMs) await sleep(throttleMs);\r\n    return logs;\r\n  } catch (e) {\r\n    // Some providers (notably Ankr) reject address arrays for eth_getLogs.\r\n    // In that case, fall back to single-contract calls.\r\n    if (!isRateLimitError(e) && !isUnsupportedArrayParamError(e)) {\r\n      // Another common incompatibility: reject complex topics shapes.\r\n      if (topic0 && isUnsupportedTopicsShapeError(e)) {\r\n        try {\r\n          const logs = await getLogsRangeSafe(provider, {\r\n            fromBlock: args.fromBlock,\r\n            toBlock: args.toBlock,\r\n            address: args.addresses,\r\n            topics: [topic0],\r\n          } as any);\r\n          if (throttleMs) await sleep(throttleMs);\r\n          return logs;\r\n        } catch (e2) {\r\n          if (!isRateLimitError(e2) && !isUnsupportedArrayParamError(e2)) throw e2;\r\n          // Continue to split fallback.\r\n        }\r\n      } else {\r\n        throw e;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Slow path: split per contract. Many public RPCs rate-limit batched/array address calls.\r\n  const out: ethers.Log[] = [];\r\n  for (const addr of args.addresses) {\r\n    if (!addr) continue;\r\n    let logs: ethers.Log[];\r\n    try {\r\n      logs = await getLogsRangeSafe(provider, {\r\n        ...filterBase,\r\n        address: addr,\r\n      } as any);\r\n    } catch (e) {\r\n      if (!topic0 || !isUnsupportedTopicsShapeError(e)) throw e;\r\n      // Retry with only the event signature topic.\r\n      logs = await getLogsRangeSafe(provider, {\r\n        fromBlock: args.fromBlock,\r\n        toBlock: args.toBlock,\r\n        address: addr,\r\n        topics: [topic0],\r\n      } as any);\r\n    }\r\n    out.push(...logs);\r\n    if (throttleMs) await sleep(throttleMs);\r\n  }\r\n  return out;\r\n}\r\n\r\nfunction normalizeAddress(addr: string): string {\r\n  return String(addr || \"\").trim().toLowerCase();\r\n}\r\n\r\nfunction decodeTopicAddress(topic: string): string {\r\n  // topic = 0x + 64 hex chars; address is last 40 chars.\r\n  const t = String(topic || \"\");\r\n  if (!t.startsWith(\"0x\") || t.length !== 66) return \"\";\r\n  return \"0x\" + t.slice(-40).toLowerCase();\r\n}\r\n\r\nfunction encodeTopicAddress(addr: string): string {\r\n  const a = normalizeAddress(addr);\r\n  if (!a.startsWith(\"0x\") || a.length !== 42) return \"0x\" + \"0\".repeat(64);\r\n  // 32-byte topic, right-aligned address (last 20 bytes)\r\n  return \"0x\" + \"0\".repeat(24 * 2) + a.slice(2);\r\n}\r\n\r\ntype DepositAsset = {\r\n  id: string;\r\n  symbol: string;\r\n  decimals: number;\r\n  contract_address: string;\r\n};\r\n\r\ntype NativeAsset = {\r\n  id: string;\r\n  symbol: string;\r\n  decimals: number;\r\n};\r\n\r\nfunction parseSymbolAllowlist(raw: string, fallback: string[]): string[] {\r\n  const out = String(raw || \"\")\r\n    .split(\",\")\r\n    .map((s) => s.trim().toUpperCase())\r\n    .filter(Boolean);\r\n  return out.length ? out : fallback;\r\n}\r\n\r\nexport async function ingestNativeBnbDepositTx(\r\n  sql: Sql,\r\n  args: {\r\n    chain?: \"bsc\";\r\n    txHash: string;\r\n    confirmations?: number;\r\n  },\r\n): Promise<\r\n  | {\r\n      ok: true;\r\n      chain: \"bsc\";\r\n      txHash: string;\r\n      blockNumber: number;\r\n      confirmations: number;\r\n      safeTip: number;\r\n      toAddress: string;\r\n      userId: string;\r\n      assetSymbol: \"BNB\";\r\n      amount: string;\r\n      outcome: \"credited\" | \"duplicate\";\r\n    }\r\n  | {\r\n      ok: false;\r\n      error:\r\n        | \"tx_not_found\"\r\n        | \"tx_not_confirmed\"\r\n        | \"tx_failed\"\r\n        | \"not_a_native_transfer\"\r\n        | \"unknown_deposit_address\"\r\n        | \"bnb_asset_missing\";\r\n      txHash: string;\r\n      details?: any;\r\n    }\r\n> {\r\n  const provider = getBscReadProvider();\r\n  const chain: \"bsc\" = args.chain ?? \"bsc\";\r\n\r\n  const confirmations = clamp(args.confirmations ?? envInt(\"BSC_DEPOSIT_CONFIRMATIONS\", 2), 0, 200);\r\n  const tip = await provider.getBlockNumber();\r\n  const safeTip = Math.max(0, tip - confirmations);\r\n\r\n  const txHash = String(args.txHash || \"\").trim();\r\n  if (!txHash.startsWith(\"0x\") || txHash.length < 10) {\r\n    return { ok: false, error: \"tx_not_found\", txHash };\r\n  }\r\n\r\n  const receipt = await provider.getTransactionReceipt(txHash);\r\n  if (!receipt) return { ok: false, error: \"tx_not_found\", txHash };\r\n  const blockNumber = Number(receipt.blockNumber);\r\n  if (!Number.isFinite(blockNumber) || blockNumber <= 0) {\r\n    return { ok: false, error: \"tx_not_found\", txHash, details: { blockNumber: receipt.blockNumber } };\r\n  }\r\n\r\n  if (blockNumber > safeTip) {\r\n    return {\r\n      ok: false,\r\n      error: \"tx_not_confirmed\",\r\n      txHash,\r\n      details: { blockNumber, tip, safeTip, confirmations },\r\n    };\r\n  }\r\n\r\n  if (typeof receipt.status === \"number\" && receipt.status !== 1) {\r\n    return { ok: false, error: \"tx_failed\", txHash, details: { status: receipt.status } };\r\n  }\r\n\r\n  const tx = await provider.getTransaction(txHash);\r\n  if (!tx) return { ok: false, error: \"tx_not_found\", txHash };\r\n\r\n  const toAddress = tx.to ? normalizeAddress(tx.to) : \"\";\r\n  const value = tx.value ?? 0n;\r\n  if (!toAddress || typeof value !== \"bigint\" || value <= 0n) {\r\n    return {\r\n      ok: false,\r\n      error: \"not_a_native_transfer\",\r\n      txHash,\r\n      details: { to: tx.to, value: String(value) },\r\n    };\r\n  }\r\n\r\n  const rows = await sql<{ user_id: string }[]>`\r\n    SELECT user_id::text AS user_id\r\n    FROM ex_deposit_address\r\n    WHERE chain = ${chain} AND status = 'active' AND lower(address) = ${toAddress}\r\n    LIMIT 1\r\n  `;\r\n  const userId = rows[0]?.user_id ? String(rows[0].user_id) : \"\";\r\n  if (!userId) {\r\n    return { ok: false, error: \"unknown_deposit_address\", txHash, details: { toAddress } };\r\n  }\r\n\r\n  const nativeRows = await sql<NativeAsset[]>`\r\n    SELECT id::text AS id, symbol, decimals\r\n    FROM ex_asset\r\n    WHERE chain = ${chain}\r\n      AND is_enabled = true\r\n      AND contract_address IS NULL\r\n      AND upper(symbol) = 'BNB'\r\n    LIMIT 1\r\n  `;\r\n  const nativeBnb = nativeRows[0] ?? null;\r\n  if (!nativeBnb) return { ok: false, error: \"bnb_asset_missing\", txHash };\r\n\r\n  const amount = ethers.formatUnits(value, nativeBnb.decimals);\r\n  const cols = await getDepositEventCols(sql);\r\n  const outcome = await creditDepositEvent(sql as any, {\r\n    chain,\r\n    txHash,\r\n    logIndex: -1,\r\n    blockNumber,\r\n    fromAddress: tx.from ? normalizeAddress(tx.from) : null,\r\n    toAddress,\r\n    userId,\r\n    assetId: nativeBnb.id,\r\n    assetSymbol: nativeBnb.symbol,\r\n    amount,\r\n    cols,\r\n  });\r\n\r\n  return {\r\n    ok: true,\r\n    chain,\r\n    txHash,\r\n    blockNumber,\r\n    confirmations,\r\n    safeTip,\r\n    toAddress,\r\n    userId,\r\n    assetSymbol: \"BNB\",\r\n    amount,\r\n    outcome,\r\n  };\r\n}\r\n\r\nexport async function ingestBscTokenDepositTx(\r\n  sql: Sql,\r\n  args: {\r\n    txHash: string;\r\n    userId: string;\r\n    depositAddress: string;\r\n    confirmations?: number;\r\n    tokenSymbols?: string[];\r\n  },\r\n): Promise<\r\n  | {\r\n      ok: true;\r\n      chain: \"bsc\";\r\n      txHash: string;\r\n      blockNumber: number;\r\n      confirmations: number;\r\n      safeTip: number;\r\n      depositAddress: string;\r\n      matches: number;\r\n      credits: Array<{\r\n        assetSymbol: string;\r\n        amount: string;\r\n        logIndex: number;\r\n        outcome: \"credited\" | \"duplicate\";\r\n      }>;\r\n    }\r\n  | {\r\n      ok: false;\r\n      error:\r\n        | \"tx_not_found\"\r\n        | \"tx_not_confirmed\"\r\n        | \"tx_failed\"\r\n        | \"no_matching_token_transfers\"\r\n        | \"token_asset_not_enabled\";\r\n      txHash: string;\r\n      details?: any;\r\n    }\r\n> {\r\n  const provider = getBscReadProvider();\r\n  const chain: \"bsc\" = \"bsc\";\r\n\r\n  const confirmations = clamp(args.confirmations ?? envInt(\"BSC_DEPOSIT_CONFIRMATIONS\", 2), 0, 200);\r\n  const tip = await provider.getBlockNumber();\r\n  const safeTip = Math.max(0, tip - confirmations);\r\n\r\n  const txHash = String(args.txHash || \"\").trim();\r\n  if (!txHash.startsWith(\"0x\") || txHash.length < 10) {\r\n    return { ok: false, error: \"tx_not_found\", txHash };\r\n  }\r\n\r\n  const receipt = await provider.getTransactionReceipt(txHash);\r\n  if (!receipt) return { ok: false, error: \"tx_not_found\", txHash };\r\n\r\n  const blockNumber = Number(receipt.blockNumber);\r\n  if (!Number.isFinite(blockNumber) || blockNumber <= 0) {\r\n    return { ok: false, error: \"tx_not_found\", txHash, details: { blockNumber: receipt.blockNumber } };\r\n  }\r\n\r\n  if (blockNumber > safeTip) {\r\n    return {\r\n      ok: false,\r\n      error: \"tx_not_confirmed\",\r\n      txHash,\r\n      details: { blockNumber, tip, safeTip, confirmations },\r\n    };\r\n  }\r\n\r\n  if (typeof receipt.status === \"number\" && receipt.status !== 1) {\r\n    return { ok: false, error: \"tx_failed\", txHash, details: { status: receipt.status } };\r\n  }\r\n\r\n  const depositAddress = normalizeAddress(args.depositAddress);\r\n  if (!depositAddress || !depositAddress.startsWith(\"0x\") || depositAddress.length !== 42) {\r\n    return { ok: false, error: \"no_matching_token_transfers\", txHash, details: { depositAddress } };\r\n  }\r\n\r\n  const allowSymbols = (args.tokenSymbols ?? []).map((s) => String(s || \"\").trim().toUpperCase()).filter(Boolean);\r\n  const symbols = allowSymbols.length\r\n    ? allowSymbols\r\n    : parseSymbolAllowlist(process.env.BSC_REPORT_TOKEN_SYMBOLS ?? \"\", [\"USDT\", \"USDC\"]);\r\n\r\n  const assets = await sql<DepositAsset[]>`\r\n    SELECT id::text AS id, symbol, decimals, contract_address\r\n    FROM ex_asset\r\n    WHERE chain = ${chain}\r\n      AND is_enabled = true\r\n      AND contract_address IS NOT NULL\r\n      AND upper(symbol) = ANY(${symbols})\r\n    ORDER BY symbol ASC\r\n  `;\r\n\r\n  if (assets.length === 0) {\r\n    return { ok: false, error: \"token_asset_not_enabled\", txHash, details: { symbols } };\r\n  }\r\n\r\n  const contractToAsset = new Map<string, DepositAsset>();\r\n  for (const a of assets) {\r\n    const c = normalizeAddress(a.contract_address);\r\n    if (c) contractToAsset.set(c, a);\r\n  }\r\n\r\n  const cols = await getDepositEventCols(sql);\r\n  const transferTopic = ethers.id(\"Transfer(address,address,uint256)\");\r\n\r\n  const credits: Array<{ assetSymbol: string; amount: string; logIndex: number; outcome: \"credited\" | \"duplicate\" }> = [];\r\n  let matches = 0;\r\n\r\n  const logs = Array.isArray((receipt as any).logs) ? ((receipt as any).logs as Array<any>) : [];\r\n  for (const log of logs) {\r\n    const topics: string[] = Array.isArray(log?.topics) ? log.topics : [];\r\n    if (!topics?.length) continue;\r\n    if (String(topics[0]).toLowerCase() !== transferTopic.toLowerCase()) continue;\r\n\r\n    const to = decodeTopicAddress(topics?.[2] ?? \"\");\r\n    if (!to || to !== depositAddress) continue;\r\n\r\n    const contract = normalizeAddress(String(log?.address ?? \"\"));\r\n    const asset = contractToAsset.get(contract);\r\n    if (!asset) continue;\r\n\r\n    const from = decodeTopicAddress(topics?.[1] ?? \"\") || null;\r\n    let amountRaw: bigint;\r\n    try {\r\n      amountRaw = BigInt(String(log?.data ?? \"0x0\"));\r\n    } catch {\r\n      continue;\r\n    }\r\n    if (amountRaw <= 0n) continue;\r\n\r\n    const amount = ethers.formatUnits(amountRaw, asset.decimals);\r\n    const logIndex = Number((log as any)?.index ?? (log as any)?.logIndex ?? (log as any)?.log_index ?? 0);\r\n\r\n    matches += 1;\r\n    const outcome = await creditDepositEvent(sql as any, {\r\n      chain,\r\n      txHash,\r\n      logIndex,\r\n      blockNumber,\r\n      fromAddress: from,\r\n      toAddress: to,\r\n      userId: args.userId,\r\n      assetId: asset.id,\r\n      assetSymbol: asset.symbol,\r\n      amount,\r\n      cols,\r\n    });\r\n\r\n    credits.push({ assetSymbol: asset.symbol, amount, logIndex, outcome });\r\n  }\r\n\r\n  if (matches === 0) {\r\n    return {\r\n      ok: false,\r\n      error: \"no_matching_token_transfers\",\r\n      txHash,\r\n      details: { depositAddress, symbols },\r\n    };\r\n  }\r\n\r\n  return {\r\n    ok: true,\r\n    chain,\r\n    txHash,\r\n    blockNumber,\r\n    confirmations,\r\n    safeTip,\r\n    depositAddress,\r\n    matches,\r\n    credits,\r\n  };\r\n}\r\n\r\nasync function ensureSystemUser(sql: Sql): Promise<void> {\r\n  await sql`\r\n    INSERT INTO app_user (id, status, kyc_level, country)\r\n    VALUES (${SYSTEM_USER_ID}::uuid, 'active', 'full', 'ZZ')\r\n    ON CONFLICT (id) DO NOTHING\r\n  `;\r\n}\r\n\r\nasync function creditDepositEvent(\r\n  sql: Sql,\r\n  args: {\r\n    chain: \"bsc\";\r\n    txHash: string;\r\n    logIndex: number;\r\n    blockNumber: number;\r\n    fromAddress: string | null;\r\n    toAddress: string;\r\n    userId: string;\r\n    assetId: string;\r\n    assetSymbol: string;\r\n    amount: string;\r\n    cols?: { hasStatus: boolean; hasCreditedAt: boolean; hasConfirmedAt: boolean };\r\n  },\r\n): Promise<\"credited\" | \"duplicate\"> {\r\n  // Idempotency is provided by ex_chain_deposit_event_uniq (chain, tx_hash, log_index).\r\n  // However, we also support a two-stage flow:\r\n  // - Stage A: record the deposit event as \"seen\" (journal_entry_id NULL)\r\n  // - Stage B: later credit it once confirmations are met\r\n  //\r\n  // So, if the row already exists but has no journal_entry_id, we still proceed to credit.\r\n  return await sql.begin(async (tx) => {\r\n    const txSql = tx as unknown as typeof sql;\r\n\r\n    const inserted = await txSql<{ id: number }[]>`\r\n      INSERT INTO ex_chain_deposit_event (\r\n        chain, tx_hash, log_index, block_number, from_address, to_address,\r\n        user_id, asset_id, amount\r\n      )\r\n      VALUES (\r\n        ${args.chain},\r\n        ${args.txHash},\r\n        ${args.logIndex},\r\n        ${args.blockNumber},\r\n        ${args.fromAddress},\r\n        ${args.toAddress},\r\n        ${args.userId}::uuid,\r\n        ${args.assetId}::uuid,\r\n        (${args.amount}::numeric)\r\n      )\r\n      ON CONFLICT (chain, tx_hash, log_index) DO NOTHING\r\n      RETURNING id\r\n    `;\r\n\r\n    let eventId: number | null = inserted[0]?.id ?? null;\r\n    let alreadyCredited = false;\r\n\r\n    if (!eventId) {\r\n      const existing = await txSql<\r\n        { id: number; journal_entry_id: string | null }[]\r\n      >`\r\n        SELECT id, journal_entry_id\r\n        FROM ex_chain_deposit_event\r\n        WHERE chain = ${args.chain}\r\n          AND tx_hash = ${args.txHash}\r\n          AND log_index = ${args.logIndex}\r\n        FOR UPDATE\r\n        LIMIT 1\r\n      `;\r\n\r\n      if (existing.length === 0) {\r\n        // Extremely rare: concurrent delete or schema issue. Treat as duplicate.\r\n        return \"duplicate\";\r\n      }\r\n\r\n      eventId = Number(existing[0]!.id);\r\n      alreadyCredited = Boolean(existing[0]!.journal_entry_id);\r\n      if (alreadyCredited) return \"duplicate\";\r\n\r\n      // Ensure the existing row reflects the final resolved attribution.\r\n      // (If it was inserted earlier as \"seen\", we still want the authoritative values.)\r\n      await txSql`\r\n        UPDATE ex_chain_deposit_event\r\n        SET\r\n          block_number = ${args.blockNumber},\r\n          from_address = ${args.fromAddress},\r\n          to_address = ${args.toAddress},\r\n          user_id = ${args.userId}::uuid,\r\n          asset_id = ${args.assetId}::uuid,\r\n          amount = (${args.amount}::numeric)\r\n        WHERE id = ${eventId}\r\n      `;\r\n    }\r\n\r\n    await ensureSystemUser(txSql as any);\r\n\r\n    const userAccountRows = await txSql<{ id: string }[]>`\r\n      INSERT INTO ex_ledger_account (user_id, asset_id)\r\n      VALUES (${args.userId}::uuid, ${args.assetId}::uuid)\r\n      ON CONFLICT (user_id, asset_id) DO UPDATE SET user_id = EXCLUDED.user_id\r\n      RETURNING id\r\n    `;\r\n\r\n    const systemAccountRows = await txSql<{ id: string }[]>`\r\n      INSERT INTO ex_ledger_account (user_id, asset_id)\r\n      VALUES (${SYSTEM_USER_ID}::uuid, ${args.assetId}::uuid)\r\n      ON CONFLICT (user_id, asset_id) DO UPDATE SET user_id = EXCLUDED.user_id\r\n      RETURNING id\r\n    `;\r\n\r\n    const reference = `${args.chain}:${args.txHash}:${args.logIndex}`;\r\n    const entryRows = await (txSql as any)<{ id: string }[]>`\r\n      INSERT INTO ex_journal_entry (type, reference, metadata_json)\r\n      VALUES (\r\n        'deposit',\r\n        ${reference},\r\n        ${\r\n          {\r\n            chain: args.chain,\r\n            tx_hash: args.txHash,\r\n            log_index: args.logIndex,\r\n            block_number: args.blockNumber,\r\n            from_address: args.fromAddress,\r\n            to_address: args.toAddress,\r\n            asset_id: args.assetId,\r\n            asset_symbol: args.assetSymbol,\r\n            amount: args.amount,\r\n          } as any\r\n        }::jsonb\r\n      )\r\n      RETURNING id\r\n    `;\r\n    const entryId = entryRows[0]!.id;\r\n\r\n    await txSql`\r\n      INSERT INTO ex_journal_line (entry_id, account_id, asset_id, amount)\r\n      VALUES\r\n        (${entryId}::uuid, ${userAccountRows[0]!.id}::uuid, ${args.assetId}::uuid, (${args.amount}::numeric)),\r\n        (${entryId}::uuid, ${systemAccountRows[0]!.id}::uuid, ${args.assetId}::uuid, ((${args.amount}::numeric) * -1))\r\n    `;\r\n\r\n    await txSql`\r\n      UPDATE ex_chain_deposit_event\r\n      SET journal_entry_id = ${entryId}::uuid\r\n      WHERE chain = ${args.chain}\r\n        AND tx_hash = ${args.txHash}\r\n        AND log_index = ${args.logIndex}\r\n    `;\r\n\r\n    // Optional bookkeeping columns (added by later migrations).\r\n    if (args.cols?.hasStatus) {\r\n      await txSql`\r\n        UPDATE ex_chain_deposit_event\r\n        SET status = 'confirmed'\r\n        WHERE chain = ${args.chain}\r\n          AND tx_hash = ${args.txHash}\r\n          AND log_index = ${args.logIndex}\r\n      `;\r\n    }\r\n    if (args.cols?.hasCreditedAt) {\r\n      await txSql`\r\n        UPDATE ex_chain_deposit_event\r\n        SET credited_at = coalesce(credited_at, now())\r\n        WHERE chain = ${args.chain}\r\n          AND tx_hash = ${args.txHash}\r\n          AND log_index = ${args.logIndex}\r\n      `;\r\n    }\r\n    if (args.cols?.hasConfirmedAt) {\r\n      await txSql`\r\n        UPDATE ex_chain_deposit_event\r\n        SET confirmed_at = coalesce(confirmed_at, now())\r\n        WHERE chain = ${args.chain}\r\n          AND tx_hash = ${args.txHash}\r\n          AND log_index = ${args.logIndex}\r\n      `;\r\n    }\r\n\r\n    await createNotification(txSql as any, {\r\n      userId: args.userId,\r\n      type: \"deposit_credited\",\r\n      title: \"Deposit credited\",\r\n      body: `+${args.amount} ${args.assetSymbol} (BSC)`,\r\n      metadata: {\r\n        asset_symbol: args.assetSymbol,\r\n        chain: args.chain,\r\n        amount: args.amount,\r\n        tx_hash: args.txHash,\r\n        log_index: args.logIndex,\r\n        entry_id: entryId,\r\n      },\r\n    });\r\n\r\n    return \"credited\";\r\n  });\r\n}\r\n\r\nasync function recordDepositEventSeen(\r\n  sql: Sql,\r\n  args: {\r\n    chain: \"bsc\";\r\n    txHash: string;\r\n    logIndex: number;\r\n    blockNumber: number;\r\n    fromAddress: string | null;\r\n    toAddress: string;\r\n    userId: string;\r\n    assetId: string;\r\n    amount: string;\r\n    cols?: { hasStatus: boolean };\r\n  },\r\n): Promise<\"inserted\" | \"exists\"> {\r\n  const inserted = await sql<{ id: number }[]>`\r\n    INSERT INTO ex_chain_deposit_event (\r\n      chain, tx_hash, log_index, block_number, from_address, to_address,\r\n      user_id, asset_id, amount\r\n    )\r\n    VALUES (\r\n      ${args.chain},\r\n      ${args.txHash},\r\n      ${args.logIndex},\r\n      ${args.blockNumber},\r\n      ${args.fromAddress},\r\n      ${args.toAddress},\r\n      ${args.userId}::uuid,\r\n      ${args.assetId}::uuid,\r\n      (${args.amount}::numeric)\r\n    )\r\n    ON CONFLICT (chain, tx_hash, log_index) DO NOTHING\r\n    RETURNING id\r\n  `;\r\n\r\n  const outcome = inserted.length > 0 ? \"inserted\" : \"exists\";\r\n\r\n  if (args.cols?.hasStatus) {\r\n    // Mark uncredited events as pending confirmations.\r\n    await sql`\r\n      UPDATE ex_chain_deposit_event\r\n      SET status = 'pending'\r\n      WHERE chain = ${args.chain}\r\n        AND tx_hash = ${args.txHash}\r\n        AND log_index = ${args.logIndex}\r\n        AND journal_entry_id IS NULL\r\n        AND status <> 'reverted'\r\n    `;\r\n  }\r\n\r\n  return outcome;\r\n}\r\n\r\nasync function getOrInitCursor(sql: Sql, chain: \"bsc\"): Promise<number> {\r\n  const rows = await sql<{ last_scanned_block: number }[]>`\r\n    SELECT last_scanned_block\r\n    FROM ex_chain_deposit_cursor\r\n    WHERE chain = ${chain}\r\n    LIMIT 1\r\n  `;\r\n  if (rows.length > 0) return Number(rows[0]!.last_scanned_block ?? 0) || 0;\r\n\r\n  await sql`\r\n    INSERT INTO ex_chain_deposit_cursor (chain, last_scanned_block)\r\n    VALUES (${chain}, 0)\r\n    ON CONFLICT (chain) DO NOTHING\r\n  `;\r\n  return 0;\r\n}\r\n\r\nasync function updateCursor(sql: Sql, chain: \"bsc\", lastScannedBlock: number): Promise<void> {\r\n  await sql`\r\n    INSERT INTO ex_chain_deposit_cursor (chain, last_scanned_block, updated_at)\r\n    VALUES (${chain}, ${lastScannedBlock}, now())\r\n    ON CONFLICT (chain)\r\n    DO UPDATE SET\r\n      last_scanned_block = GREATEST(ex_chain_deposit_cursor.last_scanned_block, EXCLUDED.last_scanned_block),\r\n      updated_at = now()\r\n  `;\r\n}\r\n\r\nexport async function scanAndCreditBscDeposits(\r\n  sql: Sql,\r\n  opts?: {\r\n    fromBlock?: number;\r\n    maxBlocks?: number;\r\n    confirmations?: number;\r\n    blocksPerBatch?: number;\r\n    maxMs?: number;\r\n    scanNative?: boolean;\r\n    scanTokens?: boolean;\r\n    tokenSymbols?: string[];\r\n  },\r\n): Promise<{\r\n  ok: true;\r\n  chain: \"bsc\";\r\n  fromBlock: number;\r\n  toBlock: number;\r\n  tip: number;\r\n  confirmations: number;\r\n  batches: number;\r\n  assets: number;\r\n  scanNative: boolean;\r\n  scanTokens: boolean;\r\n  checkedLogs: number;\r\n  matchedDeposits: number;\r\n  credited: number;\r\n  duplicates: number;\r\n  pendingSeen?: number;\r\n  stoppedEarly?: boolean;\r\n  stopReason?: \"time_budget\";\r\n}> {\r\n  const provider = getBscReadProvider();\r\n  const chain: \"bsc\" = \"bsc\";\r\n\r\n  const cols = await getDepositEventCols(sql);\r\n\r\n  const confirmations = clamp(opts?.confirmations ?? envInt(\"BSC_DEPOSIT_CONFIRMATIONS\", 2), 0, 200);\r\n  const blocksPerBatch = clamp(opts?.blocksPerBatch ?? envInt(\"BSC_DEPOSIT_BLOCKS_PER_BATCH\", 1200), 10, 10_000);\r\n  const maxBlocks = clamp(opts?.maxBlocks ?? envInt(\"BSC_DEPOSIT_MAX_BLOCKS_PER_RUN\", 15_000), 10, 200_000);\r\n\r\n  const maxMs = clamp(opts?.maxMs ?? envInt(\"BSC_DEPOSIT_MAX_MS\", 0), 0, 5 * 60_000);\r\n  const startedAtMs = Date.now();\r\n\r\n  const scanNative = opts?.scanNative ?? true;\r\n  const scanTokens = opts?.scanTokens ?? true;\r\n  const tokenSymbols = (opts?.tokenSymbols ?? []).map((s) => String(s || \"\").trim().toUpperCase()).filter(Boolean);\r\n\r\n  const tip = await provider.getBlockNumber();\r\n  const safeTip = Math.max(0, tip - confirmations);\r\n\r\n  const cursor = await getOrInitCursor(sql, chain);\r\n  const startFromCursor = cursor + 1;\r\n\r\n  // Prefer scanning near where deposit addresses actually exist.\r\n  // This protects fresh deployments from large historical backfills and prevents\r\n  // situations where the cursor is far behind tip but users expect near-real-time crediting.\r\n  let minAssignedBlock: number | null = null;\r\n  try {\r\n    const rows = await sql<{ b: string | number | null }[]>`\r\n      SELECT min(assigned_block)::text AS b\r\n      FROM ex_deposit_address\r\n      WHERE chain = ${chain} AND status = 'active' AND assigned_block IS NOT NULL\r\n    `;\r\n    const raw = rows[0]?.b;\r\n    const n = raw == null ? NaN : Number(raw);\r\n    if (Number.isFinite(n) && n > 0) minAssignedBlock = Math.trunc(n);\r\n  } catch {\r\n    minAssignedBlock = null;\r\n  }\r\n\r\n  const addressFrom = minAssignedBlock != null ? Math.max(0, minAssignedBlock - 50) : null;\r\n\r\n  // If the cursor is brand new (0) and the caller didn't specify a fromBlock,\r\n  // start at the safe tip to avoid an accidental genesis-to-tip backfill.\r\n  const defaultFrom = cursor === 0 && typeof opts?.fromBlock !== \"number\" ? safeTip : startFromCursor;\r\n  const computedFrom = Math.max(defaultFrom, addressFrom ?? 0);\r\n  const fromBlock = Math.max(0, Math.min(safeTip, opts?.fromBlock ?? computedFrom));\r\n  const toBlock = Math.min(safeTip, fromBlock + maxBlocks - 1);\r\n\r\n  // Nothing to do.\r\n  if (fromBlock > toBlock) {\r\n    return {\r\n      ok: true,\r\n      chain,\r\n      fromBlock,\r\n      toBlock,\r\n      tip,\r\n      confirmations,\r\n      batches: 0,\r\n      assets: 0,\r\n      scanNative,\r\n      scanTokens,\r\n      checkedLogs: 0,\r\n      matchedDeposits: 0,\r\n      credited: 0,\r\n      duplicates: 0,\r\n    };\r\n  }\r\n\r\n  const maxAddresses = clamp(envInt(\"BSC_DEPOSIT_MAX_ADDRESSES\", 500), 1, 50_000);\r\n  const depositAddresses = await sql<{ user_id: string; address: string }[]>`\r\n    SELECT user_id::text AS user_id, address\r\n    FROM ex_deposit_address\r\n    WHERE chain = ${chain} AND status = 'active'\r\n    ORDER BY derivation_index ASC\r\n    LIMIT ${maxAddresses}\r\n  `;\r\n  const addressToUser = new Map<string, string>();\r\n  for (const row of depositAddresses) {\r\n    const address = normalizeAddress(row.address);\r\n    if (!address) continue;\r\n    addressToUser.set(address, String(row.user_id));\r\n  }\r\n\r\n  // If we have no addresses to watch, don't hammer the RPC provider.\r\n  // Still advance the cursor so subsequent runs start from a recent block.\r\n  if (addressToUser.size === 0) {\r\n    await updateCursor(sql, chain, toBlock);\r\n    return {\r\n      ok: true,\r\n      chain,\r\n      fromBlock,\r\n      toBlock,\r\n      tip,\r\n      confirmations,\r\n      batches: 0,\r\n      assets: 0,\r\n      scanNative,\r\n      scanTokens,\r\n      checkedLogs: 0,\r\n      matchedDeposits: 0,\r\n      credited: 0,\r\n      duplicates: 0,\r\n    };\r\n  }\r\n\r\n  const tokenAssets = scanTokens\r\n    ? await sql<DepositAsset[]>`\r\n        SELECT id::text AS id, symbol, decimals, contract_address\r\n        FROM ex_asset\r\n        WHERE chain = ${chain}\r\n          AND is_enabled = true\r\n          AND contract_address IS NOT NULL\r\n          AND (${tokenSymbols.length === 0}::boolean OR upper(symbol) = ANY(${tokenSymbols}))\r\n        ORDER BY symbol ASC\r\n      `\r\n    : ([] as DepositAsset[]);\r\n\r\n  // Native BNB support (direct transfers). This does NOT require traces;\r\n  // it covers the common “send BNB to address” case. Internal transfers\r\n  // (contract sends) require trace APIs and are handled separately.\r\n  const nativeBnb = scanNative\r\n    ? (\r\n        (\r\n          await sql<NativeAsset[]>`\r\n            SELECT id::text AS id, symbol, decimals\r\n            FROM ex_asset\r\n            WHERE chain = ${chain}\r\n              AND is_enabled = true\r\n              AND contract_address IS NULL\r\n              AND upper(symbol) = 'BNB'\r\n            LIMIT 1\r\n          `\r\n        )[0] ?? null\r\n      )\r\n    : null;\r\n\r\n  // ── Pending-detection (native BNB only) ─────────────────────────\r\n  // Record recent deposits immediately (\"seen\") so the wallet can show\r\n  // pending confirmations even before crediting occurs.\r\n  //\r\n  const pendingLookback = clamp(envInt(\"BSC_DEPOSIT_PENDING_LOOKBACK_BLOCKS\", 60), 0, 500);\r\n  let pendingSeen = 0;\r\n  if (nativeBnb && pendingLookback > 0 && safeTip < tip) {\r\n    const pendingFrom = Math.max(safeTip + 1, tip - pendingLookback + 1);\r\n    const pendingTo = tip;\r\n    for (let blockNo = pendingFrom; blockNo <= pendingTo; blockNo += 1) {\r\n      if (maxMs > 0 && Date.now() - startedAtMs > maxMs) {\r\n        break;\r\n      }\r\n\r\n      const block = await provider.getBlock(blockNo, true);\r\n      if (!block) continue;\r\n\r\n      const txs = Array.isArray((block as any).transactions)\r\n        ? ((block as any).transactions as ethers.TransactionResponse[])\r\n        : [];\r\n      for (const tx of txs) {\r\n        const to = tx.to ? normalizeAddress(tx.to) : \"\";\r\n        if (!to) continue;\r\n        const userId = addressToUser.get(to);\r\n        if (!userId) continue;\r\n\r\n        const value = tx.value ?? 0n;\r\n        if (typeof value !== \"bigint\" || value <= 0n) continue;\r\n\r\n        const amount = ethers.formatUnits(value, nativeBnb.decimals);\r\n        const out = await recordDepositEventSeen(sql as any, {\r\n          chain,\r\n          txHash: String(tx.hash),\r\n          logIndex: -1,\r\n          blockNumber: Number(block.number),\r\n          fromAddress: tx.from ? normalizeAddress(tx.from) : null,\r\n          toAddress: to,\r\n          userId,\r\n          assetId: nativeBnb.id,\r\n          amount,\r\n          cols,\r\n        });\r\n\r\n        if (out === \"inserted\") pendingSeen += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  // ── Pending-detection (token transfers) ──────────────────────────\r\n  // Similar to native pending detection, but uses logs (Transfer event) for a\r\n  // small recent block window to avoid OOM / huge RPC scans.\r\n  const pendingTokenLookback = clamp(\r\n    envInt(\"BSC_DEPOSIT_PENDING_TOKEN_LOOKBACK_BLOCKS\", pendingLookback),\r\n    0,\r\n    500,\r\n  );\r\n\r\n  if (scanTokens && tokenAssets.length > 0 && pendingTokenLookback > 0 && safeTip < tip) {\r\n    const pendingFrom = Math.max(safeTip + 1, tip - pendingTokenLookback + 1);\r\n    const pendingTo = tip;\r\n\r\n    const pendingTransferTopic = ethers.id(\"Transfer(address,address,uint256)\");\r\n    const pendingToTopicChunkSize = clamp(envInt(\"BSC_DEPOSIT_TO_TOPIC_CHUNK\", 20), 1, 200);\r\n    const pendingToTopicChunks = chunk(\r\n      Array.from(addressToUser.keys()).map(encodeTopicAddress),\r\n      pendingToTopicChunkSize,\r\n    );\r\n\r\n    // Map contract -> asset meta for quick attribution.\r\n    const contractToAsset = new Map<string, DepositAsset>();\r\n    for (const asset of tokenAssets) {\r\n      const contract = normalizeAddress(asset.contract_address);\r\n      if (!contract) continue;\r\n      contractToAsset.set(contract, asset);\r\n    }\r\n\r\n    const addressChunkSize = clamp(envInt(\"BSC_DEPOSIT_LOG_ADDRESS_CHUNK\", 25), 5, 250);\r\n    const contractChunks = chunk(Array.from(contractToAsset.keys()), addressChunkSize);\r\n\r\n    for (const contracts of contractChunks) {\r\n      if (!contracts.length) continue;\r\n      if (maxMs > 0 && Date.now() - startedAtMs > maxMs) break;\r\n\r\n      for (const toTopics of pendingToTopicChunks) {\r\n        if (!toTopics.length) continue;\r\n        if (maxMs > 0 && Date.now() - startedAtMs > maxMs) break;\r\n\r\n        const logs = await getLogsBatchedOrSplit(provider, {\r\n          addresses: contracts,\r\n          fromBlock: pendingFrom,\r\n          toBlock: pendingTo,\r\n          topics: [pendingTransferTopic, null, toTopics],\r\n        });\r\n\r\n        for (const log of logs) {\r\n          if (maxMs > 0 && Date.now() - startedAtMs > maxMs) break;\r\n\r\n          const asset = contractToAsset.get(normalizeAddress(String((log as any)?.address ?? \"\")));\r\n          if (!asset) continue;\r\n\r\n          const to = decodeTopicAddress((log as any)?.topics?.[2] ?? \"\");\r\n          if (!to) continue;\r\n          const userId = addressToUser.get(to);\r\n          if (!userId) continue;\r\n\r\n          const from = decodeTopicAddress((log as any)?.topics?.[1] ?? \"\") || null;\r\n          let amountRaw = 0n;\r\n          try {\r\n            amountRaw = BigInt(String((log as any)?.data ?? \"0x0\"));\r\n          } catch {\r\n            amountRaw = 0n;\r\n          }\r\n          if (amountRaw <= 0n) continue;\r\n\r\n          const amount = ethers.formatUnits(amountRaw, asset.decimals);\r\n          const out = await recordDepositEventSeen(sql as any, {\r\n            chain,\r\n            txHash: String((log as any)?.transactionHash ?? \"\"),\r\n            logIndex: Number((log as any)?.index ?? 0),\r\n            blockNumber: Number((log as any)?.blockNumber ?? 0),\r\n            fromAddress: from,\r\n            toAddress: to,\r\n            userId,\r\n            assetId: asset.id,\r\n            amount,\r\n            cols,\r\n          });\r\n          if (out === \"inserted\") pendingSeen += 1;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const transferTopic = ethers.id(\"Transfer(address,address,uint256)\");\r\n  const toTopicChunkSize = clamp(envInt(\"BSC_DEPOSIT_TO_TOPIC_CHUNK\", 20), 1, 200);\r\n\r\n  // Precompute watched-address topic chunks once per scan run.\r\n  const toTopicChunksAll = scanTokens\r\n    ? chunk(Array.from(addressToUser.keys()).map(encodeTopicAddress), toTopicChunkSize)\r\n    : [];\r\n\r\n  let batches = 0;\r\n  let checkedLogs = 0;\r\n  let matchedDeposits = 0;\r\n  let credited = 0;\r\n  let duplicates = 0;\r\n\r\n  let stoppedEarly = false;\r\n  let stopReason: \"time_budget\" | undefined;\r\n\r\n  const timeExceeded = (): boolean => maxMs > 0 && Date.now() - startedAtMs > maxMs;\r\n\r\n  for (let start = fromBlock; start <= toBlock; start += blocksPerBatch) {\r\n    if (timeExceeded()) {\r\n      stoppedEarly = true;\r\n      stopReason = \"time_budget\";\r\n      break;\r\n    }\r\n\r\n    const end = Math.min(toBlock, start + blocksPerBatch - 1);\r\n    batches += 1;\r\n\r\n    if (nativeBnb) {\r\n      for (let blockNo = start; blockNo <= end; blockNo += 1) {\r\n        if (timeExceeded()) {\r\n          stoppedEarly = true;\r\n          stopReason = \"time_budget\";\r\n          break;\r\n        }\r\n\r\n        const block = await provider.getBlock(blockNo, true);\r\n        if (!block) continue;\r\n\r\n        const txs = Array.isArray((block as any).transactions) ? ((block as any).transactions as ethers.TransactionResponse[]) : [];\r\n        for (const tx of txs) {\r\n          if (timeExceeded()) {\r\n            stoppedEarly = true;\r\n            stopReason = \"time_budget\";\r\n            break;\r\n          }\r\n          const to = tx.to ? normalizeAddress(tx.to) : \"\";\r\n          if (!to) continue;\r\n          const userId = addressToUser.get(to);\r\n          if (!userId) continue;\r\n\r\n          const value = tx.value ?? 0n;\r\n          if (typeof value !== \"bigint\" || value <= 0n) continue;\r\n\r\n          matchedDeposits += 1;\r\n          const amount = ethers.formatUnits(value, nativeBnb.decimals);\r\n\r\n          // Use log_index = -1 to avoid collisions with ERC20 log indexes (0..N) for the same tx hash.\r\n          const outcome = await creditDepositEvent(sql as any, {\r\n            chain,\r\n            txHash: String(tx.hash),\r\n            logIndex: -1,\r\n            blockNumber: Number(block.number),\r\n            fromAddress: tx.from ? normalizeAddress(tx.from) : null,\r\n            toAddress: to,\r\n            userId,\r\n            assetId: nativeBnb.id,\r\n            assetSymbol: nativeBnb.symbol,\r\n            amount,\r\n            cols,\r\n          });\r\n\r\n          if (outcome === \"credited\") credited += 1;\r\n          else duplicates += 1;\r\n        }\r\n\r\n        if (stoppedEarly) break;\r\n      }\r\n    }\r\n\r\n    if (stoppedEarly) break;\r\n\r\n    if (!scanTokens) {\r\n      await updateCursor(sql, chain, end);\r\n      continue;\r\n    }\r\n\r\n    const addressChunkSize = clamp(envInt(\"BSC_DEPOSIT_LOG_ADDRESS_CHUNK\", 25), 5, 250);\r\n    const contractToAsset = new Map<string, DepositAsset>();\r\n    for (const asset of tokenAssets) {\r\n      const contract = normalizeAddress(asset.contract_address);\r\n      if (!contract) continue;\r\n      contractToAsset.set(contract, asset);\r\n    }\r\n\r\n    const contractChunks = chunk(Array.from(contractToAsset.keys()), addressChunkSize);\r\n    for (const contracts of contractChunks) {\r\n      if (!contracts.length) continue;\r\n\r\n      if (timeExceeded()) {\r\n        stoppedEarly = true;\r\n        stopReason = \"time_budget\";\r\n        break;\r\n      }\r\n\r\n      for (const toTopics of toTopicChunksAll) {\r\n        if (!toTopics.length) continue;\r\n\r\n        if (timeExceeded()) {\r\n          stoppedEarly = true;\r\n          stopReason = \"time_budget\";\r\n          break;\r\n        }\r\n\r\n        const logs = await getLogsBatchedOrSplit(provider, {\r\n          addresses: contracts,\r\n          fromBlock: start,\r\n          toBlock: end,\r\n          // Filter by recipient to avoid fetching *all* transfers for the token.\r\n          // topics[2] is `to` in the Transfer event.\r\n          topics: [transferTopic, null, toTopics],\r\n        });\r\n\r\n        checkedLogs += logs.length;\r\n\r\n        for (const log of logs) {\r\n          if (timeExceeded()) {\r\n            stoppedEarly = true;\r\n            stopReason = \"time_budget\";\r\n            break;\r\n          }\r\n          const asset = contractToAsset.get(normalizeAddress(String((log as any)?.address ?? \"\")));\r\n          if (!asset) continue;\r\n\r\n          // Transfer(address indexed from, address indexed to, uint256 value)\r\n          const to = decodeTopicAddress(log.topics?.[2] ?? \"\");\r\n          if (!to) continue;\r\n          const userId = addressToUser.get(to);\r\n          if (!userId) continue;\r\n\r\n          const from = decodeTopicAddress(log.topics?.[1] ?? \"\") || null;\r\n          const amountRaw = BigInt(log.data);\r\n          if (amountRaw <= 0n) continue;\r\n\r\n          matchedDeposits += 1;\r\n          const amount = ethers.formatUnits(amountRaw, asset.decimals);\r\n\r\n          const outcome = await creditDepositEvent(sql as any, {\r\n            chain,\r\n            txHash: String(log.transactionHash),\r\n            logIndex: Number(log.index),\r\n            blockNumber: Number(log.blockNumber),\r\n            fromAddress: from,\r\n            toAddress: to,\r\n            userId,\r\n            assetId: asset.id,\r\n            assetSymbol: asset.symbol,\r\n            amount,\r\n            cols,\r\n          });\r\n\r\n          if (outcome === \"credited\") credited += 1;\r\n          else duplicates += 1;\r\n        }\r\n\r\n        if (stoppedEarly) break;\r\n      }\r\n\r\n      if (stoppedEarly) break;\r\n    }\r\n\r\n    // Cursor advances only after all assets for the batch are processed.\r\n    if (stoppedEarly) break;\r\n    await updateCursor(sql, chain, end);\r\n  }\r\n\r\n  return {\r\n    ok: true,\r\n    chain,\r\n    fromBlock,\r\n    toBlock,\r\n    tip,\r\n    confirmations,\r\n    batches,\r\n    assets: tokenAssets.length + (nativeBnb ? 1 : 0),\r\n    scanNative,\r\n    scanTokens,\r\n    checkedLogs,\r\n    matchedDeposits,\r\n    credited,\r\n    duplicates,\r\n    ...(pendingSeen ? { pendingSeen } : {}),\r\n    ...(stoppedEarly ? { stoppedEarly, stopReason } : {}),\r\n  };\r\n}\r\n\r\nexport async function finalizePendingBscDeposits(\r\n  sql: Sql,\r\n  opts?: {\r\n    confirmations?: number;\r\n    max?: number;\r\n    maxMs?: number;\r\n  },\r\n): Promise<{\r\n  ok: true;\r\n  chain: \"bsc\";\r\n  tip: number;\r\n  safe_tip: number;\r\n  confirmations_required: number;\r\n  scanned: number;\r\n  credited: number;\r\n  duplicates: number;\r\n  stoppedEarly?: boolean;\r\n  stopReason?: \"time_budget\";\r\n}> {\r\n  const provider = getBscReadProvider();\r\n  const chain: \"bsc\" = \"bsc\";\r\n  const cols = await getDepositEventCols(sql);\r\n\r\n  const confirmationsRequired = clamp(opts?.confirmations ?? envInt(\"BSC_DEPOSIT_CONFIRMATIONS\", 2), 0, 200);\r\n  const tip = await provider.getBlockNumber();\r\n  const safeTip = Math.max(0, tip - confirmationsRequired);\r\n\r\n  const max = clamp(opts?.max ?? envInt(\"BSC_DEPOSIT_FINALIZE_MAX\", 250), 1, 2000);\r\n  const maxMs = clamp(opts?.maxMs ?? envInt(\"BSC_DEPOSIT_FINALIZE_MAX_MS\", 0), 0, 60_000);\r\n  const startedAtMs = Date.now();\r\n  const timeExceeded = (): boolean => maxMs > 0 && Date.now() - startedAtMs > maxMs;\r\n\r\n  // Select pending, uncredited events that are now within the safe tip.\r\n  const rows = await sql<\r\n    Array<{\r\n      tx_hash: string;\r\n      log_index: number;\r\n      block_number: number;\r\n      from_address: string | null;\r\n      to_address: string;\r\n      user_id: string;\r\n      asset_id: string;\r\n      asset_symbol: string;\r\n      amount: string;\r\n    }>\r\n  >`\r\n    SELECT\r\n      e.tx_hash,\r\n      e.log_index,\r\n      e.block_number,\r\n      e.from_address,\r\n      e.to_address,\r\n      e.user_id::text AS user_id,\r\n      e.asset_id::text AS asset_id,\r\n      a.symbol AS asset_symbol,\r\n      e.amount::text AS amount\r\n    FROM ex_chain_deposit_event e\r\n    JOIN ex_asset a ON a.id = e.asset_id\r\n    WHERE e.chain = ${chain}\r\n      AND e.journal_entry_id IS NULL\r\n      AND e.status = 'pending'\r\n      AND e.block_number <= ${safeTip}\r\n    ORDER BY e.block_number ASC, e.id ASC\r\n    LIMIT ${max}\r\n  `;\r\n\r\n  let credited = 0;\r\n  let duplicates = 0;\r\n  let scanned = 0;\r\n  let stoppedEarly = false;\r\n  let stopReason: \"time_budget\" | undefined;\r\n\r\n  for (const r of rows) {\r\n    if (timeExceeded()) {\r\n      stoppedEarly = true;\r\n      stopReason = \"time_budget\";\r\n      break;\r\n    }\r\n\r\n    scanned += 1;\r\n    const outcome = await creditDepositEvent(sql as any, {\r\n      chain,\r\n      txHash: String(r.tx_hash),\r\n      logIndex: Number(r.log_index),\r\n      blockNumber: Number(r.block_number),\r\n      fromAddress: r.from_address ? normalizeAddress(String(r.from_address)) : null,\r\n      toAddress: normalizeAddress(String(r.to_address)),\r\n      userId: String(r.user_id),\r\n      assetId: String(r.asset_id),\r\n      assetSymbol: String(r.asset_symbol),\r\n      amount: String(r.amount),\r\n      cols,\r\n    });\r\n\r\n    if (outcome === \"credited\") credited += 1;\r\n    else duplicates += 1;\r\n  }\r\n\r\n  return {\r\n    ok: true,\r\n    chain,\r\n    tip,\r\n    safe_tip: safeTip,\r\n    confirmations_required: confirmationsRequired,\r\n    scanned,\r\n    credited,\r\n    duplicates,\r\n    ...(stoppedEarly ? { stoppedEarly, stopReason } : {}),\r\n  };\r\n}\r\n"],"names":[],"mappings":"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"}