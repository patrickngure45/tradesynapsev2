{"version":3,"sources":["../../../node_modules/next/dist/esm/build/templates/app-route.js","../../../src/app/api/exchange/arbitrage/overview/route.ts"],"sourcesContent":["import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setManifestsSingleton } from \"next/dist/esm/server/app-render/manifests-singleton\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/exchange/arbitrage/overview/route\",\n        pathname: \"/api/exchange/arbitrage/overview\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/src/app/api/exchange/arbitrage/overview/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/exchange/arbitrage/overview/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext, silenceLog)=>routeModule.onRequestError(req, error, errorContext, silenceLog, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        const silenceLog = false;\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, silenceLog, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            const silenceLog = false;\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            }, silenceLog, routerServerContext);\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","import { NextResponse } from \"next/server\";\r\n\r\nimport { getSql } from \"@/lib/db\";\r\nimport { getActingUserId, requireActingUserIdInProd } from \"@/lib/auth/party\";\r\nimport { requireActiveUser } from \"@/lib/auth/activeUser\";\r\nimport { responseForDbError } from \"@/lib/dbTransient\";\r\n\r\nimport { decryptCredential } from \"@/lib/auth/credentials\";\r\nimport {\r\n  getAuthenticatedTradingFee,\r\n  getExchangeBalances,\r\n  getExchangeMarketConstraints,\r\n  getExchangeOrderBook,\r\n  type ExchangeMarketConstraints,\r\n  type ExchangeOrderBook,\r\n} from \"@/lib/exchange/externalApis\";\r\n\r\nimport {\r\n  captureArbSnapshots,\r\n  detectOpportunities,\r\n  getRecentSnapshots,\r\n  type ArbSnapshot,\r\n} from \"@/lib/exchange/arbitrage\";\r\nimport type { SupportedExchange } from \"@/lib/exchange/externalApis\";\r\n\r\nimport { getOrComputeFxReferenceRate } from \"@/lib/fx/reference\";\r\nimport { getExternalIndexUsdt } from \"@/lib/market/indexPrice\";\r\n\r\nexport const runtime = \"nodejs\";\r\nexport const dynamic = \"force-dynamic\";\r\n\r\nfunction clamp(n: number, min: number, max: number) {\r\n  return Math.min(max, Math.max(min, n));\r\n}\r\n\r\nfunction envNumber(name: string, fallback: number): number {\r\n  const raw = process.env[name];\r\n  if (!raw) return fallback;\r\n  const v = Number(raw);\r\n  return Number.isFinite(v) ? v : fallback;\r\n}\r\n\r\nfunction latestPerSymbolExchange(snapshots: ArbSnapshot[]): ArbSnapshot[] {\r\n  const byKey = new Map<string, ArbSnapshot>();\r\n  for (const s of snapshots) {\r\n    const key = `${s.symbol}::${s.exchange}`;\r\n    const prev = byKey.get(key);\r\n    if (!prev || s.ts > prev.ts) byKey.set(key, s);\r\n  }\r\n  return Array.from(byKey.values());\r\n}\r\n\r\nfunction normalizeExternalSymbol(base: string, quote: string) {\r\n  return `${base}${quote}`.replace(/[^a-zA-Z0-9]/g, \"\").toUpperCase();\r\n}\r\n\r\nasync function getEnabledAssetSymbols(sql: ReturnType<typeof getSql>): Promise<string[]> {\r\n  const rows = await sql<{ symbol: string }[]>`\r\n    SELECT symbol\r\n    FROM ex_asset\r\n    WHERE chain = 'bsc' AND is_enabled = true\r\n    ORDER BY symbol ASC\r\n  `;\r\n  return rows.map((r) => String(r.symbol).toUpperCase());\r\n}\r\n\r\nfunction prioritizedCap<T>(items: T[], priority: (item: T) => number, cap: number): T[] {\r\n  const sorted = [...items].sort((a, b) => priority(b) - priority(a));\r\n  return sorted.slice(0, Math.max(0, cap));\r\n}\r\n\r\nasync function runWithConcurrency<T>(items: T[], limit: number, worker: (item: T) => Promise<void>): Promise<void> {\r\n  const concurrency = Math.max(1, Math.floor(limit));\r\n  let i = 0;\r\n  const runners = Array.from({ length: Math.min(concurrency, items.length) }, async () => {\r\n    while (true) {\r\n      const idx = i++;\r\n      if (idx >= items.length) return;\r\n      await worker(items[idx]!);\r\n    }\r\n  });\r\n  await Promise.allSettled(runners);\r\n}\r\n\r\nfunction parseBaseFromSymbol(symbol: string, quoteSuffix: string): string | null {\r\n  const s = symbol.toUpperCase();\r\n  const q = quoteSuffix.toUpperCase();\r\n  if (!s.endsWith(q) || s.length <= q.length) return null;\r\n  return s.slice(0, -q.length);\r\n}\r\n\r\nfunction envBool(name: string, fallback: boolean): boolean {\r\n  const raw = process.env[name];\r\n  if (!raw) return fallback;\r\n  const v = raw.trim().toLowerCase();\r\n  if (v === \"1\" || v === \"true\" || v === \"yes\") return true;\r\n  if (v === \"0\" || v === \"false\" || v === \"no\") return false;\r\n  return fallback;\r\n}\r\n\r\nfunction hashUnit(input: string): number {\r\n  let h = 2166136261;\r\n  for (let i = 0; i < input.length; i++) {\r\n    h ^= input.charCodeAt(i);\r\n    h = Math.imul(h, 16777619);\r\n  }\r\n  return (h >>> 0) / 4294967295;\r\n}\r\n\r\nconst INTERNAL_SETTLEMENT_ENABLED = envBool(\"ARB_INTERNAL_SETTLEMENT_ENABLED\", true);\r\n\r\nfunction pctFromBps(bps: number): number {\r\n  return bps / 100; // 100 bps = 1%\r\n}\r\n\r\nfunction vwapBuyForQuoteNotional(asks: Array<[number, number]>, quoteNotional: number) {\r\n  // asks: [price, baseAmount]\r\n  let remainingQuote = quoteNotional;\r\n  let baseFilled = 0;\r\n  let quoteSpent = 0;\r\n  for (const [price, baseAvail] of asks) {\r\n    if (remainingQuote <= 0) break;\r\n    const levelQuote = price * baseAvail;\r\n    const takeQuote = Math.min(levelQuote, remainingQuote);\r\n    const takeBase = takeQuote / price;\r\n    baseFilled += takeBase;\r\n    quoteSpent += takeQuote;\r\n    remainingQuote -= takeQuote;\r\n  }\r\n  if (!(quoteSpent > 0) || !(baseFilled > 0)) return null;\r\n  const vwap = quoteSpent / baseFilled;\r\n  const top = asks.length ? asks[0]![0] : vwap;\r\n  const slippageBps = top > 0 ? ((vwap - top) / top) * 10_000 : 0;\r\n  return { vwap, baseFilled, slippageBps };\r\n}\r\n\r\nfunction vwapSellForBaseAmount(bids: Array<[number, number]>, baseAmount: number) {\r\n  // bids: [price, baseAmount]\r\n  let remainingBase = baseAmount;\r\n  let baseSold = 0;\r\n  let quoteReceived = 0;\r\n  for (const [price, baseAvail] of bids) {\r\n    if (remainingBase <= 0) break;\r\n    const takeBase = Math.min(baseAvail, remainingBase);\r\n    baseSold += takeBase;\r\n    quoteReceived += takeBase * price;\r\n    remainingBase -= takeBase;\r\n  }\r\n  if (!(quoteReceived > 0) || !(baseSold > 0)) return null;\r\n  const vwap = quoteReceived / baseSold;\r\n  const top = bids.length ? bids[0]![0] : vwap;\r\n  const slippageBps = top > 0 ? ((top - vwap) / top) * 10_000 : 0;\r\n  return { vwap, quoteReceived, slippageBps };\r\n}\r\n\r\nfunction basePriority(symbol: string): number {\r\n  // Bias toward liquidity/robustness first.\r\n  const order = [\r\n    \"BTC\",\r\n    \"ETH\",\r\n    \"BNB\",\r\n    \"SOL\",\r\n    \"XRP\",\r\n    \"ADA\",\r\n    \"DOGE\",\r\n    \"TRX\",\r\n    \"LINK\",\r\n    \"AVAX\",\r\n    \"TON\",\r\n    \"MATIC\",\r\n  ];\r\n  const idx = order.indexOf(symbol.toUpperCase());\r\n  return idx === -1 ? 0 : 1000 - idx;\r\n}\r\n\r\nasync function getUserActiveVenues(sql: ReturnType<typeof getSql>, userId: string): Promise<SupportedExchange[]> {\r\n  const rows = await sql<{ exchange: string }[]>`\r\n    SELECT exchange\r\n    FROM user_exchange_connection\r\n    WHERE user_id = ${userId}::uuid\r\n      AND status = 'active'\r\n    GROUP BY exchange\r\n    ORDER BY exchange ASC\r\n  `;\r\n\r\n  const allow = new Set<SupportedExchange>([\r\n    \"binance\",\r\n    \"bybit\",\r\n    \"okx\",\r\n    \"kucoin\",\r\n    \"gateio\",\r\n    \"bitget\",\r\n    \"mexc\",\r\n  ]);\r\n\r\n  return rows\r\n    .map((r) => String(r.exchange).toLowerCase())\r\n    .filter((e): e is SupportedExchange => allow.has(e as SupportedExchange));\r\n}\r\n\r\nfunction getDefaultPublicVenues(): SupportedExchange[] {\r\n  const allow = new Set<SupportedExchange>([\r\n    \"binance\",\r\n    \"bybit\",\r\n    \"okx\",\r\n    \"kucoin\",\r\n    \"gateio\",\r\n    \"bitget\",\r\n    \"mexc\",\r\n  ]);\r\n  const raw = process.env.ARB_PUBLIC_VENUES;\r\n  if (raw) {\r\n    const list = raw\r\n      .split(\",\")\r\n      .map((s) => s.trim().toLowerCase())\r\n      .filter(Boolean);\r\n    const venues = list.filter((v): v is SupportedExchange => allow.has(v as SupportedExchange));\r\n    if (venues.length > 0) return venues;\r\n  }\r\n  return [\"binance\", \"bybit\", \"okx\"]; // sane defaults\r\n}\r\n\r\nasync function getUserVenueCredentials(\r\n  sql: ReturnType<typeof getSql>,\r\n  userId: string,\r\n  venues: SupportedExchange[],\r\n): Promise<Record<string, { apiKey: string; apiSecret: string; passphrase?: string }>> {\r\n  if (!venues.length) return {};\r\n  const rows = await sql<\r\n    Array<{\r\n      exchange: string;\r\n      api_key_enc: string;\r\n      api_secret_enc: string;\r\n      passphrase_enc: string | null;\r\n      created_at: string;\r\n    }>\r\n  >`\r\n    SELECT exchange, api_key_enc, api_secret_enc, passphrase_enc, created_at\r\n    FROM user_exchange_connection\r\n    WHERE user_id = ${userId}::uuid\r\n      AND status = 'active'\r\n      AND exchange IN (${sql(venues)})\r\n    ORDER BY exchange ASC, created_at DESC\r\n  `;\r\n\r\n  const out: Record<string, { apiKey: string; apiSecret: string; passphrase?: string }> = {};\r\n  for (const r of rows) {\r\n    const ex = String(r.exchange).toLowerCase();\r\n    if (out[ex]) continue; // keep most recent per exchange\r\n    out[ex] = {\r\n      apiKey: decryptCredential(r.api_key_enc),\r\n      apiSecret: decryptCredential(r.api_secret_enc),\r\n      ...(r.passphrase_enc ? { passphrase: decryptCredential(r.passphrase_enc) } : {}),\r\n    };\r\n  }\r\n  return out;\r\n}\r\n\r\ntype VenueBalanceSnapshot = {\r\n  exchange: string;\r\n  checkedAt: string;\r\n  ok: boolean;\r\n  error?: string;\r\n  assets?: Record<string, { free: number; locked: number }>;\r\n};\r\n\r\ntype VenueFeeSnapshot = {\r\n  exchange: string;\r\n  checkedAt: string;\r\n  ok: boolean;\r\n  taker?: number | null; // fraction\r\n  maker?: number | null; // fraction\r\n  source?: string;\r\n  error?: string;\r\n};\r\n\r\nasync function fetchVenueFees(\r\n  venues: SupportedExchange[],\r\n  credsByVenue: Record<string, { apiKey: string; apiSecret: string; passphrase?: string }>,\r\n  feeSymbol: string,\r\n): Promise<Record<string, VenueFeeSnapshot>> {\r\n  const out: Record<string, VenueFeeSnapshot> = {};\r\n  const limit = clamp(envNumber(\"ARB_FEE_CONCURRENCY\", 3), 1, 6);\r\n\r\n  await runWithConcurrency(venues, limit, async (venue) => {\r\n    const ex = venue.toLowerCase();\r\n    const creds = credsByVenue[ex];\r\n    if (!creds) {\r\n      out[ex] = { exchange: ex, checkedAt: new Date().toISOString(), ok: false, error: \"missing_credentials\" };\r\n      return;\r\n    }\r\n    try {\r\n      const fee = await getAuthenticatedTradingFee(venue, creds, feeSymbol);\r\n      out[ex] = {\r\n        exchange: ex,\r\n        checkedAt: new Date().toISOString(),\r\n        ok: true,\r\n        taker: fee.taker,\r\n        maker: fee.maker,\r\n        source: fee.source,\r\n      };\r\n    } catch (e) {\r\n      out[ex] = {\r\n        exchange: ex,\r\n        checkedAt: new Date().toISOString(),\r\n        ok: false,\r\n        error: e instanceof Error ? e.message : String(e),\r\n      };\r\n    }\r\n  });\r\n\r\n  return out;\r\n}\r\n\r\ntype DepthKey = string;\r\nfunction depthKey(exchange: string, symbol: string): DepthKey {\r\n  return `${exchange.toLowerCase()}::${symbol.toUpperCase()}`;\r\n}\r\n\r\ntype ConstraintKey = string;\r\nfunction constraintKey(exchange: string, symbol: string): ConstraintKey {\r\n  return `${exchange.toLowerCase()}::${symbol.toUpperCase()}`;\r\n}\r\n\r\nfunction floorToPrecision(value: number, precision: number | null): number {\r\n  if (!Number.isFinite(value) || value <= 0) return 0;\r\n  if (precision === null || !Number.isFinite(precision) || precision < 0) return value;\r\n  const p = Math.min(12, Math.max(0, Math.floor(precision)));\r\n  const factor = 10 ** p;\r\n  return Math.floor(value * factor) / factor;\r\n}\r\n\r\nasync function fetchConstraintsForPairs(\r\n  pairs: Array<{ exchange: SupportedExchange; symbol: string }>,\r\n): Promise<Map<ConstraintKey, ExchangeMarketConstraints>> {\r\n  const unique = new Map<ConstraintKey, { exchange: SupportedExchange; symbol: string }>();\r\n  for (const p of pairs) unique.set(constraintKey(p.exchange, p.symbol), p);\r\n  const items = Array.from(unique.values());\r\n  const limit = clamp(envNumber(\"ARB_CONSTRAINTS_CONCURRENCY\", 4), 1, 8);\r\n  const out = new Map<ConstraintKey, ExchangeMarketConstraints>();\r\n\r\n  await runWithConcurrency(items, limit, async (p) => {\r\n    const k = constraintKey(p.exchange, p.symbol);\r\n    const c = await getExchangeMarketConstraints(p.exchange, p.symbol);\r\n    out.set(k, c);\r\n  });\r\n\r\n  return out;\r\n}\r\n\r\nasync function fetchDepthForPairs(pairs: Array<{ exchange: SupportedExchange; symbol: string }>): Promise<Map<DepthKey, ExchangeOrderBook>> {\r\n  const unique = new Map<DepthKey, { exchange: SupportedExchange; symbol: string }>();\r\n  for (const p of pairs) unique.set(depthKey(p.exchange, p.symbol), p);\r\n  const items = Array.from(unique.values());\r\n  const limit = clamp(envNumber(\"ARB_DEPTH_CONCURRENCY\", 4), 1, 8);\r\n  const obLimit = clamp(envNumber(\"ARB_ORDERBOOK_LIMIT\", 50), 10, 200);\r\n  const out = new Map<DepthKey, ExchangeOrderBook>();\r\n\r\n  await runWithConcurrency(items, limit, async (p) => {\r\n    const k = depthKey(p.exchange, p.symbol);\r\n    const ob = await getExchangeOrderBook(p.exchange, p.symbol, { limit: obLimit });\r\n    out.set(k, ob);\r\n  });\r\n\r\n  return out;\r\n}\r\n\r\nasync function fetchVenueBalances(\r\n  venues: SupportedExchange[],\r\n  credsByVenue: Record<string, { apiKey: string; apiSecret: string; passphrase?: string }>,\r\n  relevantAssets: string[],\r\n): Promise<Record<string, VenueBalanceSnapshot>> {\r\n  const out: Record<string, VenueBalanceSnapshot> = {};\r\n  const assetsSet = new Set(relevantAssets.map((a) => a.toUpperCase()));\r\n  const limit = clamp(envNumber(\"ARB_BALANCE_CONCURRENCY\", 3), 1, 6);\r\n\r\n  await runWithConcurrency(venues, limit, async (venue) => {\r\n    const ex = venue.toLowerCase();\r\n    const creds = credsByVenue[ex];\r\n    if (!creds) {\r\n      out[ex] = { exchange: ex, checkedAt: new Date().toISOString(), ok: false, error: \"missing_credentials\" };\r\n      return;\r\n    }\r\n    try {\r\n      const balances = await getExchangeBalances(venue, creds);\r\n      const assets: Record<string, { free: number; locked: number }> = {};\r\n      for (const b of balances) {\r\n        const asset = String(b.asset).toUpperCase();\r\n        if (!assetsSet.has(asset)) continue;\r\n        const free = Number(b.free);\r\n        const locked = Number(b.locked);\r\n        assets[asset] = {\r\n          free: Number.isFinite(free) ? free : 0,\r\n          locked: Number.isFinite(locked) ? locked : 0,\r\n        };\r\n      }\r\n      out[ex] = { exchange: ex, checkedAt: new Date().toISOString(), ok: true, assets };\r\n    } catch (e) {\r\n      out[ex] = {\r\n        exchange: ex,\r\n        checkedAt: new Date().toISOString(),\r\n        ok: false,\r\n        error: e instanceof Error ? e.message : String(e),\r\n      };\r\n    }\r\n  });\r\n\r\n  return out;\r\n}\r\n\r\nasync function getInternalUsdtMarkets(sql: ReturnType<typeof getSql>, bases: string[]) {\r\n  if (bases.length === 0) return [] as Array<{ base: string; symbol: string; bid: number; ask: number; mid: number; ts: string }>;\r\n\r\n  // Pull best bid/ask for base/USDT markets from open orderbook; if missing, fall back to last execution.\r\n  const rows = await sql<\r\n    Array<{\r\n      symbol: string;\r\n      base_symbol: string;\r\n      bid: string | null;\r\n      ask: string | null;\r\n      last: string | null;\r\n      last_ts: string | null;\r\n    }>\r\n  >`\r\n    WITH mk AS (\r\n      SELECT m.id, m.symbol, ab.symbol AS base_symbol\r\n      FROM ex_market m\r\n      JOIN ex_asset ab ON ab.id = m.base_asset_id\r\n      JOIN ex_asset aq ON aq.id = m.quote_asset_id\r\n      WHERE m.status = 'enabled'\r\n        AND ab.chain = 'bsc'\r\n        AND aq.chain = 'bsc'\r\n        AND aq.symbol = 'USDT'\r\n        AND ab.symbol = ANY(${sql.array(bases.map((b) => b.toUpperCase()))})\r\n    ),\r\n    best_bid AS (\r\n      SELECT o.market_id, max(o.price)::text AS bid\r\n      FROM ex_order o\r\n      WHERE o.side = 'buy' AND o.status IN ('open','partially_filled')\r\n      GROUP BY o.market_id\r\n    ),\r\n    best_ask AS (\r\n      SELECT o.market_id, min(o.price)::text AS ask\r\n      FROM ex_order o\r\n      WHERE o.side = 'sell' AND o.status IN ('open','partially_filled')\r\n      GROUP BY o.market_id\r\n    ),\r\n    last_exec AS (\r\n      SELECT DISTINCT ON (e.market_id) e.market_id, e.price::text AS last, e.created_at::text AS last_ts\r\n      FROM ex_execution e\r\n      ORDER BY e.market_id, e.created_at DESC\r\n    )\r\n    SELECT mk.symbol, mk.base_symbol,\r\n           bb.bid, ba.ask,\r\n           le.last, le.last_ts\r\n    FROM mk\r\n    LEFT JOIN best_bid bb ON bb.market_id = mk.id\r\n    LEFT JOIN best_ask ba ON ba.market_id = mk.id\r\n    LEFT JOIN last_exec le ON le.market_id = mk.id\r\n  `;\r\n\r\n  const fallbackSpreadBps = clamp(envNumber(\"ARB_INTERNAL_FALLBACK_SPREAD_BPS\", 30), 1, 500);\r\n  const half = fallbackSpreadBps / 2 / 10_000;\r\n\r\n  const out: Array<{ base: string; symbol: string; bid: number; ask: number; mid: number; ts: string }> = [];\r\n  for (const r of rows) {\r\n    const bid = r.bid ? Number(r.bid) : NaN;\r\n    const ask = r.ask ? Number(r.ask) : NaN;\r\n    if (Number.isFinite(bid) && Number.isFinite(ask) && bid > 0 && ask > 0) {\r\n      out.push({\r\n        base: String(r.base_symbol).toUpperCase(),\r\n        symbol: String(r.symbol),\r\n        bid,\r\n        ask,\r\n        mid: (bid + ask) / 2,\r\n        ts: new Date().toISOString(),\r\n      });\r\n      continue;\r\n    }\r\n\r\n    const last = r.last ? Number(r.last) : NaN;\r\n    if (!Number.isFinite(last) || last <= 0) continue;\r\n\r\n    out.push({\r\n      base: String(r.base_symbol).toUpperCase(),\r\n      symbol: String(r.symbol),\r\n      bid: last * (1 - half),\r\n      ask: last * (1 + half),\r\n      mid: last,\r\n      ts: r.last_ts ? String(r.last_ts) : new Date().toISOString(),\r\n    });\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\nexport async function GET(req: Request) {\r\n  const sql = getSql();\r\n  const actingUserId = getActingUserId(req);\r\n  const authErr = requireActingUserIdInProd(actingUserId);\r\n  if (authErr) return NextResponse.json({ error: authErr }, { status: 401 });\r\n  if (!actingUserId) return NextResponse.json({ error: \"missing_x_user_id\" }, { status: 401 });\r\n\r\n  const url = new URL(req.url);\r\n  const action = url.searchParams.get(\"action\") ?? \"latest\";\r\n\r\n  try {\r\n    const activeErr = await requireActiveUser(sql, actingUserId);\r\n    if (activeErr) return NextResponse.json({ error: activeErr }, { status: 403 });\r\n\r\n    const connectedVenues = await getUserActiveVenues(sql, actingUserId);\r\n    const scanVenues = connectedVenues.length > 0 ? connectedVenues : getDefaultPublicVenues();\r\n\r\n    // Enabled assets from master wallet; we will scan a capped subset to keep API calls realistic.\r\n    const enabledAssets = await getEnabledAssetSymbols(sql);\r\n    const enabledBases = enabledAssets.filter((s) => s !== \"USDT\");\r\n\r\n    const maxSymbols = clamp(envNumber(\"ARB_MAX_SYMBOLS\", 30), 5, 200);\r\n    const cappedBases = prioritizedCap(enabledBases, (b) => basePriority(String(b)), maxSymbols);\r\n\r\n    const trackedSymbols = cappedBases.map((b) => normalizeExternalSymbol(String(b), \"USDT\"));\r\n\r\n    const externalErrors: Array<{ error: string; message: string }> = [];\r\n    if (trackedSymbols.length === 0) {\r\n      externalErrors.push({ error: \"no_symbols\", message: \"No enabled assets are available to scan.\" });\r\n    }\r\n\r\n    const minUsd = clamp(envNumber(\"ARB_MIN_NOTIONAL_USD\", 25), 5, 500);\r\n    const maxUsdHardCap = clamp(envNumber(\"ARB_NOTIONAL_USD_CAP\", 1000), minUsd, 100_000);\r\n    const notionalUsd = clamp(envNumber(\"ARB_NOTIONAL_USD\", minUsd), minUsd, maxUsdHardCap);\r\n\r\n    if (connectedVenues.length === 0) {\r\n      externalErrors.push({\r\n        error: \"no_exchange_connections\",\r\n        message: \"No exchange APIs connected yet. Scan uses public market data; connect an exchange API to unlock balance checks + execution readiness.\",\r\n      });\r\n    }\r\n\r\n    const includeInternalPrices = false; // external arb is external-only; internal-vs-index is computed separately.\r\n\r\n    const balancesEnabled = process.env.ARB_BALANCES_ENABLED !== \"0\";\r\n    const includeBalances = balancesEnabled && action === \"scan\" && connectedVenues.length > 0;\r\n    let venueBalances: Record<string, VenueBalanceSnapshot> | null = null;\r\n\r\n    const includeFees = envBool(\"ARB_FEES_ENABLED\", true) && action === \"scan\" && connectedVenues.length > 0;\r\n    let venueFees: Record<string, VenueFeeSnapshot> | null = null;\r\n\r\n    const includeDepth = envBool(\"ARB_DEPTH_ENABLED\", true) && action === \"scan\";\r\n    let depthMap: Map<DepthKey, ExchangeOrderBook> | null = null;\r\n\r\n    const includeConstraints = envBool(\"ARB_CONSTRAINTS_ENABLED\", true) && action === \"scan\";\r\n    let constraintsMap: Map<ConstraintKey, ExchangeMarketConstraints> | null = null;\r\n\r\n    let latest: ArbSnapshot[] = [];\r\n    let scanErrors: unknown[] = [];\r\n\r\n    if (action === \"scan\" && trackedSymbols.length > 0) {\r\n      const scan = await captureArbSnapshots(sql, {\r\n        exchanges: scanVenues,\r\n        symbols: trackedSymbols,\r\n        includeInternalPrices,\r\n        storeSnapshots: true,\r\n      });\r\n      latest = latestPerSymbolExchange(scan.snapshots);\r\n      scanErrors = scan.errors;\r\n\r\n      if (includeBalances) {\r\n        const creds = await getUserVenueCredentials(sql, actingUserId, connectedVenues);\r\n        const relevantAssets = [\r\n          \"USDT\",\r\n          ...cappedBases.map((b) => String(b).toUpperCase()),\r\n        ];\r\n        venueBalances = await fetchVenueBalances(connectedVenues, creds, relevantAssets);\r\n\r\n        // Fees (best-effort). Use BTCUSDT if available; otherwise first tracked symbol.\r\n        if (includeFees) {\r\n          const feeSymbol = trackedSymbols.includes(\"BTCUSDT\") ? \"BTCUSDT\" : trackedSymbols[0]!;\r\n          venueFees = await fetchVenueFees(connectedVenues, creds, feeSymbol);\r\n        }\r\n      }\r\n    } else {\r\n      const recent = await getRecentSnapshots(sql, undefined, 0.1);\r\n      const filtered = recent.filter((s) => scanVenues.includes(String(s.exchange).toLowerCase() as SupportedExchange));\r\n      latest = latestPerSymbolExchange(filtered);\r\n    }\r\n\r\n    // Precompute opps once (used for depth/constraints and final response).\r\n    const rawOppsAny = detectOpportunities(latest, {\r\n      minNetSpread: -100,\r\n      oppExchanges: scanVenues,\r\n      includeInternal: false,\r\n      quoteSuffix: \"USDT\",\r\n    });\r\n    const rawOpps = rawOppsAny.filter((o) => o.netSpreadPct >= -1.0);\r\n\r\n    // Depth (best-effort) for top opportunities only to avoid heavy API load.\r\n    if (includeDepth) {\r\n      const depthTopN = clamp(envNumber(\"ARB_DEPTH_TOP_N\", 15), 0, 100);\r\n      if (depthTopN > 0) {\r\n        const prelim = rawOppsAny.slice(0, depthTopN);\r\n\r\n        const pairs: Array<{ exchange: SupportedExchange; symbol: string }> = [];\r\n        for (const o of prelim) {\r\n          const buy = String(o.buyExchange).toLowerCase() as SupportedExchange;\r\n          const sell = String(o.sellExchange).toLowerCase() as SupportedExchange;\r\n          pairs.push({ exchange: buy, symbol: o.symbol });\r\n          pairs.push({ exchange: sell, symbol: o.symbol });\r\n        }\r\n        try {\r\n          depthMap = await fetchDepthForPairs(pairs);\r\n        } catch {\r\n          depthMap = null;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (includeConstraints) {\r\n      const topN = clamp(envNumber(\"ARB_CONSTRAINTS_TOP_N\", 60), 0, 500);\r\n      const target = topN > 0 ? rawOpps.slice(0, topN) : [];\r\n      const pairs: Array<{ exchange: SupportedExchange; symbol: string }> = [];\r\n      for (const o of target) {\r\n        pairs.push({ exchange: String(o.buyExchange).toLowerCase() as SupportedExchange, symbol: o.symbol });\r\n        pairs.push({ exchange: String(o.sellExchange).toLowerCase() as SupportedExchange, symbol: o.symbol });\r\n      }\r\n      try {\r\n        constraintsMap = await fetchConstraintsForPairs(pairs);\r\n      } catch {\r\n        constraintsMap = null;\r\n      }\r\n    }\r\n\r\n    const opportunities = rawOpps.map((o) => {\r\n      const effectiveNotionalUsd = notionalUsd;\r\n\r\n      const netProfitUsdTarget = (o.netSpreadPct / 100) * effectiveNotionalUsd;\r\n      const grossProfitUsdTarget = (o.spreadPct / 100) * effectiveNotionalUsd;\r\n\r\n      const base = parseBaseFromSymbol(o.symbol, \"USDT\");\r\n      const quantityTarget = base && o.buyAsk > 0 ? effectiveNotionalUsd / o.buyAsk : null;\r\n\r\n      const buyEx = String(o.buyExchange).toLowerCase();\r\n      const sellEx = String(o.sellExchange).toLowerCase();\r\n      const buyBal = venueBalances?.[buyEx];\r\n      const sellBal = venueBalances?.[sellEx];\r\n\r\n      let execution: {\r\n        status: \"ready\" | \"missing\" | \"unknown\";\r\n        blockers: string[];\r\n        required?: { usdtBuy: number; baseSell: number; base: string };\r\n        max?: { notionalUsd: number; baseSell: number; limitedBy: string[] };\r\n      } | null = null;\r\n\r\n      let execNotionalUsd = effectiveNotionalUsd;\r\n      let execQuantity = quantityTarget;\r\n      let limitedBy: string[] = [];\r\n\r\n      if (venueBalances) {\r\n        const blockers: string[] = [];\r\n        if (!base || !quantityTarget || !Number.isFinite(quantityTarget) || quantityTarget <= 0) {\r\n          blockers.push(\"invalid_quantity\");\r\n        }\r\n        if (!buyBal || !buyBal.ok) blockers.push(\"buy_balance_unavailable\");\r\n        if (!sellBal || !sellBal.ok) blockers.push(\"sell_balance_unavailable\");\r\n\r\n        if (base && quantityTarget && buyBal?.ok && sellBal?.ok) {\r\n          const usdtFree = buyBal.assets?.USDT?.free ?? 0;\r\n          const baseFree = sellBal.assets?.[base]?.free ?? 0;\r\n\r\n          const maxQtyByUsdt = o.buyAsk > 0 ? usdtFree / o.buyAsk : 0;\r\n          const maxQty = Math.max(0, Math.min(maxQtyByUsdt, baseFree));\r\n          const maxNotionalUsd = maxQty * (o.buyAsk > 0 ? o.buyAsk : 0);\r\n\r\n          if (usdtFree + 1e-9 < effectiveNotionalUsd) blockers.push(\"insufficient_usdt_on_buy\");\r\n          if (baseFree + 1e-12 < quantityTarget) blockers.push(\"insufficient_base_on_sell\");\r\n\r\n          if (Number.isFinite(maxNotionalUsd) && maxNotionalUsd > 0 && maxNotionalUsd + 1e-9 < effectiveNotionalUsd) {\r\n            execNotionalUsd = maxNotionalUsd;\r\n            execQuantity = maxQty;\r\n            if (maxQtyByUsdt + 1e-12 < baseFree) limitedBy.push(\"usdt\");\r\n            if (baseFree + 1e-12 < maxQtyByUsdt) limitedBy.push(\"base\");\r\n          }\r\n        }\r\n\r\n        const status = blockers.length === 0 ? \"ready\" : blockers.some((b) => b.includes(\"unavailable\")) ? \"unknown\" : \"missing\";\r\n        execution = {\r\n          status,\r\n          blockers,\r\n          ...(base && quantityTarget\r\n            ? { required: { usdtBuy: effectiveNotionalUsd, baseSell: quantityTarget, base } }\r\n            : {}),\r\n          ...(base && execQuantity && Number.isFinite(execNotionalUsd) && execNotionalUsd > 0\r\n            ? {\r\n                max: {\r\n                  notionalUsd: execNotionalUsd,\r\n                  baseSell: execQuantity,\r\n                  limitedBy,\r\n                },\r\n              }\r\n            : {}),\r\n        };\r\n      }\r\n\r\n      // Venue constraints (best-effort): apply precision quantization + min amount/cost enforcement.\r\n      const constraintBlockers: string[] = [];\r\n      const buyC = constraintsMap?.get(constraintKey(buyEx, o.symbol)) ?? null;\r\n      const sellC = constraintsMap?.get(constraintKey(sellEx, o.symbol)) ?? null;\r\n\r\n      if (includeConstraints) {\r\n        if (buyC && !buyC.ok) constraintBlockers.push(\"symbol_unavailable_buy\");\r\n        if (sellC && !sellC.ok) constraintBlockers.push(\"symbol_unavailable_sell\");\r\n\r\n        if (base && execNotionalUsd > 0 && o.buyAsk > 0) {\r\n          const desiredQty = execNotionalUsd / o.buyAsk;\r\n          const buyPrec = buyC?.ok ? buyC.amountPrecision : null;\r\n          const sellPrec = sellC?.ok ? sellC.amountPrecision : null;\r\n          const qtyPrecision = buyPrec === null ? sellPrec : sellPrec === null ? buyPrec : Math.min(buyPrec, sellPrec);\r\n          const qty = floorToPrecision(desiredQty, qtyPrecision ?? null);\r\n          if (qty > 0 && execQuantity && Number.isFinite(execQuantity) && qty + 1e-12 < execQuantity) {\r\n            limitedBy = Array.from(new Set([...limitedBy, \"precision\"]));\r\n          }\r\n          execQuantity = qty > 0 ? qty : execQuantity;\r\n          execNotionalUsd = execQuantity && o.buyAsk > 0 ? execQuantity * o.buyAsk : execNotionalUsd;\r\n\r\n          // Min checks (only when we have concrete values)\r\n          if (buyC?.ok && typeof buyC.amountMin === \"number\" && execQuantity && execQuantity > 0 && execQuantity < buyC.amountMin) {\r\n            constraintBlockers.push(\"min_amount_buy\");\r\n          }\r\n          if (sellC?.ok && typeof sellC.amountMin === \"number\" && execQuantity && execQuantity > 0 && execQuantity < sellC.amountMin) {\r\n            constraintBlockers.push(\"min_amount_sell\");\r\n          }\r\n          if (buyC?.ok && typeof buyC.costMin === \"number\" && execNotionalUsd > 0 && execNotionalUsd < buyC.costMin) {\r\n            constraintBlockers.push(\"min_notional_buy\");\r\n          }\r\n          const sellQuote = execQuantity && execQuantity > 0 ? execQuantity * o.sellBid : 0;\r\n          if (sellC?.ok && typeof sellC.costMin === \"number\" && sellQuote > 0 && sellQuote < sellC.costMin) {\r\n            constraintBlockers.push(\"min_notional_sell\");\r\n          }\r\n        }\r\n\r\n        if (execution && constraintBlockers.length > 0) {\r\n          execution.status = \"missing\";\r\n          execution.blockers = Array.from(new Set([...(execution.blockers ?? []), ...constraintBlockers]));\r\n          if (execution.max) {\r\n            execution.max.limitedBy = Array.from(new Set([...(execution.max.limitedBy ?? []), \"constraints\"]));\r\n          }\r\n        }\r\n\r\n        // If constraints are known and blockers exist, drop the route (strict realism).\r\n        if (constraintBlockers.length > 0) {\r\n          return null;\r\n        }\r\n      }\r\n\r\n      // Per-venue taker fees (fraction) with fallbacks.\r\n      const fallbackTakerBps = Math.max(0, envNumber(\"ARB_TAKER_FEE_BPS\", 10));\r\n      const buyTaker = venueFees?.[buyEx]?.ok && typeof venueFees?.[buyEx]?.taker === \"number\"\r\n        ? (venueFees![buyEx]!.taker as number)\r\n        : fallbackTakerBps / 10_000;\r\n      const sellTaker = venueFees?.[sellEx]?.ok && typeof venueFees?.[sellEx]?.taker === \"number\"\r\n        ? (venueFees![sellEx]!.taker as number)\r\n        : fallbackTakerBps / 10_000;\r\n\r\n      const latencyBps = Math.max(0, envNumber(\"ARB_LATENCY_BPS\", 2));\r\n      const feePct = (buyTaker + sellTaker) * 100;\r\n      const latencyPct = pctFromBps(latencyBps);\r\n\r\n      // Depth-adjusted execution (VWAP) for execNotional if available.\r\n      let depth: any = null;\r\n      let netSpreadDepthPct: number | null = null;\r\n      let netProfitDepthUsd: number | null = null;\r\n\r\n      if (depthMap && base && Number.isFinite(execNotionalUsd) && execNotionalUsd > 0) {\r\n        const buyOb = depthMap.get(depthKey(buyEx, o.symbol));\r\n        const sellOb = depthMap.get(depthKey(sellEx, o.symbol));\r\n        if (buyOb && sellOb && buyOb.asks.length && sellOb.bids.length) {\r\n          const buy = vwapBuyForQuoteNotional(buyOb.asks, execNotionalUsd);\r\n          if (buy && buy.baseFilled > 0) {\r\n            const sell = vwapSellForBaseAmount(sellOb.bids, buy.baseFilled);\r\n            if (sell && sell.quoteReceived > 0) {\r\n              const grossSpreadPctDepth = ((sell.vwap - buy.vwap) / buy.vwap) * 100;\r\n              netSpreadDepthPct = grossSpreadPctDepth - feePct - latencyPct;\r\n              netProfitDepthUsd = (netSpreadDepthPct / 100) * execNotionalUsd;\r\n              depth = {\r\n                buyVwap: buy.vwap,\r\n                sellVwap: sell.vwap,\r\n                buySlippageBps: buy.slippageBps,\r\n                sellSlippageBps: sell.slippageBps,\r\n              };\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return {\r\n        ...o,\r\n        // Existing fields are “per $1000”; add “for your notional”.\r\n        notionalUsd: effectiveNotionalUsd,\r\n        execNotionalUsd: Math.round(execNotionalUsd * 100) / 100,\r\n        grossProfitUsd: Math.round(grossProfitUsdTarget * 100) / 100,\r\n        netProfitUsd: Math.round(netProfitUsdTarget * 100) / 100,\r\n        grossProfitExecUsd: Math.round(((o.spreadPct / 100) * execNotionalUsd) * 100) / 100,\r\n        netProfitExecUsd: Math.round((((netSpreadDepthPct ?? o.netSpreadPct) / 100) * execNotionalUsd) * 100) / 100,\r\n        fee: {\r\n          buyTaker,\r\n          sellTaker,\r\n          feePct,\r\n          sourceBuy: venueFees?.[buyEx]?.source ?? \"fallback\",\r\n          sourceSell: venueFees?.[sellEx]?.source ?? \"fallback\",\r\n        },\r\n        constraints: includeConstraints\r\n          ? {\r\n              buy: buyC ? { ok: buyC.ok, amountMin: buyC.amountMin, costMin: buyC.costMin, amountPrecision: buyC.amountPrecision } : null,\r\n              sell: sellC ? { ok: sellC.ok, amountMin: sellC.amountMin, costMin: sellC.costMin, amountPrecision: sellC.amountPrecision } : null,\r\n            }\r\n          : null,\r\n        depth,\r\n        netSpreadDepthPct: netSpreadDepthPct !== null ? Math.round(netSpreadDepthPct * 10000) / 10000 : null,\r\n        execution,\r\n        readiness: (() => {\r\n          const reasons = new Set<string>();\r\n          if (!INTERNAL_SETTLEMENT_ENABLED && connectedVenues.length === 0) reasons.add(\"connect_exchange_api\");\r\n          if (execution?.status === \"missing\") {\r\n            for (const b of execution.blockers ?? []) reasons.add(String(b));\r\n          }\r\n          if (execution?.status === \"unknown\") reasons.add(\"execution_data_unavailable\");\r\n\r\n          const netExecSpread = netSpreadDepthPct ?? o.netSpreadPct;\r\n          const profitableNow = Number.isFinite(netExecSpread) && netExecSpread > 0;\r\n\r\n          const windowSecs = clamp(envNumber(\"ARB_ACTION_WINDOW_SECS\", 90), 15, 600);\r\n          const windowBucket = Math.floor(Date.now() / 1000 / windowSecs);\r\n          const baseChance = clamp(envNumber(\"ARB_ACTIONABLE_BASE_PCT\", 18), 1, 95) / 100;\r\n          const spreadBoost = Math.max(0, Math.min(0.45, (netExecSpread - 0.1) * 0.12));\r\n          const openChance = Math.min(0.9, baseChance + spreadBoost);\r\n          const windowRoll = hashUnit(`${actingUserId}:${o.symbol}:${buyEx}:${sellEx}:${windowBucket}`);\r\n          const windowOpen = windowRoll < openChance;\r\n\r\n          if (profitableNow && !windowOpen) reasons.add(\"execution_window_closed\");\r\n\r\n          const canExecute = INTERNAL_SETTLEMENT_ENABLED\r\n            ? profitableNow && windowOpen && reasons.size === 0\r\n            : execution?.status === \"ready\" && reasons.size === 0 && profitableNow;\r\n\r\n          const state: \"discoverable\" | \"action_required\" | \"executable\" = canExecute\r\n            ? \"executable\"\r\n            : reasons.size > 0\r\n              ? \"action_required\"\r\n              : \"discoverable\";\r\n\r\n          return {\r\n            state,\r\n            canExecute,\r\n            reasons: Array.from(reasons),\r\n          };\r\n        })(),\r\n      };\r\n    }).filter((v): v is NonNullable<typeof v> => Boolean(v));\r\n\r\n    // Price map for transparency.\r\n    const priceMap: Record<string, Record<string, { bid: string; ask: string; ts: string }>> = {};\r\n    for (const s of latest) {\r\n      if (!priceMap[s.symbol]) priceMap[s.symbol] = {};\r\n      priceMap[s.symbol]![s.exchange] = { bid: s.bid, ask: s.ask, ts: s.ts.toISOString() };\r\n    }\r\n\r\n    // Internal-vs-external index: compare internal base/USDT mid vs external index in USDT.\r\n    const maxIndexBases = clamp(envNumber(\"ARB_INDEX_MAX_BASES\", 12), 1, 50);\r\n    const indexBases = prioritizedCap(enabledBases, (b) => basePriority(String(b)), maxIndexBases);\r\n\r\n    const internal = await getInternalUsdtMarkets(sql, indexBases);\r\n\r\n    const minDevPct = Math.max(0, envNumber(\"ARB_INDEX_MIN_DEV_PCT\", 0.25));\r\n\r\n    const indexOpps = await Promise.all(\r\n      internal.map(async (m) => {\r\n        try {\r\n          const idx = await getExternalIndexUsdt(m.base);\r\n          if (!idx || !Number.isFinite(idx.mid) || idx.mid <= 0) return null;\r\n          const devPct = ((m.mid - idx.mid) / idx.mid) * 100;\r\n\r\n          const direction = devPct >= minDevPct\r\n            ? \"sell_internal_buy_external\"\r\n            : devPct <= -minDevPct\r\n              ? \"buy_internal_sell_external\"\r\n              : \"none\";\r\n\r\n          return {\r\n            base: m.base,\r\n            internalSymbol: m.symbol,\r\n            internalBidUsdt: m.bid,\r\n            internalAskUsdt: m.ask,\r\n            internalMidUsdt: m.mid,\r\n            externalIndexUsdt: idx.mid,\r\n            indexSourcesUsed: idx.sourcesUsed,\r\n            indexSources: (idx.sources || []).map((s) => ({\r\n              exchange: s.exchange,\r\n              mid: s.mid,\r\n              ts: s.ts,\r\n              error: s.error,\r\n            })),\r\n            dispersionBps: idx.dispersionBps,\r\n            deviationPct: Math.round(devPct * 10000) / 10000,\r\n            direction,\r\n            ts: new Date().toISOString(),\r\n          };\r\n        } catch {\r\n          return null;\r\n        }\r\n      }),\r\n    );\r\n\r\n    const index = indexOpps.filter((v): v is NonNullable<typeof v> => Boolean(v));\r\n\r\n    return NextResponse.json({\r\n      ts: new Date().toISOString(),\r\n      action,\r\n      venues: {\r\n        connected: connectedVenues,\r\n        scanned: scanVenues,\r\n        mode: connectedVenues.length > 0 ? \"connected\" : \"public\",\r\n      },\r\n      gates: {\r\n        api: {\r\n          ok: connectedVenues.length > 0,\r\n          connectedCount: connectedVenues.length,\r\n        },\r\n      },\r\n      symbols: {\r\n        enabledCount: enabledBases.length,\r\n        scanned: trackedSymbols,\r\n        scannedCount: trackedSymbols.length,\r\n        maxSymbols,\r\n      },\r\n      sizing: {\r\n        minUsd,\r\n        notionalUsd,\r\n        capUsd: maxUsdHardCap,\r\n      },\r\n      external: {\r\n        banner: connectedVenues.length === 0\r\n          ? { tone: \"warning\", code: \"no_exchange_connections\", message: externalErrors.find((e) => e.error === \"no_exchange_connections\")?.message ?? \"Connect an exchange API\" }\r\n          : null,\r\n        opportunities,\r\n        prices: priceMap,\r\n        balances: venueBalances,\r\n        balancesIncluded: Boolean(venueBalances),\r\n        fees: venueFees,\r\n        depthIncluded: Boolean(depthMap),\r\n        constraintsIncluded: Boolean(constraintsMap),\r\n        errors: action === \"scan\" ? [...externalErrors, ...(scanErrors as any[])] : externalErrors,\r\n      },\r\n      index: {\r\n        minDevPct,\r\n        opportunities: index,\r\n      },\r\n    });\r\n  } catch (e) {\r\n    const resp = responseForDbError(\"exchange.arbitrage.overview\", e);\r\n    if (resp) return resp;\r\n    console.error(\"[arb.overview] error\", e);\r\n    return NextResponse.json({ error: \"internal_error\" }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","ignoreList":[0]}