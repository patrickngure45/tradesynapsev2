module.exports=[481750,e=>{"use strict";var t=e.i(747909),i=e.i(174017),a=e.i(996250),r=e.i(759756),n=e.i(561916),o=e.i(174677),s=e.i(869741),d=e.i(316795),u=e.i(487718),l=e.i(995169),c=e.i(47587),_=e.i(666012),p=e.i(570101),m=e.i(626937),f=e.i(10372),E=e.i(193695);e.i(52474);var w=e.i(600220),g=e.i(89171),h=e.i(843793),b=e.i(666680),y=e.i(361179),N=e.i(24672),S=e.i(784756),x=e.i(194748);async function T(e,t){let{order:i}=t;if("limit"!==i.type||!i.price)return[];let a=await (0,S.getActiveSubscriptionsForLeader)(e,i.user_id);if(0===a.length)return[];let r=[];for(let t of a){let a=parseFloat(t.copy_ratio)||1,n=Math.min(parseFloat(i.original_quantity)*a,t.max_per_trade?parseFloat(t.max_per_trade):1/0);if(n<=0){r.push({follower_user_id:t.follower_user_id,success:!1,error:"zero_quantity"});continue}let o=n.toFixed(18);try{let s=await e.begin(async e=>{let r=await e`
          SELECT id, base_asset_id::text, quote_asset_id::text, symbol
          FROM ex_market WHERE id = ${i.market_id} AND status = 'active'
          LIMIT 1
        `;if(0===r.length)return{success:!1,error:"market_not_found"};let n=r[0],s="buy"===i.side?n.quote_asset_id:n.base_asset_id,d=await e`
          SELECT
            (COALESCE(
              (SELECT sum(jl.amount) FROM ex_journal_line jl WHERE jl.account_id = la.id AND jl.asset_id = ${s}),
              0
            ) - COALESCE(
              (SELECT sum(h.remaining_amount) FROM ex_hold h WHERE h.account_id = la.id AND h.asset_id = ${s} AND h.status = 'active'),
              0
            ))::text AS available
          FROM ex_ledger_account la
          WHERE la.user_id = ${t.follower_user_id}::uuid AND la.asset_id = ${s}::uuid
        `;if(0===d.length||0>=parseFloat(d[0].available))return{success:!1,error:"insufficient_balance"};let u=await e`
          INSERT INTO ex_order (
            user_id, market_id, side, type, price, original_quantity,
            remaining_quantity, status, time_in_force, metadata_json
          ) VALUES (
            ${t.follower_user_id}::uuid, ${i.market_id}::uuid,
            ${i.side}, 'limit', ${i.price}::numeric, ${o}::numeric,
            ${o}::numeric, 'open', 'GTC',
            ${JSON.stringify({copied_from_order:i.id,leader_user_id:i.user_id,copy_ratio:a})}::jsonb
          )
          RETURNING id
        `;if(0===u.length)return{success:!1,error:"insert_failed"};let l="buy"===i.side?(parseFloat(o)*parseFloat(i.price)).toFixed(18):o,c=await e`
          SELECT id FROM ex_ledger_account
          WHERE user_id = ${t.follower_user_id}::uuid AND asset_id = ${s}::uuid
          LIMIT 1
        `;return c.length>0&&await e`
            INSERT INTO ex_hold (account_id, asset_id, amount, remaining_amount, reason, status)
            VALUES (
              ${c[0].id}, ${s}::uuid, ${l}::numeric,
              ${l}::numeric, ${"order:"+u[0].id}, 'active'
            )
          `,{success:!0,order_id:u[0].id}});r.push({follower_user_id:t.follower_user_id,...s}),s.success?await (0,x.createNotification)(e,{userId:t.follower_user_id,type:"order_filled",title:"Copy Trade Placed",body:`Copied ${i.side} order: ${n} at ${i.price} (from leader)`,metadata:{copied_order_id:s.order_id,leader_order_id:i.id,copy_ratio:a}}):"insufficient_balance"===s.error&&await (0,x.createNotification)(e,{userId:t.follower_user_id,type:"system",title:"Copy Trade Skipped",body:`Insufficient balance to copy ${i.side} order (${n} at ${i.price})`,metadata:{leader_order_id:i.id,reason:"insufficient_balance"}})}catch(i){let e=i instanceof Error?i.message:String(i);r.push({follower_user_id:t.follower_user_id,success:!1,error:e})}}return r}var R=e.i(844297),A=e.i(29984);function v(e){let t="number"==typeof e?e:Number(e);return Number.isFinite(t)?t:NaN}function $(e,t){let i=process.env[e];if(!i)return t;let a=Number(i);return Number.isFinite(a)?a:t}function O(){return new Date().toISOString()}async function D(e,t){let i=t.executionId,[a]=await e`
    SELECT id, user_id, kind, status, signal_id, exchange, symbol, amount_usd::text, leverage::text, params_json, result_json
    FROM trading_bot_execution
    WHERE id = ${i}::uuid
    LIMIT 1
  `;if(a&&"queued"===a.status){await e`
    UPDATE trading_bot_execution
    SET status = 'running', started_at = now(), error = NULL
    WHERE id = ${i}::uuid
  `;try{var r;let t=(r=a.params_json)&&"object"==typeof r&&!Array.isArray(r)&&"live"===r.mode?"live":"simulation";if("live"===t&&"1"!==process.env.TRADING_LIVE_ENABLED)return void await e`
          UPDATE trading_bot_execution
          SET status = 'failed', finished_at = now(), error = 'Live trading requested but TRADING_LIVE_ENABLED is not set.',
              result_json = ${JSON.stringify({mode:t,note:"No orders were placed."})}::jsonb
          WHERE id = ${i}::uuid
        `;let n=String(a.exchange??""),o=String(a.symbol??""),s=Number(a.amount_usd??"0");if(!n)throw Error("Missing exchange on execution");let[d]=await e`
      SELECT api_key_enc, api_secret_enc, passphrase_enc
      FROM user_exchange_connection
      WHERE user_id = ${a.user_id}::uuid
        AND exchange = ${n}
        AND status = 'active'
      ORDER BY created_at DESC
      LIMIT 1
    `;if(!d)return void await e`
        UPDATE trading_bot_execution
        SET status = 'failed', finished_at = now(), error = ${`No active ${n} connection`}
        WHERE id = ${i}::uuid
      `;let u=(0,R.decryptCredential)(d.api_key_enc),l=(0,R.decryptCredential)(d.api_secret_enc),c=d.passphrase_enc?(0,R.decryptCredential)(d.passphrase_enc):void 0,_=(0,A.getAuthenticatedExchangeClientWithType)(n,{apiKey:u,apiSecret:l,passphrase:c},{defaultType:"spot"}),p=await _.fetchBalance(),m=v(p?.USDT?.free??0);if(s>0&&(!Number.isFinite(m)||m<s))return void await e`
        UPDATE trading_bot_execution
        SET
          status = 'failed',
          finished_at = now(),
          error = ${`Insufficient USDT balance (free=${m}, required=${s})`},
          result_json = ${JSON.stringify({mode:"simulation",checks:{usdtFree:m,requiredUsd:s},exchange:n,symbol:o})}::jsonb
        WHERE id = ${i}::uuid
      `;if("simulation"===t)return void await e`
        UPDATE trading_bot_execution
        SET
          status = 'succeeded',
          finished_at = now(),
          error = NULL,
          result_json = ${JSON.stringify({mode:"simulation",checks:{usdtFree:m,requiredUsd:s},exchange:n,symbol:o,note:"Simulation-only: no orders were placed."})}::jsonb
        WHERE id = ${i}::uuid
      `;let f=new Set((process.env.TRADING_LIVE_ALLOWED_EXCHANGES??"").split(/[,\n]/g).map(e=>e.trim().toLowerCase()).filter(Boolean));if(f.size>0&&!f.has(n.toLowerCase()))return void await e`
        UPDATE trading_bot_execution
        SET status = 'failed', finished_at = now(), error = ${`Live trading not allowed for exchange=${n}`},
            result_json = ${JSON.stringify({mode:t,exchange:n,note:"No orders were placed."})}::jsonb
        WHERE id = ${i}::uuid
      `;if("binance"!==n.toLowerCase())return void await e`
        UPDATE trading_bot_execution
        SET status = 'failed', finished_at = now(), error = ${`Live trading is only implemented for Binance right now (got ${n}).`},
            result_json = ${JSON.stringify({mode:t,exchange:n,note:"No orders were placed."})}::jsonb
        WHERE id = ${i}::uuid
      `;if(!o)throw Error("Missing symbol on execution");let E=Math.max(1,Math.min(10,Number(a.leverage??"1")||1)),w=s>0?s/2:0;if(w<=0)throw Error("Invalid amount_usd");let g=o.includes(":")?o.split(":")[0]:o,h=(0,A.getAuthenticatedExchangeClientWithType)("binance",{apiKey:u,apiSecret:l,passphrase:c},{defaultType:"spot"}),b=(0,A.getAuthenticatedExchangeClientWithType)("binance",{apiKey:u,apiSecret:l,passphrase:c},{defaultType:"swap"}),y=null,N=null,S=null;try{"function"==typeof h.loadMarkets&&await h.loadMarkets(),"function"==typeof b.loadMarkets&&await b.loadMarkets();let t=Math.max(1,Math.floor($("TRADING_SIGNAL_MAX_AGE_MIN",30))),r=Math.max(0,$("TRADING_MAX_ENTRY_BASIS_PCT",1)),d=null;if(a.signal_id){let[s]=await e`
          SELECT id, kind, payload_json, created_at
          FROM app_signal
          WHERE id = ${a.signal_id}::uuid
          LIMIT 1
        `;if(s){let a=new Date(s.created_at),u=(Date.now()-a.getTime())/6e4;if(d={id:String(s.id),kind:String(s.kind),createdAt:a.toISOString(),ageMin:Number.isFinite(u)?Number(u.toFixed(2)):null,exchange:s.payload_json?.exchange,symbol:s.payload_json?.symbol,fundingRate:s.payload_json?.fundingRate},Number.isFinite(u)&&u>t)return void await e`
              UPDATE trading_bot_execution
              SET status = 'failed', finished_at = now(),
                  error = ${`Signal too old (${u.toFixed(1)} min > ${t} min). Re-scan funding rates.`},
                  result_json = ${JSON.stringify({mode:"live",exchange:n,symbol:o,spotSymbol:g,leverage:E,legUsd:w,preflight:{at:O(),maxSignalAgeMin:t,maxBasisPct:r,signal:d},note:"No orders were placed."})}::jsonb
              WHERE id = ${i}::uuid
            `;let l=v(d.fundingRate);if(Number.isFinite(l)&&l<=0)return void await e`
              UPDATE trading_bot_execution
              SET status = 'failed', finished_at = now(),
                  error = 'Funding is not positive; cash & carry is not eligible right now.',
                  result_json = ${JSON.stringify({mode:"live",exchange:n,symbol:o,spotSymbol:g,leverage:E,legUsd:w,preflight:{at:O(),maxSignalAgeMin:t,maxBasisPct:r,signal:d},note:"No orders were placed."})}::jsonb
              WHERE id = ${i}::uuid
            `}}let u=await h.fetchTicker(g),l=await b.fetchTicker(o),c=v(u?.ask??u?.last),_=v(l?.bid??l?.last),p=Number.isFinite(c)&&c>0&&Number.isFinite(_)?(_/c-1)*100:NaN,f=h?.markets?.[g],S=b?.markets?.[o],x=v(f?.limits?.cost?.min),T=v(f?.limits?.amount?.min),R=v(S?.limits?.amount?.min),A=Number.isFinite(c)&&c>0?w/c:NaN,D=Number.isFinite(A)&&"function"==typeof h.amountToPrecision?v(h.amountToPrecision(g,A)):A,I={at:O(),maxSignalAgeMin:t,maxBasisPct:r,prices:{spotAsk:c,perpBid:_,basisPct:p},limits:{spotMinCost:Number.isFinite(x)?x:null,spotMinAmount:Number.isFinite(T)?T:null,swapMinAmount:Number.isFinite(R)?R:null},sizing:{legUsd:w,expectedQty:D},signal:d};if(!Number.isFinite(c)||c<=0)return void await e`
          UPDATE trading_bot_execution
          SET status = 'failed', finished_at = now(),
              error = 'Preflight failed: could not fetch spot ask price.',
              result_json = ${JSON.stringify({mode:"live",exchange:n,symbol:o,spotSymbol:g,leverage:E,legUsd:w,preflight:I,note:"No orders were placed."})}::jsonb
          WHERE id = ${i}::uuid
        `;if(Number.isFinite(x)&&w<x)return void await e`
          UPDATE trading_bot_execution
          SET status = 'failed', finished_at = now(),
              error = ${`Preflight failed: leg USD amount below min notional (legUsd=${w}, minCost=${x}).`},
              result_json = ${JSON.stringify({mode:"live",exchange:n,symbol:o,spotSymbol:g,leverage:E,legUsd:w,preflight:I,note:"No orders were placed."})}::jsonb
          WHERE id = ${i}::uuid
        `;if(Number.isFinite(T)&&Number.isFinite(D)&&D>0&&D<T)return void await e`
          UPDATE trading_bot_execution
          SET status = 'failed', finished_at = now(),
              error = ${`Preflight failed: spot qty below min (qty=${D}, min=${T}).`},
              result_json = ${JSON.stringify({mode:"live",exchange:n,symbol:o,spotSymbol:g,leverage:E,legUsd:w,preflight:I,note:"No orders were placed."})}::jsonb
          WHERE id = ${i}::uuid
        `;if(Number.isFinite(R)&&Number.isFinite(D)&&D>0&&D<R)return void await e`
          UPDATE trading_bot_execution
          SET status = 'failed', finished_at = now(),
              error = ${`Preflight failed: perp qty below min (qty=${D}, min=${R}).`},
              result_json = ${JSON.stringify({mode:"live",exchange:n,symbol:o,spotSymbol:g,leverage:E,legUsd:w,preflight:I,note:"No orders were placed."})}::jsonb
          WHERE id = ${i}::uuid
        `;if(Number.isFinite(p)&&p>r)return void await e`
          UPDATE trading_bot_execution
          SET status = 'failed', finished_at = now(),
              error = ${`Preflight failed: perp premium too high (basis=${p.toFixed(3)}% > max=${r}%).`},
              result_json = ${JSON.stringify({mode:"live",exchange:n,symbol:o,spotSymbol:g,leverage:E,legUsd:w,preflight:I,note:"No orders were placed."})}::jsonb
          WHERE id = ${i}::uuid
        `;let M=null;try{y=await h.createOrder(g,"market","buy",void 0,void 0,{quoteOrderQty:w})}catch(i){let e=await h.fetchTicker(g),t=v(e?.ask??e?.last);if(!Number.isFinite(t)||t<=0)throw i;M=w/t,"function"==typeof h.amountToPrecision&&(M=Number(h.amountToPrecision(g,M))),y=await h.createOrder(g,"market","buy",M)}let C=v(y?.filled??NaN),k=v(y?.amount??NaN),j=Number.isFinite(C)&&C>0?C:Number.isFinite(k)&&k>0?k:M??NaN;if(!Number.isFinite(j)||j<=0)throw Error("Spot order did not return a filled/amount quantity");if("function"==typeof b.setMarginMode)try{await b.setMarginMode("isolated",o)}catch{}if("function"==typeof b.setLeverage)try{await b.setLeverage(E,o)}catch{}N=await b.createOrder(o,"market","sell",j,void 0,{reduceOnly:!1}),await e`
        UPDATE trading_bot_execution
        SET
          status = 'succeeded',
          finished_at = now(),
          error = NULL,
          result_json = ${JSON.stringify({mode:"live",exchange:n,symbol:o,spotSymbol:g,leverage:E,legUsd:w,preflight:I,checks:{usdtFree:m,requiredUsd:s},spotOrder:{id:y?.id??y?.orderId,filled:y?.filled,amount:y?.amount,cost:y?.cost,status:y?.status},perpOrder:{id:N?.id??N?.orderId,filled:N?.filled,amount:N?.amount,cost:N?.cost,status:N?.status},note:"Live execution placed 2 market orders (spot buy + perp sell)."})}::jsonb
        WHERE id = ${i}::uuid
      `}catch(a){let t=a instanceof Error?a.message:String(a);try{if(y&&!N){let e=v(y?.filled??y?.amount??NaN);Number.isFinite(e)&&e>0&&(S=await h.createOrder(g,"market","sell",e))}}catch{}await e`
        UPDATE trading_bot_execution
        SET
          status = 'failed',
          finished_at = now(),
          error = ${t},
          result_json = ${JSON.stringify({mode:"live",exchange:n,symbol:o,spotSymbol:g,leverage:E,legUsd:w,spotOrder:y?{id:y?.id??y?.orderId,status:y?.status}:null,perpOrder:N?{id:N?.id??N?.orderId,status:N?.status}:null,unwindOrder:S?{id:S?.id??S?.orderId,status:S?.status}:null,note:y&&!N?"Perp leg failed; attempted best-effort spot unwind.":"Execution failed."})}::jsonb
        WHERE id = ${i}::uuid
      `}}catch(a){let t=a instanceof Error?a.message:String(a);await e`
      UPDATE trading_bot_execution
      SET status = 'failed', finished_at = now(), error = ${t}
      WHERE id = ${i}::uuid
    `}}}function I(e){let t="number"==typeof e?e:Number(e);return Number.isFinite(t)?t:NaN}function M(){return new Date().toISOString()}async function C(e,t){try{if("function"==typeof e.fetchPosition){let i=await e.fetchPosition(t),a=I(i?.contracts??i?.amount??i?.info?.positionAmt);if(Number.isFinite(a)&&a<0)return Math.abs(a);let r=String(i?.side??"").toLowerCase(),n=I(i?.contracts??i?.amount);if("short"===r&&Number.isFinite(n)&&n>0)return n}if("function"==typeof e.fetchPositions){let i=await e.fetchPositions([t]),a=Array.isArray(i)?i[0]:null,r=I(a?.contracts??a?.amount??a?.info?.positionAmt);if(Number.isFinite(r)&&r<0)return Math.abs(r);let n=String(a?.side??"").toLowerCase(),o=I(a?.contracts??a?.amount);if("short"===n&&Number.isFinite(o)&&o>0)return o}}catch{}return null}async function k(e,t){var i;let a=t.executionId,[r]=await e`
    SELECT id, user_id, status, exchange, symbol, params_json, result_json
    FROM trading_bot_execution
    WHERE id = ${a}::uuid
    LIMIT 1
  `;if(!r||"cancel_requested"!==r.status&&"unwinding"!==r.status)return;if("unwinding"!==r.status&&await e`
      UPDATE trading_bot_execution
      SET status = 'unwinding', error = NULL,
          result_json = jsonb_set(result_json, '{unwind}', ${JSON.stringify({at:M(),stage:"starting"})}::jsonb, true)
      WHERE id = ${a}::uuid
    `,"simulation"==((i=r.params_json)&&"object"==typeof i&&!Array.isArray(i)&&"live"===i.mode?"live":"simulation"))return void await e`
      UPDATE trading_bot_execution
      SET status = 'canceled', finished_at = now(), error = NULL,
          result_json = jsonb_set(result_json, '{unwind}', ${JSON.stringify({at:M(),stage:"done",note:"Simulation canceled."})}::jsonb, true)
      WHERE id = ${a}::uuid
    `;let n=String(r.exchange??"").toLowerCase(),o=String(r.symbol??""),s=o.includes(":")?o.split(":")[0]:o;if(!n||!o)return void await e`
      UPDATE trading_bot_execution
      SET status = 'failed', finished_at = now(),
          error = 'Unwind failed: missing exchange or symbol on execution.',
          result_json = jsonb_set(result_json, '{unwind}', ${JSON.stringify({at:M(),stage:"failed",note:"No orders were placed."})}::jsonb, true)
      WHERE id = ${a}::uuid
    `;if("binance"!==n)return void await e`
      UPDATE trading_bot_execution
      SET status = 'failed', finished_at = now(),
          error = ${`Unwind is only implemented for Binance right now (got ${n}).`},
          result_json = jsonb_set(result_json, '{unwind}', ${JSON.stringify({at:M(),stage:"failed"})}::jsonb, true)
      WHERE id = ${a}::uuid
    `;let[d]=await e`
    SELECT api_key_enc, api_secret_enc, passphrase_enc
    FROM user_exchange_connection
    WHERE user_id = ${r.user_id}::uuid
      AND exchange = ${n}
      AND status = 'active'
    ORDER BY created_at DESC
    LIMIT 1
  `;if(!d)return void await e`
      UPDATE trading_bot_execution
      SET status = 'failed', finished_at = now(),
          error = ${`Unwind failed: no active ${n} connection.`},
          result_json = jsonb_set(result_json, '{unwind}', ${JSON.stringify({at:M(),stage:"failed",note:"Manual intervention may be required."})}::jsonb, true)
      WHERE id = ${a}::uuid
    `;let u=(0,R.decryptCredential)(d.api_key_enc),l=(0,R.decryptCredential)(d.api_secret_enc),c=d.passphrase_enc?(0,R.decryptCredential)(d.passphrase_enc):void 0,_=(0,A.getAuthenticatedExchangeClientWithType)("binance",{apiKey:u,apiSecret:l,passphrase:c},{defaultType:"spot"}),p=(0,A.getAuthenticatedExchangeClientWithType)("binance",{apiKey:u,apiSecret:l,passphrase:c},{defaultType:"swap"}),m=null,f=null,E=[];try{"function"==typeof _.loadMarkets&&await _.loadMarkets(),"function"==typeof p.loadMarkets&&await p.loadMarkets();let t=r.result_json&&"object"==typeof r.result_json?r.result_json:{},i=I(t?.perpOrder?.filled??t?.perpOrder?.amount),d=await C(p,o),u="number"==typeof d&&Number.isFinite(d)&&d>0?d:Number.isFinite(i)&&i>0?i:NaN;Number.isFinite(u)&&u>0?m=await p.createOrder(o,"market","buy",u,void 0,{reduceOnly:!0}):E.push("Could not determine perp position size; skipped perp close.");let l=s.split("/")[0]??"",c=await _.fetchBalance(),w=I(c?.[l]?.free??0),g=I(t?.spotOrder?.filled??t?.spotOrder?.amount);if(l)if(!Number.isFinite(w)||w<=0)E.push(`No free ${l} balance found; skipped spot sell.`);else if(!Number.isFinite(g)||g<=0)E.push("Missing executed spot qty; skipped spot sell to avoid liquidating unrelated holdings.");else{let e=Math.min(w,g);e>0?f=await _.createOrder(s,"market","sell",e):E.push("Computed spot sell qty was 0; skipped.")}else E.push("Could not determine spot base asset; skipped spot sell.");await e`
      UPDATE trading_bot_execution
      SET status = 'canceled', finished_at = now(), error = NULL,
          result_json = jsonb_set(
            result_json,
            '{unwind}',
            ${JSON.stringify({at:M(),stage:"done",exchange:n,symbol:o,spotSymbol:s,closePerpOrder:m?{id:m?.id??m?.orderId,status:m?.status,filled:m?.filled,amount:m?.amount}:null,sellSpotOrder:f?{id:f?.id??f?.orderId,status:f?.status,filled:f?.filled,amount:f?.amount}:null,warnings:E})}::jsonb,
            true
          )
      WHERE id = ${a}::uuid
    `}catch(i){let t=i instanceof Error?i.message:String(i);await e`
      UPDATE trading_bot_execution
      SET status = 'failed', finished_at = now(),
          error = ${`Unwind failed: ${t}`},
          result_json = jsonb_set(result_json, '{unwind}', ${JSON.stringify({at:M(),stage:"failed",error:t,warnings:E})}::jsonb, true)
      WHERE id = ${a}::uuid
    `}}var j=e.i(654657),F=e.i(220900);async function L(e,t){let i=(await e`
    SELECT
      w.id,
      w.user_id,
      w.asset_id,
      w.amount::text AS amount,
      w.destination_address,
      w.hold_id,
      al.created_at::text AS allowlist_created_at,
      a.symbol AS asset_symbol
    FROM ex_withdrawal_request w
    JOIN ex_asset a ON a.id = w.asset_id
    LEFT JOIN ex_withdrawal_allowlist al ON al.id = w.allowlist_id
    WHERE w.id = ${t.withdrawalId}::uuid
    LIMIT 1
  `)[0];if(!i)return;let a=(()=>{if(!i.allowlist_created_at)return null;let e=Date.parse(i.allowlist_created_at);return Number.isFinite(e)?Math.max(0,Math.floor((Date.now()-e)/6e4)):null})(),r=await e`
    SELECT count(*)::int AS c
    FROM ex_withdrawal_request
    WHERE user_id = ${i.user_id}::uuid
      AND created_at >= (now() - interval '1 hour')
  `,n=r[0]?.c??0,o=await e`
    SELECT count(*)::int AS c
    FROM ex_withdrawal_request
    WHERE user_id = ${i.user_id}::uuid
      AND created_at >= (now() - interval '24 hours')
  `,s=o[0]?.c??0,d=await e`
    WITH acct AS (
      SELECT id
      FROM ex_ledger_account
      WHERE user_id = ${i.user_id}::uuid AND asset_id = ${i.asset_id}::uuid
      LIMIT 1
    ),
    posted AS (
      SELECT coalesce(sum(amount), 0)::numeric AS posted
      FROM ex_journal_line
      WHERE account_id = (SELECT id FROM acct)
    ),
    held AS (
      SELECT coalesce(sum(remaining_amount), 0)::numeric AS held
      FROM ex_hold
      WHERE account_id = (SELECT id FROM acct)
        AND status = 'active'
        AND (${i.hold_id}::uuid IS NULL OR id <> ${i.hold_id}::uuid)
    )
    SELECT (posted.posted - held.held)::text AS available
    FROM posted, held
  `,u=d[0]?.available??null,l=(0,F.assessExchangeWithdrawalRiskV0)({amount:i.amount,available_amount:u,asset_symbol:i.asset_symbol??null,destination_address:i.destination_address??null,allowlist_age_minutes:a,user_withdrawals_1h:n,user_withdrawals_24h:s});await e`
    INSERT INTO app_signal (subject_type, subject_id, kind, score, recommended_action, model_version, payload_json)
    VALUES (
      'withdrawal',
      ${t.withdrawalId},
      'risk_assessment',
      ${l.score},
      ${l.recommended_action},
      ${l.version},
      jsonb_build_object('factors', ${JSON.stringify(l.factors)}::jsonb)
    )
  `,("hold"===l.recommended_action||"block"===l.recommended_action)&&await e`
      UPDATE ex_withdrawal_request
      SET status = 'needs_review', updated_at = now()
      WHERE id = ${t.withdrawalId}::uuid
        AND status = 'requested'
    `}async function U(e,t){let i=String(t.module??"arcade").trim()||"arcade";await (0,x.createNotification)(e,{userId:t.userId,type:"arcade_ready",title:"Arcade reveal ready",body:"daily_drop"===i?"Your daily drop is ready to reveal.":"A new Arcade action is ready to reveal.",metadata:{action_id:t.actionId,module:i,href:"/arcade"}})}async function P(e,t){let i=String(t.module??"arcade").trim()||"arcade";await (0,x.createNotification)(e,{userId:t.userId,type:"arcade_hint_ready",title:"Arcade hint ready",body:"time_vault"===i?"Your Time Vault hint is available.":"A new Arcade hint is available.",metadata:{action_id:t.actionId,module:i,href:"/arcade"}})}var H=e.i(630862),W=e.i(184883),q=e.i(437274);function B(e,t,i){return!!Number.isFinite(t)&&!!Number.isFinite(i)&&!(i<=0)&&("buy"===e?t>=i:t<=i)}function J(e){return Number.isFinite(e)?e.toFixed(18):"0"}function G(e,t,i){let a=BigInt(Math.max(1,Math.min(1e4,Math.trunc(t)))),r=e*("sell"===i?10000n-a:10000n+a);return"buy"===i?(r+10000n-1n)/10000n:r/10000n}async function V(e,t){let i=Math.max(1,Math.min(500,Math.floor(t?.limit??50))),a=t?.serviceName??"exchange:conditional-orders",r=await (0,W.retryOnceOnTransientDbError)(async()=>await e`
      SELECT
        id::text,
        user_id::text,
        market_id::text,
        kind,
        side,
        trigger_price::text,
        limit_price::text,
        take_profit_price::text,
        trail_bps,
        trailing_ref_price::text,
        trailing_stop_price::text,
        activated_at,
        quantity::text,
        status,
        attempt_count,
        last_attempt_at
      FROM ex_conditional_order
      WHERE kind IN ('stop_limit','oco','trailing_stop')
        AND (
          status = 'active'
          OR (
            status = 'triggering'
            AND (last_attempt_at IS NULL OR last_attempt_at < now() - interval '2 minutes')
            AND attempt_count < 10
          )
        )
      ORDER BY created_at ASC
      LIMIT ${i}
    `),n=Array.from(new Set(r.map(e=>e.market_id))),o=new Map;if(n.length>0)for(let t of(await (0,W.retryOnceOnTransientDbError)(async()=>await e`
        WITH mids AS (
          SELECT
            m.id::text AS market_id,
            (
              SELECT e.price
              FROM ex_execution e
              WHERE e.market_id = m.id
              ORDER BY e.created_at DESC
              LIMIT 1
            ) AS last_exec_price,
            (
              SELECT o.price
              FROM ex_order o
              WHERE o.market_id = m.id
                AND o.side = 'buy'
                AND o.status IN ('open','partially_filled')
              ORDER BY o.price DESC, o.created_at ASC
              LIMIT 1
            ) AS bid,
            (
              SELECT o.price
              FROM ex_order o
              WHERE o.market_id = m.id
                AND o.side = 'sell'
                AND o.status IN ('open','partially_filled')
              ORDER BY o.price ASC, o.created_at ASC
              LIMIT 1
            ) AS ask
          FROM ex_market m
          WHERE m.id = ANY(${e.array(n)}::uuid[])
        )
        SELECT
          market_id,
          COALESCE(
            last_exec_price,
            CASE WHEN bid IS NOT NULL AND ask IS NOT NULL THEN (bid + ask) / 2 ELSE NULL END
          )::text AS price
        FROM mids
      `))){let e=null!=t.price?Number(t.price):NaN;Number.isFinite(e)&&o.set(t.market_id,e)}let s=0,d=0,u=0,l=0;for(let t of r){var c,_,p;let i=o.get(t.market_id);if(null==i)continue;let a="stop",r=t.limit_price;if("trailing_stop"===t.kind){let n=Number(t.trigger_price),o=t.trail_bps??0;if(!Number.isFinite(n)||n<=0||!Number.isInteger(o)||o<=0||o>1e4)continue;if(null==t.activated_at){if(c=t.side,!(Number.isFinite(i)&&Number.isFinite(n))||n<=0||("sell"===c?!(i>=n):!(i<=n)))continue;let a=(0,H.toBigInt3818)(J(i)),r=G(a,o,t.side),s=(0,H.fromBigInt3818)(a),d=(0,H.fromBigInt3818)(r);await (0,W.retryOnceOnTransientDbError)(async()=>{await e`
            UPDATE ex_conditional_order
            SET activated_at = now(),
                trailing_ref_price = ${s}::numeric,
                trailing_stop_price = ${d}::numeric,
                updated_at = now()
            WHERE id = ${t.id}::uuid
              AND status = 'active'
          `});continue}if(!t.trailing_ref_price||!t.trailing_stop_price)continue;let s=Number(t.trailing_ref_price),d=Number(t.trailing_stop_price);if(!Number.isFinite(s)||s<=0||!Number.isFinite(d)||d<=0)continue;if("sell"===t.side?i>s:i<s){let a=(0,H.toBigInt3818)(J(i)),r=G(a,o,t.side),n=(0,H.fromBigInt3818)(a),s=(0,H.fromBigInt3818)(r);await (0,W.retryOnceOnTransientDbError)(async()=>{await e`
            UPDATE ex_conditional_order
            SET trailing_ref_price = ${n}::numeric,
                trailing_stop_price = ${s}::numeric,
                updated_at = now()
            WHERE id = ${t.id}::uuid
              AND status = 'active'
          `});continue}if(_=t.side,!(Number.isFinite(i)&&Number.isFinite(d))||d<=0||("sell"===_?!(i<=d):!(i>=d)))continue;a="stop",r=t.limit_price}else if("oco"===t.kind){let e=null!=t.take_profit_price?Number(t.take_profit_price):NaN,n=Number(t.trigger_price),o=B(t.side,i,n),s=(p=t.side,!!Number.isFinite(i)&&!!Number.isFinite(e)&&!(e<=0)&&("sell"===p?i>=e:i<=e));if(!o&&!s)continue;s&&!o?(a="take_profit",r=String(e)):(a="stop",r=t.limit_price)}else{let e=Number(t.trigger_price);if(!B(t.side,i,e))continue;a="stop",r=t.limit_price}s+=1,d+=1,await (0,W.retryOnceOnTransientDbError)(async()=>{await e`
        UPDATE ex_conditional_order
        SET status = 'triggering',
            attempt_count = attempt_count + 1,
            last_attempt_at = now(),
            updated_at = now(),
            failure_reason = NULL
        WHERE id = ${t.id}::uuid
          AND status IN ('active','triggering')
      `});let n=new Request("http://internal/api/exchange/orders",{method:"POST",headers:{"content-type":"application/json","x-user-id":t.user_id,"x-idempotency-key":`cond:${t.id}:${a}`},body:JSON.stringify({market_id:t.market_id,side:t.side,type:"limit",price:r,quantity:t.quantity})}),m=null;try{let i=await (0,q.POST)(n),r=await i.json().catch(()=>null);if(m=r?.order?.id??null,!i.ok||!m){let e=r?.error||`place_failed_${i.status}`;throw Error(e)}u+=1,await (0,W.retryOnceOnTransientDbError)(async()=>{await e`
          UPDATE ex_conditional_order
          SET status = 'triggered',
              triggered_at = now(),
              triggered_leg = ${a},
              placed_order_id = ${m}::uuid,
              updated_at = now()
          WHERE id = ${t.id}::uuid
        `})}catch(a){l+=1;let i=a?.message?String(a.message):"place_failed";await (0,W.retryOnceOnTransientDbError)(async()=>{await e`
          UPDATE ex_conditional_order
          SET status = CASE WHEN attempt_count >= 10 THEN 'failed' ELSE 'active' END,
              failure_reason = ${i},
              updated_at = now()
          WHERE id = ${t.id}::uuid
        `})}}try{await (0,N.upsertServiceHeartbeat)(e,{service:a,status:l>0?"degraded":"ok",details:{scanned:r.length,triggered:s,attempted:d,placed:u,failed:l}})}catch{}return{ok:!0,scanned:r.length,triggered:s,attempted:d,placed:u,failed:l}}var Y=e.i(358217);async function z(e,t){let i=(0,b.randomUUID)(),a="exchange:conditional-orders:evaluate";if((await (0,Y.tryAcquireJobLock)(e,{key:a,holderId:i,ttlMs:55e3})).acquired)try{await V(e,{limit:t.limit??50,serviceName:"exchange:conditional-orders"})}finally{await (0,Y.releaseJobLock)(e,{key:a,holderId:i})}}async function X(e,t){let i=t.payload_json&&"object"==typeof t.payload_json&&!Array.isArray(t.payload_json)?t.payload_json:{};switch(t.topic){case"arcade.action.hint_ready":{let t=String(i.user_id??i.userId??""),a=String(i.action_id??i.actionId??""),r=String(i.module??"");if(!t||!a)return;await P(e,{userId:t,actionId:a,module:r});return}case"arcade.action.ready":{let t=String(i.user_id??i.userId??""),a=String(i.action_id??i.actionId??""),r=String(i.module??"");if(!t||!a)return;await U(e,{userId:t,actionId:a,module:r});return}case"ex.withdrawal.requested":{let t=String(i.withdrawal_id??"");if(!t)return;await L(e,{withdrawalId:t});return}case"ex.withdrawal.approved":{let t=String(i.withdrawal_id??"");if(!t)return;await (0,j.handleWithdrawalBroadcast)(e,{withdrawalId:t});return}case"ex.order.placed":{let t=i.order;if(!t||"object"!=typeof t)return;await T(e,{order:t});return}case"trading.bot.execute":{let t=String(i.execution_id??"");if(!t)return;await D(e,{executionId:t});return}case"trading.bot.unwind":{let t=String(i.execution_id??"");if(!t)return;await k(e,{executionId:t});return}case"ex.conditional.evaluate":{let t=i.limit,a="number"==typeof t?t:"string"==typeof t?Number(t):NaN;await z(e,{limit:Number.isFinite(a)?a:50});return}default:return}}async function K(e,t){let i=Date.now(),a=(0,b.randomUUID)(),r=Math.max(1,Math.min(100,Math.floor(t?.batchSize??25))),n=Math.max(1,Math.min(25,Math.floor(t?.maxBatches??5))),o=Math.max(2e3,Math.min(55e3,Math.floor(t?.maxMs??25e3))),s=t?.topics?.length?t.topics:null,d=0,u=0,l=0,c=0,_=async t=>{try{await (0,N.upsertServiceHeartbeat)(e,{service:"outbox-worker",status:"ok",details:{lockId:a,once:!0,batch:r,maxBatches:n,maxMs:o,topics:s,...t??{}}})}catch{}};await _({event:"start"});for(let t=0;t<n&&!(Date.now()-i>o);t+=1){let t=await (0,y.claimOutboxBatch)(e,{limit:r,lockId:a,lockTtlSeconds:30,topics:s??void 0});if(0===t.length)break;for(let r of(d+=t.length,t)){if(Date.now()-i>o)break;try{await X(e,r),await (0,y.ackOutbox)(e,{id:r.id,lockId:a}),u+=1}catch(o){let t=(0,y.stringifyUnknownError)(o),i=(r.attempts??0)+1;if(i>=Math.max(1,Math.min(25,Number.parseInt(process.env.OUTBOX_MAX_ATTEMPTS??"10",10)||10))){await (0,y.deadLetterOutbox)(e,{id:r.id,lockId:a,error:o}),c+=1,await _({event:"dead-letter",topic:r.topic,err:t});continue}let n=function(e){let t=Math.min(16,Math.max(0,e));return Math.min(6e4,1e3*2**t)}(i);await (0,y.failOutbox)(e,{id:r.id,lockId:a,error:o,nextVisibleAt:new Date(Date.now()+n)}),l+=1,await _({event:"fail",topic:r.topic,err:t,backoffMs:n})}}}let p=Date.now()-i;return await _({event:"stop",claimed:d,acked:u,failed:l,deadLettered:c,durationMs:p}),{ok:!0,lockId:a,claimed:d,acked:u,failed:l,deadLettered:c,durationMs:p,maxMs:o,batchSize:r,maxBatches:n,topics:s}}async function Q(e){let t=function(e){let t=process.env.EXCHANGE_CRON_SECRET??process.env.CRON_SECRET;if(!t)return"cron_secret_not_configured";let i=e.headers.get("x-cron-secret")??e.nextUrl.searchParams.get("secret");return i&&i===t?null:"cron_unauthorized"}(e);if(t)return g.NextResponse.json({error:t},{status:"cron_unauthorized"===t?401:500});let i=new URL(e.url),a=Number(i.searchParams.get("batch")??""),r=Number(i.searchParams.get("max_batches")??""),n=Number(i.searchParams.get("max_ms")??""),o=(i.searchParams.get("topics")??"").trim(),s=o?o.split(",").map(e=>e.trim()).filter(Boolean):void 0,d=(0,h.getSql)();try{let e=await K(d,{batchSize:Number.isFinite(a)&&a>0?a:void 0,maxBatches:Number.isFinite(r)&&r>0?r:void 0,maxMs:Number.isFinite(n)&&n>0?n:void 0,topics:s});return g.NextResponse.json(e)}catch(t){let e=t instanceof Error?t.message:String(t);return g.NextResponse.json({ok:!1,error:"outbox_worker_failed",message:e},{status:500})}}async function Z(e){return Q(e)}e.s(["GET",()=>Z,"POST",()=>Q,"dynamic",0,"force-dynamic","runtime",0,"nodejs"],439918);var ee=e.i(439918);let et=new t.AppRouteRouteModule({definition:{kind:i.RouteKind.APP_ROUTE,page:"/api/exchange/cron/outbox-worker/route",pathname:"/api/exchange/cron/outbox-worker",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/src/app/api/exchange/cron/outbox-worker/route.ts",nextConfigOutput:"",userland:ee}),{workAsyncStorage:ei,workUnitAsyncStorage:ea,serverHooks:er}=et;function en(){return(0,a.patchFetch)({workAsyncStorage:ei,workUnitAsyncStorage:ea})}async function eo(e,t,a){et.isDev&&(0,r.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let g="/api/exchange/cron/outbox-worker/route";g=g.replace(/\/index$/,"")||"/";let h=await et.prepare(e,t,{srcPage:g,multiZoneDraftMode:!1});if(!h)return t.statusCode=400,t.end("Bad Request"),null==a.waitUntil||a.waitUntil.call(a,Promise.resolve()),null;let{buildId:b,params:y,nextConfig:N,parsedUrl:S,isDraftMode:x,prerenderManifest:T,routerServerContext:R,isOnDemandRevalidate:A,revalidateOnlyGenerated:v,resolvedPathname:$,clientReferenceManifest:O,serverActionsManifest:D}=h,I=(0,s.normalizeAppPath)(g),M=!!(T.dynamicRoutes[I]||T.routes[$]),C=async()=>((null==R?void 0:R.render404)?await R.render404(e,t,S,!1):t.end("This page could not be found"),null);if(M&&!x){let e=!!T.routes[$],t=T.dynamicRoutes[I];if(t&&!1===t.fallback&&!e){if(N.experimental.adapterPath)return await C();throw new E.NoFallbackError}}let k=null;!M||et.isDev||x||(k="/index"===(k=$)?"/":k);let j=!0===et.isDev||!M,F=M&&!j;D&&O&&(0,o.setManifestsSingleton)({page:g,clientReferenceManifest:O,serverActionsManifest:D});let L=e.method||"GET",U=(0,n.getTracer)(),P=U.getActiveScopeSpan(),H={params:y,prerenderManifest:T,renderOpts:{experimental:{authInterrupts:!!N.experimental.authInterrupts},cacheComponents:!!N.cacheComponents,supportsDynamicResponse:j,incrementalCache:(0,r.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:N.cacheLife,waitUntil:a.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,i,a,r)=>et.onRequestError(e,t,a,r,R)},sharedContext:{buildId:b}},W=new d.NodeNextRequest(e),q=new d.NodeNextResponse(t),B=u.NextRequestAdapter.fromNodeNextRequest(W,(0,u.signalFromNodeResponse)(t));try{let o=async e=>et.handle(B,H).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let i=U.getRootSpanAttributes();if(!i)return;if(i.get("next.span_type")!==l.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${i.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let a=i.get("next.route");if(a){let t=`${L} ${a}`;e.setAttributes({"next.route":a,"http.route":a,"next.span_name":t}),e.updateName(t)}else e.updateName(`${L} ${g}`)}),s=!!(0,r.getRequestMeta)(e,"minimalMode"),d=async r=>{var n,d;let u=async({previousCacheEntry:i})=>{try{if(!s&&A&&v&&!i)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let n=await o(r);e.fetchMetrics=H.renderOpts.fetchMetrics;let d=H.renderOpts.pendingWaitUntil;d&&a.waitUntil&&(a.waitUntil(d),d=void 0);let u=H.renderOpts.collectedTags;if(!M)return await (0,_.sendResponse)(W,q,n,H.renderOpts.pendingWaitUntil),null;{let e=await n.blob(),t=(0,p.toNodeOutgoingHttpHeaders)(n.headers);u&&(t[f.NEXT_CACHE_TAGS_HEADER]=u),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let i=void 0!==H.renderOpts.collectedRevalidate&&!(H.renderOpts.collectedRevalidate>=f.INFINITE_CACHE)&&H.renderOpts.collectedRevalidate,a=void 0===H.renderOpts.collectedExpire||H.renderOpts.collectedExpire>=f.INFINITE_CACHE?void 0:H.renderOpts.collectedExpire;return{value:{kind:w.CachedRouteKind.APP_ROUTE,status:n.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:i,expire:a}}}}catch(t){throw(null==i?void 0:i.isStale)&&await et.onRequestError(e,t,{routerKind:"App Router",routePath:g,routeType:"route",revalidateReason:(0,c.getRevalidateReason)({isStaticGeneration:F,isOnDemandRevalidate:A})},!1,R),t}},l=await et.handleResponse({req:e,nextConfig:N,cacheKey:k,routeKind:i.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:T,isRoutePPREnabled:!1,isOnDemandRevalidate:A,revalidateOnlyGenerated:v,responseGenerator:u,waitUntil:a.waitUntil,isMinimalMode:s});if(!M)return null;if((null==l||null==(n=l.value)?void 0:n.kind)!==w.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==l||null==(d=l.value)?void 0:d.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});s||t.setHeader("x-nextjs-cache",A?"REVALIDATED":l.isMiss?"MISS":l.isStale?"STALE":"HIT"),x&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let E=(0,p.fromNodeOutgoingHttpHeaders)(l.value.headers);return s&&M||E.delete(f.NEXT_CACHE_TAGS_HEADER),!l.cacheControl||t.getHeader("Cache-Control")||E.get("Cache-Control")||E.set("Cache-Control",(0,m.getCacheControlHeader)(l.cacheControl)),await (0,_.sendResponse)(W,q,new Response(l.value.body,{headers:E,status:l.value.status||200})),null};P?await d(P):await U.withPropagatedContext(e.headers,()=>U.trace(l.BaseServerSpan.handleRequest,{spanName:`${L} ${g}`,kind:n.SpanKind.SERVER,attributes:{"http.method":L,"http.target":e.url}},d))}catch(t){if(t instanceof E.NoFallbackError||await et.onRequestError(e,t,{routerKind:"App Router",routePath:I,routeType:"route",revalidateReason:(0,c.getRevalidateReason)({isStaticGeneration:F,isOnDemandRevalidate:A})},!1,R),M)throw t;return await (0,_.sendResponse)(W,q,new Response(null,{status:500})),null}}e.s(["handler",()=>eo,"patchFetch",()=>en,"routeModule",()=>et,"serverHooks",()=>er,"workAsyncStorage",()=>ei,"workUnitAsyncStorage",()=>ea],481750)}];

//# sourceMappingURL=node_modules_next_dist_esm_build_templates_app-route_f6cf2978.js.map