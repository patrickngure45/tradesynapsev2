{"version":3,"sources":["../../../src/lib/api/errors.ts","../../../src/lib/dbTransient.ts","../../../src/lib/auth/session.ts","../../../src/lib/auth/party.ts","../../../src/lib/auth/admin.ts","../../../src/lib/notifications.ts","../../../src/lib/auditLog.ts","../../../src/lib/requestLog.ts","../../../src/lib/routeLog.ts","../../../src/lib/outbox.ts","../../../src/lib/blockchain/tokens.ts","../../../src/lib/blockchain/hotWallet.ts","../../../src/lib/outbox/handlers/exchangeWithdrawalBroadcast.ts","../../../node_modules/next/dist/esm/build/templates/app-route.js","../../../src/app/api/exchange/admin/withdrawals/%5Bid%5D/broadcast/route.ts"],"sourcesContent":["import { ZodError } from \"zod\";\r\n\r\nexport type ApiErrorResponse = {\r\n  error: string;\r\n  details?: unknown;\r\n};\r\n\r\nexport function statusForApiError(code: string): number {\r\n  switch (code) {\r\n    // AuthN\r\n    case \"missing_x_user_id\":\r\n    case \"missing_user_id\":\r\n    case \"reviewer_key_invalid\":\r\n    case \"session_bootstrap_key_invalid\":\r\n    case \"admin_key_invalid\":\r\n    case \"session_token_expired\":\r\n      return 401;\r\n\r\n    // AuthZ\r\n    case \"not_party\":\r\n    case \"opened_by_not_party\":\r\n    case \"x_user_id_mismatch\":\r\n    case \"actor_not_allowed\":\r\n    case \"withdrawal_address_not_allowlisted\":\r\n    case \"email_not_verified\":\r\n    case \"kyc_required_for_asset\":\r\n    case \"withdrawal_requires_kyc\":\r\n    case \"withdrawal_allowlist_cooldown\":\r\n    case \"totp_setup_required\":\r\n    case \"stepup_required\":\r\n    case \"user_not_active\":\r\n    case \"buyer_not_active\":\r\n    case \"seller_not_active\":\r\n    case \"p2p_country_not_supported\":\r\n    case \"arcade_key_required\":\r\n      return 403;\r\n\r\n    // Not found\r\n    case \"not_found\":\r\n    case \"recipient_not_found\":\r\n    case \"trade_not_found\":\r\n    case \"dispute_not_found\":\r\n    case \"user_not_found\":\r\n    case \"market_not_found\":\r\n    case \"order_not_found\":\r\n    case \"ad_not_found\":\r\n    case \"transfer_not_found\":\r\n      return 404;\r\n\r\n    // Conflict / state machine\r\n    case \"trade_not_disputable\":\r\n    case \"trade_not_disputed\":\r\n    case \"trade_not_resolvable\":\r\n    case \"dispute_not_open\":\r\n    case \"dispute_already_exists\":\r\n    case \"dispute_transition_not_allowed\":\r\n    case \"trade_transition_not_allowed\":\r\n    case \"trade_not_cancelable\":\r\n    case \"trade_state_conflict\":\r\n    case \"insufficient_balance\":\r\n    case \"recipient_inactive\":\r\n    case \"recipient_same_as_sender\":\r\n    case \"transfer_not_reversible\":\r\n    case \"transfer_already_reversed\":\r\n    case \"recipient_insufficient_balance_for_reversal\":\r\n    case \"seller_insufficient_funds\":\r\n    case \"insufficient_liquidity_on_ad\":\r\n    case \"seller_payment_details_missing\":\r\n    case \"order_state_conflict\":\r\n    case \"market_disabled\":\r\n    case \"withdrawal_risk_blocked\":\r\n    case \"ad_is_not_online\":\r\n    case \"p2p_open_orders_limit\":\r\n    case \"post_only_would_take\":\r\n    case \"fok_insufficient_liquidity\":\r\n    case \"idempotency_key_conflict\":\r\n    case \"open_orders_limit\":\r\n    case \"order_notional_too_large\":\r\n    case \"exchange_price_out_of_band\":\r\n    case \"market_halted\":\r\n    case \"stp_cancel_newest\":\r\n    case \"stp_cancel_both\":\r\n    case \"passkey_not_configured\":\r\n      return 409;\r\n\r\n    // Gas token\r\n    case \"insufficient_gas\":\r\n      return 409;\r\n    case \"gas_disabled\":\r\n      return 403;\r\n    case \"gas_asset_not_found\":\r\n    case \"gas_fee_invalid\":\r\n      return 500;\r\n\r\n    // Forbidden\r\n    case \"cannot_trade_own_ad\":\r\n      return 403;\r\n\r\n    // Rate limiting\r\n    case \"rate_limit_exceeded\":\r\n    case \"p2p_order_create_cooldown\":\r\n      return 429;\r\n\r\n    // Validation\r\n    case \"invalid_input\":\r\n    case \"price_not_multiple_of_tick\":\r\n    case \"quantity_not_multiple_of_lot\":\r\n    case \"unsupported_version\":\r\n    case \"missing_file\":\r\n    case \"invalid_metadata_json\":\r\n    case \"buyer_not_found\":\r\n    case \"seller_not_found\":\r\n    case \"seller_payment_method_required\":\r\n    case \"invalid_seller_payment_method\":\r\n    case \"webauthn_verification_failed\":\r\n      return 400;\r\n\r\n    // Server misconfig\r\n    case \"reviewer_key_not_configured\":\r\n    case \"session_secret_not_configured\":\r\n    case \"session_bootstrap_not_configured\":\r\n    case \"admin_key_not_configured\":\r\n      return 500;\r\n\r\n    // Internal\r\n    case \"internal_error\":\r\n      return 500;\r\n\r\n    // Upstream / dependencies\r\n    case \"upstream_unavailable\":\r\n      return 503;\r\n\r\n    default:\r\n      return 400;\r\n  }\r\n}\r\n\r\nexport function apiError(\r\n  code: string,\r\n  init?: {\r\n    status?: number;\r\n    details?: unknown;\r\n    headers?: HeadersInit;\r\n  }\r\n): Response {\r\n  const status = init?.status ?? statusForApiError(code);\r\n  \r\n  // Ensure message is included if details is just a string, or if we can extract it.\r\n  // But strictly, we should output { error: code, message?: string, details?: any }\r\n  // The UI expects `message`.\r\n  const body: any = { error: code };\r\n  \r\n  if (typeof init?.details === 'string') {\r\n      body.message = init.details;\r\n      body.details = init.details;\r\n  } else if (typeof init?.details === 'object' && init?.details !== null) {\r\n      body.details = init.details;\r\n      if ('message' in init.details) {\r\n          body.message = (init.details as any).message;\r\n      }\r\n  }\r\n\r\n  const headers = init?.headers ? new Headers(init.headers) : new Headers();\r\n  if (code === \"upstream_unavailable\" && !headers.has(\"Retry-After\")) {\r\n    headers.set(\"Retry-After\", \"3\");\r\n  }\r\n\r\n  return Response.json(body, { status, headers });\r\n}\r\n\r\nexport function apiZodError(err: unknown): Response | null {\r\n  if (!(err instanceof ZodError)) return null;\r\n  return apiError(\"invalid_input\", { status: 400, details: err.issues });\r\n}\r\n\r\nexport function apiUpstreamUnavailable(\r\n  details?: unknown,\r\n  init?: {\r\n    retryAfterSeconds?: number;\r\n  }\r\n): Response {\r\n  const headers: HeadersInit | undefined =\r\n    typeof init?.retryAfterSeconds === \"number\"\r\n      ? { \"Retry-After\": String(Math.max(0, Math.floor(init.retryAfterSeconds))) }\r\n      : undefined;\r\n\r\n  return apiError(\"upstream_unavailable\", {\r\n    status: 503,\r\n    details,\r\n    headers,\r\n  });\r\n}\r\n","import { apiUpstreamUnavailable } from \"@/lib/api/errors\";\r\n\r\nfunction sleep(ms: number): Promise<void> {\r\n  return new Promise((r) => setTimeout(r, ms));\r\n}\r\n\r\nfunction getErrorCode(err: unknown): string | undefined {\r\n  if (!err || typeof err !== \"object\") return undefined;\r\n  const anyErr = err as { code?: unknown };\r\n  return typeof anyErr.code === \"string\" ? anyErr.code : undefined;\r\n}\r\n\r\nfunction getErrorMessage(err: unknown): string {\r\n  if (!err || typeof err !== \"object\") return String(err);\r\n  const anyErr = err as { message?: unknown };\r\n  return typeof anyErr.message === \"string\" ? anyErr.message : String(err);\r\n}\r\n\r\nexport function isTransientDbError(err: unknown): boolean {\r\n  const code = (getErrorCode(err) ?? \"\").toUpperCase();\r\n  const msg = getErrorMessage(err);\r\n\r\n  // postgres.js (and some serverless poolers) commonly surface these.\r\n  const transientCodes = new Set([\r\n    \"CONNECTION_CLOSED\",\r\n    \"CONNECTION_ENDED\",\r\n    \"CONNECTION_DESTROYED\",\r\n    \"ECONNRESET\",\r\n    \"ETIMEDOUT\",\r\n    \"EPIPE\",\r\n    \"ENOTFOUND\",\r\n  ]);\r\n  if (code && transientCodes.has(code)) return true;\r\n\r\n  // SQLSTATE classes for connection / availability issues.\r\n  // 08xxx: connection exception, 57P0x: operator intervention.\r\n  const transientSqlState = new Set([\r\n    \"08000\",\r\n    \"08003\",\r\n    \"08006\",\r\n    \"08001\",\r\n    \"08004\",\r\n    \"57P01\",\r\n    \"57P02\",\r\n    \"57P03\",\r\n    \"53300\", // too_many_connections\r\n  ]);\r\n  if (code && transientSqlState.has(code)) return true;\r\n\r\n  if (\r\n    /CONNECTION_CLOSED|connection\\s+terminated|terminating\\s+connection|socket\\s+hang\\s+up|ECONNRESET|EPIPE/i.test(\r\n      msg\r\n    )\r\n  ) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport async function retryOnceOnTransientDbError<T>(\r\n  fn: () => Promise<T>,\r\n  init?: { delayMs?: number }\r\n): Promise<T> {\r\n  try {\r\n    return await fn();\r\n  } catch (e) {\r\n    if (!isTransientDbError(e)) throw e;\r\n    await sleep(init?.delayMs ?? 50);\r\n    return await fn();\r\n  }\r\n}\r\n\r\nexport function responseForDbError(op: string, err: unknown): Response | null {\r\n  if (!isTransientDbError(err)) return null;\r\n\r\n  return apiUpstreamUnavailable(\r\n    {\r\n      dependency: \"db\",\r\n      op,\r\n    },\r\n    { retryAfterSeconds: 3 }\r\n  );\r\n}\r\n","import { createHmac, timingSafeEqual } from \"node:crypto\";\r\n\r\nconst COOKIE_NAME = \"pp_session\";\r\n\r\ntype SessionPayload = {\r\n  uid: string;\r\n  iat: number;\r\n  exp: number;\r\n  sv?: number;\r\n};\r\n\r\nfunction base64UrlEncode(buf: Buffer): string {\r\n  return buf\r\n    .toString(\"base64\")\r\n    .replace(/\\+/g, \"-\")\r\n    .replace(/\\//g, \"_\")\r\n    .replace(/=+$/g, \"\");\r\n}\r\n\r\nfunction base64UrlDecode(text: string): Buffer {\r\n  const pad = text.length % 4;\r\n  const padded = text + (pad ? \"=\".repeat(4 - pad) : \"\");\r\n  const b64 = padded.replace(/-/g, \"+\").replace(/_/g, \"/\");\r\n  return Buffer.from(b64, \"base64\");\r\n}\r\n\r\nfunction sign(secret: string, payloadB64: string): string {\r\n  const mac = createHmac(\"sha256\", secret).update(payloadB64, \"utf8\").digest();\r\n  return base64UrlEncode(mac);\r\n}\r\n\r\nexport function getSessionCookieName(): string {\r\n  return COOKIE_NAME;\r\n}\r\n\r\nexport function parseCookieHeader(header: string | null): Record<string, string> {\r\n  if (!header) return {};\r\n  const out: Record<string, string> = {};\r\n  const parts = header.split(/;\\s*/g);\r\n  for (const part of parts) {\r\n    const idx = part.indexOf(\"=\");\r\n    if (idx <= 0) continue;\r\n    const k = part.slice(0, idx).trim();\r\n    const v = part.slice(idx + 1).trim();\r\n    if (!k) continue;\r\n    out[k] = decodeURIComponent(v);\r\n  }\r\n  return out;\r\n}\r\n\r\nexport function getSessionTokenFromRequest(request: Request): string | null {\r\n  const cookies = parseCookieHeader(request.headers.get(\"cookie\"));\r\n  return cookies[COOKIE_NAME] ?? null;\r\n}\r\n\r\nexport function createSessionToken(opts: {\r\n  userId: string;\r\n  secret: string;\r\n  sessionVersion?: number;\r\n  ttlSeconds?: number;\r\n  now?: number;\r\n}): string {\r\n  const nowSec = Math.floor((opts.now ?? Date.now()) / 1000);\r\n  const ttl = typeof opts.ttlSeconds === \"number\" ? opts.ttlSeconds : 60 * 60 * 24 * 7;\r\n  const payload: SessionPayload = {\r\n    uid: opts.userId,\r\n    iat: nowSec,\r\n    exp: nowSec + ttl,\r\n    ...(typeof opts.sessionVersion === \"number\" && Number.isFinite(opts.sessionVersion)\r\n      ? { sv: Math.max(0, Math.trunc(opts.sessionVersion)) }\r\n      : {}),\r\n  };\r\n\r\n  const payloadB64 = base64UrlEncode(Buffer.from(JSON.stringify(payload), \"utf8\"));\r\n  const sigB64 = sign(opts.secret, payloadB64);\r\n  return `${payloadB64}.${sigB64}`;\r\n}\r\n\r\nexport function verifySessionToken(opts: {\r\n  token: string;\r\n  secret: string;\r\n  now?: number;\r\n}): { ok: true; payload: SessionPayload } | { ok: false; error: string } {\r\n  const token = opts.token.trim();\r\n  const dot = token.indexOf(\".\");\r\n  if (dot <= 0) return { ok: false, error: \"session_token_invalid\" };\r\n\r\n  const payloadB64 = token.slice(0, dot);\r\n  const sigB64 = token.slice(dot + 1);\r\n  if (!payloadB64 || !sigB64) return { ok: false, error: \"session_token_invalid\" };\r\n\r\n  const expectedSig = sign(opts.secret, payloadB64);\r\n  const a = Buffer.from(sigB64);\r\n  const b = Buffer.from(expectedSig);\r\n  if (a.length !== b.length || !timingSafeEqual(a, b)) {\r\n    return { ok: false, error: \"session_token_invalid\" };\r\n  }\r\n\r\n  let payload: SessionPayload;\r\n  try {\r\n    payload = JSON.parse(base64UrlDecode(payloadB64).toString(\"utf8\")) as SessionPayload;\r\n  } catch {\r\n    return { ok: false, error: \"session_token_invalid\" };\r\n  }\r\n\r\n  if (!payload || typeof payload !== \"object\") return { ok: false, error: \"session_token_invalid\" };\r\n  if (typeof payload.uid !== \"string\" || !payload.uid) return { ok: false, error: \"session_token_invalid\" };\r\n  if (typeof payload.exp !== \"number\" || !Number.isFinite(payload.exp)) {\r\n    return { ok: false, error: \"session_token_invalid\" };\r\n  }\r\n\r\n  if (payload.sv != null) {\r\n    const sv = Number(payload.sv);\r\n    if (!Number.isFinite(sv) || sv < 0) return { ok: false, error: \"session_token_invalid\" };\r\n    payload.sv = Math.max(0, Math.trunc(sv));\r\n  }\r\n\r\n  const nowSec = Math.floor((opts.now ?? Date.now()) / 1000);\r\n  if (payload.exp <= nowSec) return { ok: false, error: \"session_token_expired\" };\r\n\r\n  return { ok: true, payload };\r\n}\r\n\r\n\r\nexport function serializeSessionCookie(opts: {\r\n  token: string;\r\n  maxAgeSeconds: number;\r\n  secure: boolean;\r\n}): string {\r\n  const parts = [\r\n    `${COOKIE_NAME}=${encodeURIComponent(opts.token)}`,\r\n    \"Path=/\",\r\n    \"HttpOnly\",\r\n    \"SameSite=Lax\",\r\n    `Max-Age=${Math.max(0, Math.floor(opts.maxAgeSeconds))}`,\r\n  ];\r\n  if (opts.secure) parts.push(\"Secure\");\r\n  return parts.join(\"; \");\r\n}\r\n\r\nexport function serializeClearSessionCookie(opts?: { secure?: boolean }): string {\r\n  const parts = [\r\n    `${COOKIE_NAME}=`,\r\n    \"Path=/\",\r\n    \"HttpOnly\",\r\n    \"SameSite=Lax\",\r\n    \"Max-Age=0\",\r\n  ];\r\n  if (opts?.secure) parts.push(\"Secure\");\r\n  return parts.join(\"; \");\r\n}\r\n","import { getSessionTokenFromRequest, verifySessionToken } from \"@/lib/auth/session\";\r\n\r\nconst isProd = process.env.NODE_ENV === \"production\";\r\nconst enforceAuth = isProd || process.env.ENFORCE_AUTH === \"1\";\r\n\r\n/**\r\n * Resolve the acting user identity from the request.\r\n *\r\n * In production (or when ENFORCE_AUTH=1), **only** the signed session cookie\r\n * or a valid internal service token is trusted.\r\n * In development, the `x-user-id` header is also accepted\r\n * (convenience for scripts/smoke tests).\r\n */\r\nexport function getActingUserId(request: Request): string | null {\r\n  // 1. Try signed session cookie first (always trusted).\r\n  const secret = process.env.PROOFPACK_SESSION_SECRET ?? \"\";\r\n  if (secret) {\r\n    const token = getSessionTokenFromRequest(request);\r\n    if (token) {\r\n      const verified = verifySessionToken({ token, secret });\r\n      if (verified.ok) return verified.payload.uid;\r\n    }\r\n  } else if (enforceAuth) {\r\n    // In production, refuse to operate without a session secret.\r\n    // This prevents silent auth bypass if the env var is unset.\r\n    console.error(\"[FATAL] PROOFPACK_SESSION_SECRET is not set in production!\");\r\n    return null;\r\n  }\r\n\r\n  // 2. Internal service-to-service calls (e.g. copy trading placing orders\r\n  //    on behalf of subscribers). Trusted in ALL environments when the\r\n  //    shared secret matches.\r\n  const internalSecret = process.env.INTERNAL_SERVICE_SECRET;\r\n  if (internalSecret) {\r\n    const headerSecret = request.headers.get(\"x-internal-service-token\");\r\n    if (headerSecret && headerSecret === internalSecret) {\r\n      const uid = request.headers.get(\"x-user-id\");\r\n      if (uid) return uid;\r\n    }\r\n  }\r\n\r\n  // 3. In dev only (without ENFORCE_AUTH), fall back to the x-user-id header.\r\n  if (!enforceAuth) {\r\n    const header = request.headers.get(\"x-user-id\");\r\n    if (header) return header;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nexport function requireActingUserIdInProd(actingUserId: string | null): string | null {\r\n  if (enforceAuth && !actingUserId) {\r\n    return \"missing_x_user_id\";\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function isParty(actingUserId: string | null, trade: { buyer_user_id: string; seller_user_id: string }): boolean {\r\n  if (!actingUserId) return false;\r\n  return actingUserId === trade.buyer_user_id || actingUserId === trade.seller_user_id;\r\n}\r\n","import type { Sql } from \"postgres\";\r\nimport { getActingUserId } from \"@/lib/auth/party\";\r\nimport { apiError } from \"@/lib/api/errors\";\r\nimport { getSessionTokenFromRequest, serializeClearSessionCookie } from \"@/lib/auth/session\";\r\n\r\nexport type AdminCheckResult =\r\n  | { ok: true; userId: string }\r\n  | { ok: false; error: string };\r\n\r\nexport type AdminApiCheckResult =\r\n  | { ok: true; userId: string }\r\n  | { ok: false; response: Response };\r\n\r\n/**\r\n * Require the request to come from a signed-in user with `role = 'admin'`.\r\n *\r\n * Returns the admin user ID on success (useful for audit trails).\r\n * In dev mode without ENFORCE_AUTH, falls back to the header identity\r\n * but still checks the DB role column.\r\n */\r\nexport async function requireAdmin(\r\n  sql: Sql,\r\n  request: Request,\r\n): Promise<AdminCheckResult> {\r\n  const userId = getActingUserId(request);\r\n  if (!userId) return { ok: false, error: \"auth_required\" };\r\n\r\n  const rows = await sql<{ role: string }[]>`\r\n    SELECT role FROM app_user WHERE id = ${userId}::uuid LIMIT 1\r\n  `;\r\n\r\n  if (rows.length === 0) return { ok: false, error: \"user_not_found\" };\r\n  if (rows[0]!.role !== \"admin\") return { ok: false, error: \"admin_required\" };\r\n\r\n  return { ok: true, userId };\r\n}\r\n\r\n/**\r\n * Wrapper for API route handlers.\r\n *\r\n * If the request has a session cookie that verifies but its uid no longer exists\r\n * (common after user cleanup), we clear the cookie and return `auth_required`\r\n * so the UI can re-login cleanly.\r\n */\r\nexport async function requireAdminForApi(\r\n  sql: Sql,\r\n  request: Request,\r\n): Promise<AdminApiCheckResult> {\r\n  const sessionToken = getSessionTokenFromRequest(request);\r\n  const secure = process.env.NODE_ENV === \"production\";\r\n\r\n  const admin = await requireAdmin(sql, request);\r\n  if (admin.ok) return admin;\r\n\r\n  if (admin.error === \"user_not_found\" || admin.error === \"auth_required\") {\r\n    const headers: HeadersInit | undefined = sessionToken\r\n      ? { \"set-cookie\": serializeClearSessionCookie({ secure }) }\r\n      : undefined;\r\n    return { ok: false, response: apiError(\"auth_required\", { headers }) };\r\n  }\r\n\r\n  return { ok: false, response: apiError(admin.error) };\r\n}\r\n","import type { Sql } from \"postgres\";\r\n\r\nexport type NotificationSeverity = \"info\" | \"success\" | \"warning\" | \"danger\";\r\n\r\nexport type NotificationType =\r\n  | \"order_placed\"\r\n  | \"order_filled\"\r\n  | \"order_partially_filled\"\r\n  | \"order_canceled\"\r\n  | \"order_rejected\"\r\n  | \"deposit_credited\"\r\n  | \"withdrawal_approved\"\r\n  | \"withdrawal_rejected\"\r\n  | \"withdrawal_completed\"\r\n  | \"trade_won\"\r\n  | \"trade_lost\"\r\n  | \"p2p_order_created\"\r\n  | \"p2p_order_expiring\"\r\n  | \"p2p_payment_confirmed\"\r\n  | \"p2p_order_completed\"\r\n  | \"p2p_order_cancelled\"\r\n  | \"p2p_dispute_opened\"\r\n  | \"p2p_dispute_resolved\"\r\n  | \"p2p_feedback_received\"\r\n  | \"arcade_ready\"\r\n  | \"arcade_hint_ready\"\r\n  | \"price_alert\"\r\n  | \"system\";\r\n\r\nfunction asRecord(v: unknown): Record<string, unknown> {\r\n  if (v && typeof v === \"object\" && !Array.isArray(v)) return v as Record<string, unknown>;\r\n  return {};\r\n}\r\n\r\nfunction getString(meta: Record<string, unknown>, ...keys: string[]): string | null {\r\n  for (const key of keys) {\r\n    const v = meta[key];\r\n    if (typeof v === \"string\" && v.trim()) return v;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction getSeverityForType(type: NotificationType): NotificationSeverity {\r\n  switch (type) {\r\n    case \"order_placed\":\r\n      return \"info\";\r\n    case \"deposit_credited\":\r\n    case \"withdrawal_completed\":\r\n    case \"order_filled\":\r\n    case \"p2p_order_completed\":\r\n    case \"p2p_feedback_received\":\r\n      return \"success\";\r\n    case \"p2p_order_expiring\":\r\n    case \"p2p_payment_confirmed\":\r\n    case \"withdrawal_approved\":\r\n    case \"order_partially_filled\":\r\n      return \"warning\";\r\n    case \"withdrawal_rejected\":\r\n    case \"order_canceled\":\r\n    case \"order_rejected\":\r\n    case \"p2p_order_cancelled\":\r\n    case \"p2p_dispute_opened\":\r\n      return \"danger\";\r\n    case \"arcade_ready\":\r\n    case \"arcade_hint_ready\":\r\n      return \"info\";\r\n    case \"price_alert\":\r\n      return \"warning\";\r\n    case \"p2p_dispute_resolved\":\r\n    case \"p2p_order_created\":\r\n    case \"trade_won\":\r\n    case \"trade_lost\":\r\n    case \"system\":\r\n    default:\r\n      return \"info\";\r\n  }\r\n}\r\n\r\nfunction deriveHref(type: NotificationType, meta: Record<string, unknown>): string | null {\r\n  const orderId = getString(meta, \"order_id\", \"orderId\");\r\n  const withdrawalId = getString(meta, \"withdrawal_id\", \"withdrawalId\");\r\n  const assetSymbol = getString(meta, \"asset_symbol\", \"assetSymbol\", \"symbol\");\r\n\r\n  if (orderId && type.startsWith(\"p2p_\")) return `/p2p/orders/${orderId}`;\r\n\r\n  if (withdrawalId && type.startsWith(\"withdrawal_\")) return \"/wallet\";\r\n\r\n  switch (type) {\r\n    case \"arcade_ready\":\r\n    case \"arcade_hint_ready\":\r\n      return \"/arcade\";\r\n    case \"price_alert\":\r\n      return \"/home\";\r\n    case \"deposit_credited\":\r\n      // Nudge users toward offloading via P2P (no fiat specified so it auto-selects from /api/whoami).\r\n      return assetSymbol ? `/p2p?side=SELL&asset=${encodeURIComponent(assetSymbol)}&src=deposit` : \"/wallet\";\r\n    case \"order_filled\":\r\n    case \"order_partially_filled\":\r\n    case \"order_canceled\":\r\n    case \"order_placed\":\r\n    case \"order_rejected\":\r\n      return \"/order-history\";\r\n    default:\r\n      return null;\r\n  }\r\n}\r\n\r\nfunction applyNotificationPolicy(type: NotificationType, metadata: Record<string, unknown> | undefined) {\r\n  const meta = { ...(metadata ?? {}) } as Record<string, unknown>;\r\n\r\n  // Canonicalize common ids into snake_case so UI can be simple.\r\n  const orderId = getString(meta, \"order_id\", \"orderId\");\r\n  if (orderId) meta.order_id = orderId;\r\n\r\n  const withdrawalId = getString(meta, \"withdrawal_id\", \"withdrawalId\");\r\n  if (withdrawalId) meta.withdrawal_id = withdrawalId;\r\n\r\n  const txHash = getString(meta, \"tx_hash\", \"txHash\");\r\n  if (txHash) meta.tx_hash = txHash;\r\n\r\n  if (!getString(meta, \"severity\")) meta.severity = getSeverityForType(type);\r\n\r\n  const href = getString(meta, \"href\") ?? deriveHref(type, meta);\r\n  if (href && href.startsWith(\"/\")) meta.href = href;\r\n\r\n  return meta;\r\n}\r\n\r\ntype NotificationSchedule = {\r\n  quiet_enabled: boolean;\r\n  quiet_start_min: number;\r\n  quiet_end_min: number;\r\n  tz_offset_min: number;\r\n  digest_enabled: boolean;\r\n} | null;\r\n\r\nfunction clampInt(v: unknown, lo: number, hi: number, fallback: number): number {\r\n  const n = typeof v === \"number\" ? v : Number(String(v ?? \"\"));\r\n  if (!Number.isFinite(n)) return fallback;\r\n  const i = Math.trunc(n);\r\n  return Math.max(lo, Math.min(hi, i));\r\n}\r\n\r\nfunction isInQuietHours(schedule: NotificationSchedule, nowUtc = new Date()): boolean {\r\n  if (!schedule?.quiet_enabled) return false;\r\n\r\n  const offsetMin = clampInt(schedule.tz_offset_min, -840, 840, 0);\r\n  const localMs = nowUtc.getTime() + offsetMin * 60_000;\r\n  const local = new Date(localMs);\r\n  const localMin = local.getUTCHours() * 60 + local.getUTCMinutes();\r\n\r\n  const start = clampInt(schedule.quiet_start_min, 0, 1439, 1320);\r\n  const end = clampInt(schedule.quiet_end_min, 0, 1439, 480);\r\n\r\n  if (start === end) return true; // interpret as \"always quiet\"\r\n  if (start < end) return localMin >= start && localMin < end;\r\n  return localMin >= start || localMin < end; // wraps midnight\r\n}\r\n\r\nasync function getSchedule(sql: Sql, userId: string): Promise<NotificationSchedule> {\r\n  try {\r\n    const rows = await sql<\r\n      Array<{\r\n        quiet_enabled: boolean;\r\n        quiet_start_min: number;\r\n        quiet_end_min: number;\r\n        tz_offset_min: number;\r\n        digest_enabled: boolean;\r\n      }>\r\n    >`\r\n      SELECT quiet_enabled, quiet_start_min, quiet_end_min, tz_offset_min, digest_enabled\r\n      FROM app_notification_schedule\r\n      WHERE user_id = ${userId}::uuid\r\n      LIMIT 1\r\n    `;\r\n    return rows[0] ?? null;\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport async function createNotification(\r\n  sql: Sql,\r\n  params: {\r\n    userId: string;\r\n    type: NotificationType;\r\n    title: string;\r\n    body?: string;\r\n    metadata?: Record<string, unknown>;\r\n  },\r\n): Promise<string> {\r\n  let wantInApp = true;\r\n  let wantEmail = false;\r\n\r\n  try {\r\n    const prefRows = await sql<{ in_app_enabled: boolean; email_enabled: boolean }[]>`\r\n      SELECT\r\n        coalesce(in_app_enabled, enabled) AS in_app_enabled,\r\n        coalesce(email_enabled, false) AS email_enabled\r\n      FROM app_notification_preference\r\n      WHERE user_id = ${params.userId}::uuid\r\n        AND type = ${params.type}\r\n      LIMIT 1\r\n    `;\r\n    if (prefRows.length > 0) {\r\n      wantInApp = prefRows[0]!.in_app_enabled !== false;\r\n      wantEmail = prefRows[0]!.email_enabled === true;\r\n    }\r\n  } catch {\r\n    // Preference checks must never break core flows.\r\n  }\r\n\r\n  if (!wantInApp && !wantEmail) return \"\";\r\n\r\n  const title = String(params.title ?? \"\").trim() || \"Notification\";\r\n  const body = String(params.body ?? \"\");\r\n  const metadata = applyNotificationPolicy(params.type, params.metadata);\r\n\r\n  // Quiet hours (best-effort): defer non-system notifications into a queue.\r\n  // Digest flushing is handled by a cron endpoint.\r\n  if (params.type !== \"system\") {\r\n    const schedule = await getSchedule(sql, params.userId);\r\n    if (schedule?.digest_enabled && isInQuietHours(schedule)) {\r\n      try {\r\n        const rows = await sql<{ id: string }[]>`\r\n          INSERT INTO ex_notification_deferred (user_id, type, title, body, metadata_json)\r\n          VALUES (${params.userId}::uuid, ${params.type}, ${title}, ${body}, ${metadata as any}::jsonb)\r\n          RETURNING id::text AS id\r\n        `;\r\n        return rows[0]?.id ?? \"\";\r\n      } catch {\r\n        // If deferral fails, fall through to immediate notification.\r\n      }\r\n    }\r\n  }\r\n\r\n  let notifId = \"\";\r\n\r\n  if (wantInApp) {\r\n    const rows = await sql<{ id: string; created_at: string }[]>`\r\n      INSERT INTO ex_notification (user_id, type, title, body, metadata_json)\r\n      VALUES (\r\n        ${params.userId}::uuid,\r\n        ${params.type},\r\n        ${title},\r\n        ${body},\r\n        ${metadata as any}::jsonb\r\n      )\r\n      RETURNING id::text AS id, created_at::text AS created_at\r\n    `;\r\n\r\n    const row = rows[0]!;\r\n    notifId = row.id;\r\n\r\n    // Realtime push (SSE/WebSocket listeners): fires on COMMIT if inside a transaction.\r\n    // Keep payload small (Postgres NOTIFY is ~8KB).\r\n    try {\r\n      const payload = JSON.stringify({\r\n        id: row.id,\r\n        user_id: params.userId,\r\n        type: params.type,\r\n        title,\r\n        body,\r\n        metadata_json: metadata,\r\n        created_at: row.created_at,\r\n      });\r\n      await sql`SELECT pg_notify('ex_notification', ${payload})`;\r\n    } catch {\r\n      // ignore realtime failures\r\n    }\r\n  }\r\n\r\n  if (wantEmail) {\r\n    try {\r\n      const users = await sql<Array<{ email: string | null; email_verified: boolean | null }>>`\r\n        SELECT email, email_verified\r\n        FROM app_user\r\n        WHERE id = ${params.userId}::uuid\r\n        LIMIT 1\r\n      `;\r\n\r\n      const u = users[0];\r\n      const to = u?.email ? String(u.email).trim().toLowerCase() : \"\";\r\n      const verified = u?.email_verified === true;\r\n\r\n      if (to && to.includes(\"@\") && verified) {\r\n        const subject = `[Coinwaka] ${title}`;\r\n        const textBody = body ? `${title}\\n\\n${body}` : title;\r\n        const htmlBody = body\r\n          ? `<p><strong>${escapeHtml(title)}</strong></p><p>${escapeHtml(body)}</p>`\r\n          : `<p><strong>${escapeHtml(title)}</strong></p>`;\r\n\r\n        await sql`\r\n          INSERT INTO ex_email_outbox (user_id, to_email, kind, type, subject, text_body, html_body, metadata_json)\r\n          VALUES (\r\n            ${params.userId}::uuid,\r\n            ${to},\r\n            'notification',\r\n            ${params.type},\r\n            ${subject},\r\n            ${textBody},\r\n            ${htmlBody},\r\n            ${metadata as any}::jsonb\r\n          )\r\n        `;\r\n      }\r\n    } catch {\r\n      // Email queueing must never break core flows.\r\n    }\r\n  }\r\n\r\n  return notifId;\r\n}\r\n\r\nfunction escapeHtml(text: string): string {\r\n  return String(text ?? \"\")\r\n    .replaceAll(\"&\", \"&amp;\")\r\n    .replaceAll(\"<\", \"&lt;\")\r\n    .replaceAll(\">\", \"&gt;\")\r\n    .replaceAll('\"', \"&quot;\")\r\n    .replaceAll(\"'\", \"&#39;\");\r\n}\r\n\r\nexport async function listNotifications(\r\n  sql: Sql,\r\n  params: { userId: string; limit?: number; unreadOnly?: boolean },\r\n): Promise<\r\n  Array<{\r\n    id: string;\r\n    type: string;\r\n    title: string;\r\n    body: string;\r\n    metadata_json: unknown;\r\n    read: boolean;\r\n    created_at: string;\r\n  }>\r\n> {\r\n  const limit = Math.max(1, Math.min(200, params.limit ?? 50));\r\n  return await sql`\r\n    SELECT id, type, title, body, metadata_json, read, created_at\r\n    FROM ex_notification\r\n    WHERE user_id = ${params.userId}::uuid\r\n      ${params.unreadOnly ? sql`AND read = false` : sql``}\r\n    ORDER BY created_at DESC\r\n    LIMIT ${limit}\r\n  `;\r\n}\r\n\r\nexport async function countUnread(sql: Sql, userId: string): Promise<number> {\r\n  const rows = await sql<{ count: string }[]>`\r\n    SELECT count(*)::text AS count\r\n    FROM ex_notification\r\n    WHERE user_id = ${userId}::uuid AND read = false\r\n  `;\r\n  return Number(rows[0]?.count ?? \"0\");\r\n}\r\n\r\nexport async function markRead(sql: Sql, params: { userId: string; ids: string[] }): Promise<number> {\r\n  if (params.ids.length === 0) return 0;\r\n  const result = await sql`\r\n    UPDATE ex_notification\r\n    SET read = true\r\n    WHERE user_id = ${params.userId}::uuid\r\n      AND id = ANY(${params.ids}::uuid[])\r\n      AND read = false\r\n  `;\r\n  return result.count;\r\n}\r\n\r\nexport async function markAllRead(sql: Sql, userId: string): Promise<number> {\r\n  const result = await sql`\r\n    UPDATE ex_notification\r\n    SET read = true\r\n    WHERE user_id = ${userId}::uuid AND read = false\r\n  `;\r\n  return result.count;\r\n}\r\n","/**\r\n * Append-only audit log writer.\r\n *\r\n * All security-sensitive operations (auth, withdrawals, admin actions,\r\n * order lifecycle) should call `writeAuditLog` to create a tamper-evident\r\n * record in the `audit_log` table.\r\n *\r\n * The table has triggers that prevent UPDATE and DELETE, so records are\r\n * truly immutable once written.\r\n */\r\n\r\nimport type postgres from \"postgres\";\r\n\r\ntype Sql = ReturnType<typeof postgres>;\r\n\r\nexport type AuditEntry = {\r\n  /** Who performed the action (null for system). */\r\n  actorId?: string | null;\r\n  /** 'user' | 'admin' | 'system' | 'outbox' */\r\n  actorType?: string;\r\n  /** Dot-delimited action name, e.g. 'auth.session.created'. */\r\n  action: string;\r\n  /** Resource category, e.g. 'withdrawal', 'order'. */\r\n  resourceType?: string | null;\r\n  /** Primary key of the target resource. */\r\n  resourceId?: string | null;\r\n  /** Client IP address. */\r\n  ip?: string | null;\r\n  /** User-Agent header. */\r\n  userAgent?: string | null;\r\n  /** Request correlation ID. */\r\n  requestId?: string | null;\r\n  /** Arbitrary structured payload. */\r\n  detail?: Record<string, unknown>;\r\n};\r\n\r\n/**\r\n * Insert one audit log row.\r\n *\r\n * This is designed to be called within an existing transaction so the\r\n * audit record is committed atomically with the business operation.\r\n * It can also be called outside a transaction for fire-and-forget logging.\r\n */\r\nexport async function writeAuditLog(sql: Sql, entry: AuditEntry): Promise<void> {\r\n  await sql`\r\n    INSERT INTO audit_log (\r\n      actor_id,\r\n      actor_type,\r\n      action,\r\n      resource_type,\r\n      resource_id,\r\n      ip,\r\n      user_agent,\r\n      request_id,\r\n      detail\r\n    ) VALUES (\r\n      ${entry.actorId ?? null},\r\n      ${entry.actorType ?? \"user\"},\r\n      ${entry.action},\r\n      ${entry.resourceType ?? null},\r\n      ${entry.resourceId ?? null},\r\n      ${entry.ip ?? null},\r\n      ${entry.userAgent ?? null},\r\n      ${entry.requestId ?? null},\r\n      ${JSON.stringify(entry.detail ?? {})}::jsonb\r\n    )\r\n  `;\r\n}\r\n\r\n/**\r\n * Extract standard audit context from a Request object.\r\n */\r\nexport function auditContextFromRequest(request: Request): {\r\n  ip: string | null;\r\n  userAgent: string | null;\r\n  requestId: string | null;\r\n} {\r\n  return {\r\n    ip:\r\n      request.headers.get(\"x-real-ip\") ??\r\n      request.headers.get(\"x-forwarded-for\")?.split(\",\")[0]?.trim() ??\r\n      null,\r\n    userAgent: request.headers.get(\"user-agent\"),\r\n    requestId: request.headers.get(\"x-request-id\"),\r\n  };\r\n}\r\n","/**\r\n * Structured request logger.\r\n *\r\n * Emits one JSON line per request with:\r\n *   requestId, method, path, status, durationMs, ip, userAgent, userId\r\n *\r\n * In dev the output is also human-readable via a compact format.\r\n * In production, downstream log collectors (CloudWatch, Datadog, etc.)\r\n * can index the JSON fields directly.\r\n */\r\n\r\nexport type RequestLogEntry = {\r\n  requestId: string;\r\n  method: string;\r\n  path: string;\r\n  status: number;\r\n  durationMs: number;\r\n  ip: string | null;\r\n  userAgent: string | null;\r\n  userId: string | null;\r\n  /** Extra context (error code, rate-limit info, etc.). */\r\n  meta?: Record<string, unknown>;\r\n  ts: string;\r\n};\r\n\r\n/**\r\n * Generate a request ID (compact UUID v4 without dashes).\r\n * If the incoming request already carries `x-request-id`, reuse it\r\n * (common when behind a reverse proxy / CDN).\r\n */\r\nexport function getOrCreateRequestId(request: Request): string {\r\n  const existing = request.headers.get(\"x-request-id\");\r\n  if (existing && existing.length >= 8 && existing.length <= 128) return existing;\r\n  return crypto.randomUUID().replace(/-/g, \"\");\r\n}\r\n\r\n/**\r\n * Extract the client IP from standard proxy headers.\r\n * Next.js on Vercel provides `x-forwarded-for`; adjust for your infra.\r\n */\r\nexport function extractClientIp(request: Request): string | null {\r\n  // x-real-ip is set by many reverse proxies (nginx, Caddy, ALB).\r\n  const real = request.headers.get(\"x-real-ip\");\r\n  if (real) return real.split(\",\")[0]!.trim();\r\n\r\n  const forwarded = request.headers.get(\"x-forwarded-for\");\r\n  if (forwarded) return forwarded.split(\",\")[0]!.trim();\r\n\r\n  return null;\r\n}\r\n\r\nconst isProd = process.env.NODE_ENV === \"production\";\r\n\r\nfunction looksSecretKey(key: string): boolean {\r\n  const k = key.toLowerCase();\r\n  return (\r\n    k.includes(\"password\") ||\r\n    k.includes(\"secret\") ||\r\n    k.includes(\"token\") ||\r\n    k.includes(\"apikey\") ||\r\n    k.includes(\"api_key\") ||\r\n    k.includes(\"private\") ||\r\n    k.includes(\"seed\") ||\r\n    k.includes(\"jwt\") ||\r\n    k.includes(\"authorization\") ||\r\n    k.includes(\"cookie\")\r\n  );\r\n}\r\n\r\nfunction envSecrets(): string[] {\r\n  const names = [\r\n    \"SECRET_KEY\",\r\n    \"PROOFPACK_SESSION_SECRET\",\r\n    \"PROOFPACK_SESSION_BOOTSTRAP_KEY\",\r\n    \"PROOFPACK_REVIEWER_KEY\",\r\n    \"EXCHANGE_ADMIN_KEY\",\r\n    \"EXCHANGE_CRON_SECRET\",\r\n    \"CRON_SECRET\",\r\n    \"RESET_SECRET\",\r\n    \"ADMIN_RESET_SECRET\",\r\n    \"INTERNAL_SERVICE_SECRET\",\r\n    \"DEPLOYER_PRIVATE_KEY\",\r\n    \"CITADEL_MASTER_SEED\",\r\n    \"GROQ_API_KEY\",\r\n    \"GOOGLE_API_KEY\",\r\n    \"PINATA_JWT\",\r\n    \"BINANCE_API_KEY\",\r\n    \"BINANCE_API_SECRET\",\r\n  ];\r\n\r\n  const out: string[] = [];\r\n  for (const n of names) {\r\n    const v = String(process.env[n] ?? \"\").trim();\r\n    if (v && v.length >= 8) out.push(v);\r\n  }\r\n  return out;\r\n}\r\n\r\nconst SECRET_VALUES = envSecrets();\r\n\r\nfunction redactString(s: string): string {\r\n  let out = s;\r\n  for (const secret of SECRET_VALUES) {\r\n    if (!secret) continue;\r\n    if (out.includes(secret)) out = out.split(secret).join(\"[REDACTED]\");\r\n  }\r\n  return out;\r\n}\r\n\r\nfunction redactUnknown(v: unknown, depth: number): unknown {\r\n  if (depth > 6) return \"[TRUNCATED]\";\r\n\r\n  if (v == null) return v;\r\n  if (typeof v === \"string\") return redactString(v);\r\n  if (typeof v === \"number\" || typeof v === \"boolean\") return v;\r\n\r\n  if (Array.isArray(v)) return v.slice(0, 50).map((x) => redactUnknown(x, depth + 1));\r\n\r\n  if (typeof v === \"object\") {\r\n    const obj = v as Record<string, unknown>;\r\n    const out: Record<string, unknown> = {};\r\n    let count = 0;\r\n    for (const [k, val] of Object.entries(obj)) {\r\n      count += 1;\r\n      if (count > 80) {\r\n        out.__more__ = \"[TRUNCATED]\";\r\n        break;\r\n      }\r\n      if (looksSecretKey(k)) {\r\n        out[k] = \"[REDACTED]\";\r\n      } else {\r\n        out[k] = redactUnknown(val, depth + 1);\r\n      }\r\n    }\r\n    return out;\r\n  }\r\n\r\n  return String(v);\r\n}\r\n\r\nfunction redactEntry(entry: RequestLogEntry): RequestLogEntry {\r\n  return {\r\n    ...entry,\r\n    userAgent: entry.userAgent ? redactString(entry.userAgent) : entry.userAgent,\r\n    meta: entry.meta ? (redactUnknown(entry.meta, 0) as Record<string, unknown>) : entry.meta,\r\n  };\r\n}\r\n\r\nexport function logRequest(entry: RequestLogEntry): void {\r\n  const safe = redactEntry(entry);\r\n  if (isProd) {\r\n    // Machine-readable JSON line for log aggregators.\r\n    process.stdout.write(JSON.stringify(safe) + \"\\n\");\r\n  } else {\r\n    // Compact human-readable format for dev.\r\n    const uid = safe.userId ? ` u=${safe.userId.slice(0, 8)}` : \"\";\r\n    const meta = safe.meta ? ` ${JSON.stringify(safe.meta)}` : \"\";\r\n    console.log(\r\n      `[${safe.requestId.slice(0, 8)}] ${safe.method} ${safe.path} → ${safe.status} (${safe.durationMs}ms)${uid}${meta}`\r\n    );\r\n  }\r\n}\r\n","/**\r\n * Route-level response logging helper.\r\n *\r\n * The middleware logs at request-entry time (before the route runs) so it\r\n * doesn't know the final HTTP status or the authenticated user ID.\r\n *\r\n * This helper lets route handlers emit a completion-phase log line with\r\n * the actual status, user, and any route-specific metadata.\r\n *\r\n * Usage in a route:\r\n *\r\n *   import { logRouteResponse } from \"@/lib/routeLog\";\r\n *\r\n *   export async function POST(request: Request) {\r\n *     const start = Date.now();\r\n *     // … handler logic …\r\n *     const response = Response.json(body, { status: 201 });\r\n *     logRouteResponse(request, response, { startMs: start, userId: actingUserId });\r\n *     return response;\r\n *   }\r\n */\r\n\r\nimport { logRequest, type RequestLogEntry } from \"@/lib/requestLog\";\r\n\r\nexport type RouteLogOpts = {\r\n  /** Epoch-ms when the route handler started (use Date.now() at the top). */\r\n  startMs: number;\r\n  /** Authenticated user ID (if known). */\r\n  userId?: string | null;\r\n  /** Arbitrary extra context (error code, etc.). */\r\n  meta?: Record<string, unknown>;\r\n};\r\n\r\n/**\r\n * Emit a structured log line for a completed route response.\r\n * Reads `x-request-id` from the incoming request (set by middleware).\r\n */\r\nexport function logRouteResponse(\r\n  request: Request,\r\n  response: Response,\r\n  opts: RouteLogOpts\r\n): void {\r\n  const requestId = request.headers.get(\"x-request-id\") ?? \"unknown\";\r\n  const url = new URL(request.url, \"http://localhost\");\r\n\r\n  const entry: RequestLogEntry = {\r\n    requestId,\r\n    method: request.method,\r\n    path: url.pathname,\r\n    status: response.status,\r\n    durationMs: Date.now() - opts.startMs,\r\n    ip: request.headers.get(\"x-real-ip\") ?? request.headers.get(\"x-forwarded-for\")?.split(\",\")[0]?.trim() ?? null,\r\n    userAgent: request.headers.get(\"user-agent\"),\r\n    userId: opts.userId ?? null,\r\n    meta: opts.meta,\r\n    ts: new Date().toISOString(),\r\n  };\r\n\r\n  logRequest(entry);\r\n}\r\n","import type { Sql } from \"postgres\";\r\n\r\nexport type OutboxTopic =\r\n  | \"arcade.action.hint_ready\"\r\n  | \"arcade.action.ready\"\r\n  | \"ex.order.placed\"\r\n  | \"ex.order.canceled\"\r\n  | \"ex.conditional.evaluate\"\r\n  | \"ex.withdrawal.requested\"\r\n  | \"ex.withdrawal.approved\"\r\n  | \"ex.withdrawal.rejected\"\r\n  | \"ex.withdrawal.broadcasted\"\r\n  | \"ex.withdrawal.confirmed\"\r\n  | \"ex.withdrawal.failed\"\r\n  | \"trading.bot.execute\"\r\n  | \"trading.bot.unwind\";\r\n\r\nexport type OutboxEnqueue = {\r\n  topic: OutboxTopic;\r\n  aggregate_type?: string | null;\r\n  aggregate_id?: string | null;\r\n  payload: Record<string, unknown>;\r\n  visible_at?: Date;\r\n};\r\n\r\nexport type OutboxRow = {\r\n  id: string;\r\n  topic: string;\r\n  aggregate_type: string | null;\r\n  aggregate_id: string | null;\r\n  payload_json: unknown;\r\n  attempts: number;\r\n  last_error: string | null;\r\n  dead_lettered_at?: string | null;\r\n  visible_at: string;\r\n  locked_at: string | null;\r\n  lock_id: string | null;\r\n  created_at: string;\r\n  processed_at: string | null;\r\n};\r\n\r\nexport async function enqueueOutbox(sql: Sql, ev: OutboxEnqueue): Promise<string> {\r\n  const visibleAt = ev.visible_at ?? new Date();\r\n  const payloadText = JSON.stringify(ev.payload ?? {});\r\n\r\n  const rows = await sql<{ id: string }[]>`\r\n    INSERT INTO app_outbox_event (topic, aggregate_type, aggregate_id, payload_json, visible_at)\r\n    VALUES (\r\n      ${ev.topic},\r\n      ${ev.aggregate_type ?? null},\r\n      ${ev.aggregate_id ?? null},\r\n      (\r\n        CASE\r\n          WHEN jsonb_typeof(((${payloadText}::jsonb #>> '{}')::jsonb)) = 'object'\r\n            THEN ((${payloadText}::jsonb #>> '{}')::jsonb)\r\n          ELSE jsonb_build_object('value', ((${payloadText}::jsonb #>> '{}')::jsonb))\r\n        END\r\n      ),\r\n      ${visibleAt}\r\n    )\r\n    RETURNING id\r\n  `;\r\n\r\n  return rows[0]!.id;\r\n}\r\n\r\nexport async function claimOutboxBatch(\r\n  sql: Sql,\r\n  opts: {\r\n    limit: number;\r\n    lockId: string;\r\n    lockTtlSeconds?: number;\r\n    topics?: string[];\r\n  }\r\n): Promise<OutboxRow[]> {\r\n  const limit = Math.max(1, Math.min(500, Math.floor(opts.limit)));\r\n  const lockTtlSeconds = Math.max(5, Math.min(600, Math.floor(opts.lockTtlSeconds ?? 30)));\r\n  const topics = opts.topics?.length ? opts.topics : null;\r\n\r\n  if (!topics) {\r\n    const rows = await sql<OutboxRow[]>`\r\n      WITH picked AS (\r\n        SELECT id\r\n        FROM app_outbox_event\r\n        WHERE processed_at IS NULL\r\n          AND dead_lettered_at IS NULL\r\n          AND visible_at <= now()\r\n          AND (\r\n            locked_at IS NULL\r\n            OR locked_at < (now() - make_interval(secs => ${lockTtlSeconds}))\r\n          )\r\n        ORDER BY visible_at ASC, created_at ASC, id ASC\r\n        LIMIT ${limit}\r\n        FOR UPDATE SKIP LOCKED\r\n      )\r\n      UPDATE app_outbox_event o\r\n      SET locked_at = now(), lock_id = ${opts.lockId}::uuid\r\n      FROM picked\r\n      WHERE o.id = picked.id\r\n      RETURNING\r\n        o.id,\r\n        o.topic,\r\n        o.aggregate_type,\r\n        o.aggregate_id,\r\n        o.payload_json,\r\n        o.attempts,\r\n        o.last_error,\r\n        o.visible_at,\r\n        o.locked_at,\r\n        o.lock_id,\r\n        o.created_at,\r\n        o.processed_at\r\n    `;\r\n    return rows;\r\n  }\r\n\r\n  const rows = await sql<OutboxRow[]>`\r\n    WITH picked AS (\r\n      SELECT id\r\n      FROM app_outbox_event\r\n      WHERE processed_at IS NULL\r\n        AND dead_lettered_at IS NULL\r\n        AND visible_at <= now()\r\n        AND (\r\n          locked_at IS NULL\r\n          OR locked_at < (now() - make_interval(secs => ${lockTtlSeconds}))\r\n        )\r\n        AND topic = ANY(${sql.array(topics)})\r\n      ORDER BY visible_at ASC, created_at ASC, id ASC\r\n      LIMIT ${limit}\r\n      FOR UPDATE SKIP LOCKED\r\n    )\r\n    UPDATE app_outbox_event o\r\n    SET locked_at = now(), lock_id = ${opts.lockId}::uuid\r\n    FROM picked\r\n    WHERE o.id = picked.id\r\n    RETURNING\r\n      o.id,\r\n      o.topic,\r\n      o.aggregate_type,\r\n      o.aggregate_id,\r\n      o.payload_json,\r\n      o.attempts,\r\n      o.last_error,\r\n      o.visible_at,\r\n      o.locked_at,\r\n      o.lock_id,\r\n      o.created_at,\r\n      o.processed_at\r\n  `;\r\n\r\n  return rows;\r\n}\r\n\r\nexport async function ackOutbox(sql: Sql, opts: { id: string; lockId: string }): Promise<void> {\r\n  await sql`\r\n    UPDATE app_outbox_event\r\n    SET processed_at = now(), locked_at = NULL, lock_id = NULL\r\n    WHERE id = ${opts.id}::uuid\r\n      AND lock_id = ${opts.lockId}::uuid\r\n      AND processed_at IS NULL\r\n  `;\r\n}\r\n\r\nexport async function failOutbox(\r\n  sql: Sql,\r\n  opts: {\r\n    id: string;\r\n    lockId: string;\r\n    error: unknown;\r\n    nextVisibleAt: Date;\r\n  }\r\n): Promise<void> {\r\n  const msg = stringifyUnknownError(opts.error);\r\n  await sql`\r\n    UPDATE app_outbox_event\r\n    SET\r\n      attempts = attempts + 1,\r\n      last_error = ${msg},\r\n      visible_at = ${opts.nextVisibleAt.toISOString()},\r\n      locked_at = NULL,\r\n      lock_id = NULL\r\n    WHERE id = ${opts.id}::uuid\r\n      AND lock_id = ${opts.lockId}::uuid\r\n      AND processed_at IS NULL\r\n  `;\r\n}\r\n\r\nexport function stringifyUnknownError(err: unknown): string {\r\n  if (err instanceof Error) return err.message || err.name;\r\n  if (typeof err === \"string\") return err;\r\n  try {\r\n    return JSON.stringify(err);\r\n  } catch {\r\n    return String(err);\r\n  }\r\n}\r\n\r\n// ── Dead-letter support ──────────────────────────────────────────────\r\n\r\n/** Move an event to the dead-letter pool after exceeding max attempts. */\r\nexport async function deadLetterOutbox(\r\n  sql: Sql,\r\n  opts: { id: string; lockId: string; error: unknown },\r\n): Promise<void> {\r\n  const msg = stringifyUnknownError(opts.error);\r\n  await sql`\r\n    UPDATE app_outbox_event\r\n    SET\r\n      attempts = attempts + 1,\r\n      last_error = ${msg},\r\n      dead_lettered_at = now(),\r\n      locked_at = NULL,\r\n      lock_id = NULL\r\n    WHERE id = ${opts.id}::uuid\r\n      AND lock_id = ${opts.lockId}::uuid\r\n      AND processed_at IS NULL\r\n  `;\r\n}\r\n\r\n/** Retry a dead-lettered event by resetting it back to pending. */\r\nexport async function retryDeadLetter(sql: Sql, opts: { id: string }): Promise<boolean> {\r\n  const rows = await sql<{ id: string }[]>`\r\n    UPDATE app_outbox_event\r\n    SET\r\n      dead_lettered_at = NULL,\r\n      locked_at = NULL,\r\n      lock_id = NULL,\r\n      visible_at = now(),\r\n      attempts = 0,\r\n      last_error = NULL\r\n    WHERE id = ${opts.id}::uuid\r\n      AND dead_lettered_at IS NOT NULL\r\n      AND processed_at IS NULL\r\n    RETURNING id\r\n  `;\r\n  return rows.length > 0;\r\n}\r\n\r\n/** List dead-lettered events for admin review (most recent first). */\r\nexport async function listDeadLetters(\r\n  sql: Sql,\r\n  opts?: { limit?: number; offset?: number; topic?: string },\r\n): Promise<OutboxRow[]> {\r\n  const limit = Math.max(1, Math.min(200, Math.floor(opts?.limit ?? 50)));\r\n  const offset = Math.max(0, Math.floor(opts?.offset ?? 0));\r\n  const topic = opts?.topic ?? null;\r\n\r\n  if (topic) {\r\n    return sql<OutboxRow[]>`\r\n      SELECT\r\n        id, topic, aggregate_type, aggregate_id, payload_json,\r\n        attempts, last_error, dead_lettered_at, visible_at, locked_at, lock_id,\r\n        created_at, processed_at\r\n      FROM app_outbox_event\r\n      WHERE dead_lettered_at IS NOT NULL\r\n        AND processed_at IS NULL\r\n        AND topic = ${topic}\r\n      ORDER BY dead_lettered_at DESC\r\n      LIMIT ${limit} OFFSET ${offset}\r\n    `;\r\n  }\r\n\r\n  return sql<OutboxRow[]>`\r\n    SELECT\r\n      id, topic, aggregate_type, aggregate_id, payload_json,\r\n      attempts, last_error, dead_lettered_at, visible_at, locked_at, lock_id,\r\n      created_at, processed_at\r\n    FROM app_outbox_event\r\n    WHERE dead_lettered_at IS NOT NULL\r\n      AND processed_at IS NULL\r\n    ORDER BY dead_lettered_at DESC\r\n    LIMIT ${limit} OFFSET ${offset}\r\n  `;\r\n}\r\n\r\n/** Count dead-lettered events (for pagination). */\r\nexport async function countDeadLetters(\r\n  sql: Sql,\r\n  opts?: { topic?: string },\r\n): Promise<number> {\r\n  const topic = opts?.topic ?? null;\r\n  const rows = topic\r\n    ? await sql<{ total: number }[]>`\r\n        SELECT count(*)::int AS total FROM app_outbox_event\r\n        WHERE dead_lettered_at IS NOT NULL\r\n          AND processed_at IS NULL\r\n          AND topic = ${topic}\r\n      `\r\n    : await sql<{ total: number }[]>`\r\n        SELECT count(*)::int AS total FROM app_outbox_event\r\n        WHERE dead_lettered_at IS NOT NULL\r\n          AND processed_at IS NULL\r\n      `;\r\n  return rows[0]?.total ?? 0;\r\n}\r\n\r\n/** Mark a dead-lettered event as resolved (suppressed) without retrying. */\r\nexport async function resolveDeadLetter(sql: Sql, opts: { id: string }): Promise<boolean> {\r\n  const rows = await sql<{ id: string }[]>`\r\n    UPDATE app_outbox_event\r\n    SET\r\n      processed_at = now(),\r\n      locked_at = NULL,\r\n      lock_id = NULL\r\n    WHERE id = ${opts.id}::uuid\r\n      AND dead_lettered_at IS NOT NULL\r\n      AND processed_at IS NULL\r\n    RETURNING id\r\n  `;\r\n  return rows.length > 0;\r\n}\r\n\r\n/** Fetch a single dead-lettered event (for export/details). */\r\nexport async function getDeadLetterById(sql: Sql, opts: { id: string }): Promise<OutboxRow | null> {\r\n  const rows = await sql<OutboxRow[]>`\r\n    SELECT\r\n      id, topic, aggregate_type, aggregate_id, payload_json,\r\n      attempts, last_error, dead_lettered_at, visible_at, locked_at, lock_id,\r\n      created_at, processed_at\r\n    FROM app_outbox_event\r\n    WHERE id = ${opts.id}::uuid\r\n      AND dead_lettered_at IS NOT NULL\r\n    LIMIT 1\r\n  `;\r\n  return rows[0] ?? null;\r\n}\r\n","/**\r\n * BEP-20 Token interactions on BSC\r\n *\r\n * Provides balance checks, transfer functions, and deposit detection\r\n * for USDT and native BNB.\r\n */\r\nimport { ethers } from \"ethers\";\r\nimport { getBscProvider, getBscReadProvider } from \"./wallet\";\r\nimport { isLikelyRpcTransportError, markRpcFail, markRpcOk, rankRpcUrls } from \"@/lib/blockchain/rpcHealth\";\r\n\r\n// ── Standard BEP-20 ABI (minimal) ───────────────────────────────────\r\nconst ERC20_ABI = [\r\n  \"function balanceOf(address owner) view returns (uint256)\",\r\n  \"function transfer(address to, uint256 amount) returns (bool)\",\r\n  \"function decimals() view returns (uint8)\",\r\n  \"function symbol() view returns (string)\",\r\n  \"event Transfer(address indexed from, address indexed to, uint256 value)\",\r\n] as const;\r\n\r\n// ── Known contract addresses ─────────────────────────────────────────\r\nexport type KnownToken = \"USDT\" | \"BNB\";\r\n\r\nconst MAINNET_TOKENS: Record<string, string> = {\r\n  USDT: \"0x55d398326f99059fF775485246999027B3197955\", // BSC-USD (Binance-Peg)\r\n};\r\n\r\nconst TESTNET_TOKENS: Record<string, string> = {\r\n  USDT: \"0x337610d27c682E347C9cD60BD4b3b107C9d34dDd\", // Testnet USDT mock\r\n};\r\n\r\nexport function getTokenAddress(symbol: string): string | null {\r\n  const isMainnet = process.env.NEXT_PUBLIC_USE_MAINNET !== \"false\";\r\n  const tokens = isMainnet ? MAINNET_TOKENS : TESTNET_TOKENS;\r\n  return tokens[symbol.toUpperCase()] ?? null;\r\n}\r\n\r\n// ── Balance queries ──────────────────────────────────────────────────\r\n\r\n/** Get native BNB balance */\r\nexport async function getBnbBalance(address: string): Promise<string> {\r\n  const provider = getBscReadProvider();\r\n  const bal = await provider.getBalance(address);\r\n  return ethers.formatEther(bal);\r\n}\r\n\r\n/** Get BEP-20 token balance */\r\nexport async function getTokenBalance(\r\n  tokenAddress: string,\r\n  walletAddress: string,\r\n): Promise<{ balance: string; decimals: number }> {\r\n  const provider = getBscReadProvider();\r\n  const contract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);\r\n  const [bal, decimals] = await Promise.all([\r\n    contract.balanceOf(walletAddress) as Promise<bigint>,\r\n    contract.decimals() as Promise<number>,\r\n  ]);\r\n  return {\r\n    balance: ethers.formatUnits(bal, decimals),\r\n    decimals,\r\n  };\r\n}\r\n\r\n/** Get all known token balances for a wallet */\r\nexport async function getAllBalances(walletAddress: string): Promise<\r\n  { symbol: string; balance: string; contractAddress: string | null }[]\r\n> {\r\n  const results: { symbol: string; balance: string; contractAddress: string | null }[] = [];\r\n\r\n  // BNB (native)\r\n  try {\r\n    const bnb = await getBnbBalance(walletAddress);\r\n    results.push({ symbol: \"BNB\", balance: bnb, contractAddress: null });\r\n  } catch {\r\n    results.push({ symbol: \"BNB\", balance: \"0\", contractAddress: null });\r\n  }\r\n\r\n  // BEP-20 tokens\r\n  for (const symbol of [\"USDT\"] as const) {\r\n    const addr = getTokenAddress(symbol);\r\n    if (!addr) continue;\r\n    try {\r\n      const { balance } = await getTokenBalance(addr, walletAddress);\r\n      results.push({ symbol, balance, contractAddress: addr });\r\n    } catch {\r\n      results.push({ symbol, balance: \"0\", contractAddress: addr });\r\n    }\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\n// ── Transfer functions ───────────────────────────────────────────────\r\n\r\n/** Send BEP-20 tokens from a wallet (requires private key) */\r\nexport async function sendToken(\r\n  tokenAddress: string,\r\n  privateKey: string,\r\n  to: string,\r\n  amount: string,\r\n  decimals: number = 18,\r\n): Promise<{ txHash: string }> {\r\n  // Prefer multi-RPC failover when BSC_RPC_URLS is configured.\r\n  const urls = rankRpcUrls(\"bsc\");\r\n  const chainId = Number(process.env.NEXT_PUBLIC_USE_MAINNET) === 0 ? 97 : 56;\r\n  const network = ethers.Network.from({ name: \"bnb\", chainId });\r\n\r\n  const amountWei = ethers.parseUnits(amount, decimals);\r\n  let lastErr: unknown = null;\r\n\r\n  // If only one URL is configured, keep the historical behavior.\r\n  if (urls.length <= 1) {\r\n    const provider = getBscProvider();\r\n    const signer = new ethers.Wallet(privateKey, provider);\r\n    const contract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);\r\n    const tx = (await contract.transfer(to, amountWei)) as ethers.TransactionResponse;\r\n    await tx.wait(1);\r\n    return { txHash: tx.hash };\r\n  }\r\n\r\n  for (const url of urls) {\r\n    const provider = new ethers.JsonRpcProvider(url, network, { staticNetwork: network });\r\n    const signer = new ethers.Wallet(privateKey, provider);\r\n    const contract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);\r\n    const t0 = Date.now();\r\n    try {\r\n      const tx = (await contract.transfer(to, amountWei)) as ethers.TransactionResponse;\r\n      markRpcOk(url, Date.now() - t0);\r\n      // Waiting can fail due to transport issues even when the tx broadcast succeeded.\r\n      await tx.wait(1).catch(() => undefined);\r\n      return { txHash: tx.hash };\r\n    } catch (e) {\r\n      markRpcFail(url);\r\n      lastErr = e;\r\n      if (!isLikelyRpcTransportError(e)) throw e;\r\n    }\r\n  }\r\n\r\n  throw lastErr instanceof Error ? lastErr : new Error(\"bsc_rpc_all_failed\");\r\n}\r\n\r\n/** Send native BNB */\r\nexport async function sendBnb(\r\n  privateKey: string,\r\n  to: string,\r\n  amount: string,\r\n): Promise<{ txHash: string }> {\r\n  const urls = rankRpcUrls(\"bsc\");\r\n  const chainId = Number(process.env.NEXT_PUBLIC_USE_MAINNET) === 0 ? 97 : 56;\r\n  const network = ethers.Network.from({ name: \"bnb\", chainId });\r\n\r\n  const value = ethers.parseEther(amount);\r\n  let lastErr: unknown = null;\r\n\r\n  if (urls.length <= 1) {\r\n    const provider = getBscProvider();\r\n    const signer = new ethers.Wallet(privateKey, provider);\r\n    const tx = await signer.sendTransaction({ to, value });\r\n    await tx.wait(1);\r\n    return { txHash: tx.hash };\r\n  }\r\n\r\n  for (const url of urls) {\r\n    const provider = new ethers.JsonRpcProvider(url, network, { staticNetwork: network });\r\n    const signer = new ethers.Wallet(privateKey, provider);\r\n    const t0 = Date.now();\r\n    try {\r\n      const tx = await signer.sendTransaction({ to, value });\r\n      markRpcOk(url, Date.now() - t0);\r\n      await tx.wait(1).catch(() => undefined);\r\n      return { txHash: tx.hash };\r\n    } catch (e) {\r\n      markRpcFail(url);\r\n      lastErr = e;\r\n      if (!isLikelyRpcTransportError(e)) throw e;\r\n    }\r\n  }\r\n\r\n  throw lastErr instanceof Error ? lastErr : new Error(\"bsc_rpc_all_failed\");\r\n}\r\n","/**\r\n * Hot Wallet accessor for withdrawal broadcasting.\r\n *\r\n * The hot wallet is defined by DEPLOYER_PRIVATE_KEY in .env.\r\n * It holds a minimized float and is only accessed server-side.\r\n *\r\n * AI never signs transactions.  AI never directly moves money.\r\n * Only this module and the broadcast handler touch the private key.\r\n */\r\nimport { ethers } from \"ethers\";\r\n\r\nlet _cachedAddress: string | null = null;\r\nlet _cachedKey: string | null = null;\r\n\r\nfunction getEnvKey(): string {\r\n  const k = process.env.DEPLOYER_PRIVATE_KEY;\r\n  if (!k) throw new Error(\"DEPLOYER_PRIVATE_KEY is not set\");\r\n  return k.startsWith(\"0x\") ? k : `0x${k}`;\r\n}\r\n\r\n/** Get the hot wallet address (public, safe to log). */\r\nexport function getHotWalletAddress(): string {\r\n  if (!_cachedAddress) {\r\n    const wallet = new ethers.Wallet(getEnvKey());\r\n    _cachedAddress = wallet.address.toLowerCase();\r\n  }\r\n  return _cachedAddress;\r\n}\r\n\r\n/**\r\n * Get the hot wallet private key.\r\n * NEVER log this value. Callers must use it only inside sendToken / sendBnb.\r\n */\r\nexport function getHotWalletKey(): string {\r\n  if (!_cachedKey) {\r\n    _cachedKey = getEnvKey();\r\n  }\r\n  return _cachedKey;\r\n}\r\n","/**\r\n * Outbox handler: broadcast an approved withdrawal on-chain.\r\n *\r\n * Flow:\r\n *   1. Lock the row by setting status = 'broadcasted' (prevents double-send).\r\n *   2. Resolve the correct send function (BNB native vs BEP-20 token).\r\n *   3. Send the transaction — sendToken / sendBnb wait for 1 confirmation.\r\n *   4. On success — record tx_hash, set status = 'confirmed', consume hold,\r\n *      create settlement journal entry, notify user.\r\n *   5. On failure — set status = 'failed' with failure_reason, release hold,\r\n *      notify user.\r\n */\r\nimport type { Sql } from \"postgres\";\r\n\r\nimport { getHotWalletKey } from \"@/lib/blockchain/hotWallet\";\r\nimport { sendToken, sendBnb, getTokenAddress } from \"@/lib/blockchain/tokens\";\r\nimport { enqueueOutbox } from \"@/lib/outbox\";\r\nimport { createNotification } from \"@/lib/notifications\";\r\n\r\n/** Well-known system/omnibus ledger account owner (must match migration 007). */\r\nconst SYSTEM_USER_ID = \"00000000-0000-0000-0000-000000000001\";\r\n\r\n// ── Types ────────────────────────────────────────────────────────────\r\ntype WithdrawalRow = {\r\n  id: string;\r\n  user_id: string;\r\n  asset_id: string;\r\n  amount: string;\r\n  destination_address: string;\r\n  hold_id: string | null;\r\n  status: string;\r\n};\r\n\r\ntype AssetRow = {\r\n  id: string;\r\n  symbol: string;\r\n  chain: string;\r\n  contract_address: string | null;\r\n  decimals: number;\r\n};\r\n\r\n// ── Public ───────────────────────────────────────────────────────────\r\n\r\n/**\r\n * Broadcast a single approved withdrawal on-chain.\r\n * Caller must ensure the withdrawal is in 'approved' status.\r\n *\r\n * Throws on transient errors (outbox will retry with backoff).\r\n */\r\nexport async function handleWithdrawalBroadcast(\r\n  sql: Sql,\r\n  opts: { withdrawalId: string },\r\n): Promise<void> {\r\n  const { withdrawalId } = opts;\r\n\r\n  // ── 1. Load & lock ───────────────────────────────────────────\r\n  const locked = await sql.begin(async (tx) => {\r\n    const txSql = tx as unknown as typeof sql;\r\n\r\n    // Attempt to transition approved → broadcasted atomically\r\n    const rows = await txSql<WithdrawalRow[]>`\r\n      UPDATE ex_withdrawal_request\r\n      SET status = 'broadcasted', updated_at = now()\r\n      WHERE id = ${withdrawalId} AND status = 'approved'\r\n      RETURNING\r\n        id,\r\n        user_id::text AS user_id,\r\n        asset_id::text AS asset_id,\r\n        amount::text AS amount,\r\n        destination_address,\r\n        hold_id::text AS hold_id,\r\n        status\r\n    `;\r\n    if (rows.length === 0) return null; // already handled or wrong status\r\n    return rows[0]!;\r\n  });\r\n\r\n  if (!locked) return; // nothing to do — idempotent\r\n\r\n  // ── 2. Resolve asset ─────────────────────────────────────────\r\n  const assets = await sql<AssetRow[]>`\r\n    SELECT id::text AS id, symbol, chain, contract_address, decimals\r\n    FROM ex_asset\r\n    WHERE id = ${locked.asset_id}\r\n    LIMIT 1\r\n  `;\r\n  if (assets.length === 0) {\r\n    await markFailed(sql, locked, \"asset_not_found\");\r\n    return;\r\n  }\r\n  const asset = assets[0]!;\r\n\r\n  // ── 3. Send on-chain ─────────────────────────────────────────\r\n  let txHash: string;\r\n  try {\r\n    const hotKey = getHotWalletKey();\r\n\r\n    if (asset.symbol.toUpperCase() === \"BNB\" && !asset.contract_address) {\r\n      // Native BNB transfer\r\n      const result = await sendBnb(hotKey, locked.destination_address, locked.amount);\r\n      txHash = result.txHash;\r\n    } else {\r\n      // BEP-20 token transfer\r\n      const tokenAddr = asset.contract_address ?? getTokenAddress(asset.symbol);\r\n      if (!tokenAddr) {\r\n        await markFailed(sql, locked, `no_contract_address_for_${asset.symbol}`);\r\n        return;\r\n      }\r\n      const result = await sendToken(tokenAddr, hotKey, locked.destination_address, locked.amount, asset.decimals);\r\n      txHash = result.txHash;\r\n    }\r\n  } catch (e) {\r\n    const reason = e instanceof Error ? e.message : String(e);\r\n    await markFailed(sql, locked, reason);\r\n    return;\r\n  }\r\n\r\n  // ── 4. Confirm — record hash, consume hold, journal, notify ──\r\n  await sql.begin(async (tx) => {\r\n    const txSql = tx as unknown as typeof sql;\r\n\r\n    await txSql`\r\n      UPDATE ex_withdrawal_request\r\n      SET status = 'confirmed', tx_hash = ${txHash}, updated_at = now()\r\n      WHERE id = ${locked.id}\r\n    `;\r\n\r\n    // Consume the hold (funds are gone on-chain)\r\n    if (locked.hold_id) {\r\n      await txSql`\r\n        UPDATE ex_hold\r\n        SET status = 'consumed', remaining_amount = 0, released_at = now()\r\n        WHERE id = ${locked.hold_id} AND status = 'active'\r\n      `;\r\n    }\r\n\r\n    // Settlement journal entry: debit user account, credit system (balanced).\r\n    // The hold was reserving these funds; now we finalize the debit.\r\n    const systemAcct = await txSql<{ id: string }[]>`\r\n      INSERT INTO ex_ledger_account (user_id, asset_id)\r\n      VALUES (${SYSTEM_USER_ID}::uuid, ${locked.asset_id}::uuid)\r\n      ON CONFLICT (user_id, asset_id) DO UPDATE SET user_id = EXCLUDED.user_id\r\n      RETURNING id\r\n    `;\r\n\r\n    const userAcct = await txSql<{ id: string }[]>`\r\n      SELECT id FROM ex_ledger_account\r\n      WHERE user_id = ${locked.user_id}::uuid AND asset_id = ${locked.asset_id}::uuid\r\n      LIMIT 1\r\n    `;\r\n\r\n    if (userAcct.length > 0 && systemAcct.length > 0) {\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      const entryRows = await (txSql as any)<{ id: string }[]>`\r\n        INSERT INTO ex_journal_entry (type, reference, metadata_json)\r\n        VALUES (\r\n          'withdrawal_settlement',\r\n          ${\"withdrawal:\" + locked.id},\r\n          ${{ withdrawal_id: locked.id, tx_hash: txHash, asset: asset.symbol }}::jsonb\r\n        )\r\n        RETURNING id\r\n      `;\r\n      const entryId = entryRows[0]!.id;\r\n\r\n      await txSql`\r\n        INSERT INTO ex_journal_line (entry_id, account_id, asset_id, amount)\r\n        VALUES\r\n          (${entryId}, ${userAcct[0]!.id}, ${locked.asset_id}::uuid, (${locked.amount}::numeric) * -1),\r\n          (${entryId}, ${systemAcct[0]!.id}, ${locked.asset_id}::uuid, (${locked.amount}::numeric))\r\n      `;\r\n    }\r\n\r\n    await enqueueOutbox(txSql, {\r\n      topic: \"ex.withdrawal.confirmed\",\r\n      aggregate_type: \"withdrawal\",\r\n      aggregate_id: locked.id,\r\n      payload: {\r\n        withdrawal_id: locked.id,\r\n        user_id: locked.user_id,\r\n        tx_hash: txHash,\r\n        asset_symbol: asset.symbol,\r\n        amount: locked.amount,\r\n      },\r\n    });\r\n\r\n    await createNotification(txSql, {\r\n      userId: locked.user_id,\r\n      type: \"withdrawal_completed\",\r\n      title: \"Withdrawal Confirmed\",\r\n      body: `Your withdrawal of ${locked.amount} ${asset.symbol} has been confirmed. TX: ${txHash.slice(0, 10)}…`,\r\n      metadata: { withdrawalId: locked.id, txHash },\r\n    });\r\n  });\r\n}\r\n\r\n// ── Helpers ──────────────────────────────────────────────────────────\r\n\r\nasync function markFailed(sql: Sql, w: WithdrawalRow, reason: string): Promise<void> {\r\n  await sql.begin(async (tx) => {\r\n    const txSql = tx as unknown as typeof sql;\r\n\r\n    await txSql`\r\n      UPDATE ex_withdrawal_request\r\n      SET status = 'failed', failure_reason = ${reason}, updated_at = now()\r\n      WHERE id = ${w.id}\r\n    `;\r\n\r\n    // Release the hold so the user can retry\r\n    if (w.hold_id) {\r\n      await txSql`\r\n        UPDATE ex_hold\r\n        SET status = 'released', released_at = now()\r\n        WHERE id = ${w.hold_id} AND status = 'active'\r\n      `;\r\n    }\r\n\r\n    await enqueueOutbox(txSql, {\r\n      topic: \"ex.withdrawal.failed\",\r\n      aggregate_type: \"withdrawal\",\r\n      aggregate_id: w.id,\r\n      payload: {\r\n        withdrawal_id: w.id,\r\n        user_id: w.user_id,\r\n        failure_reason: reason,\r\n      },\r\n    });\r\n\r\n    await createNotification(txSql, {\r\n      userId: w.user_id,\r\n      type: \"system\",\r\n      title: \"Withdrawal Failed\",\r\n      body: `Your withdrawal of ${w.amount} could not be completed: ${reason}`,\r\n      metadata: { withdrawalId: w.id, failureReason: reason },\r\n    });\r\n  });\r\n}\r\n","import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setManifestsSingleton } from \"next/dist/esm/server/app-render/manifests-singleton\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/exchange/admin/withdrawals/[id]/broadcast/route\",\n        pathname: \"/api/exchange/admin/withdrawals/[id]/broadcast\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/src/app/api/exchange/admin/withdrawals/[id]/broadcast/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/exchange/admin/withdrawals/[id]/broadcast/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext, silenceLog)=>routeModule.onRequestError(req, error, errorContext, silenceLog, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        const silenceLog = false;\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, silenceLog, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            const silenceLog = false;\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            }, silenceLog, routerServerContext);\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","/**\r\n * POST /api/exchange/admin/withdrawals/[id]/broadcast\r\n *\r\n * Admin-triggered manual broadcast of an approved withdrawal.\r\n * The outbox worker handles this automatically, but admins may\r\n * need to manually trigger a retry or expedite a withdrawal.\r\n */\r\nimport { z } from \"zod\";\r\n\r\nimport { getSql } from \"@/lib/db\";\r\nimport { apiError, apiZodError } from \"@/lib/api/errors\";\r\nimport { responseForDbError } from \"@/lib/dbTransient\";\r\nimport { requireAdminForApi } from \"@/lib/auth/admin\";\r\nimport { logRouteResponse } from \"@/lib/routeLog\";\r\nimport { writeAuditLog, auditContextFromRequest } from \"@/lib/auditLog\";\r\nimport { handleWithdrawalBroadcast } from \"@/lib/outbox/handlers/exchangeWithdrawalBroadcast\";\r\n\r\nexport const runtime = \"nodejs\";\r\nexport const dynamic = \"force-dynamic\";\r\n\r\nconst idSchema = z.string().uuid();\r\n\r\nexport async function POST(request: Request, { params }: { params: Promise<{ id: string }> }) {\r\n  const startMs = Date.now();\r\n  const sql = getSql();\r\n  const admin = await requireAdminForApi(sql, request);\r\n  if (!admin.ok) return admin.response;\r\n  const { id } = await params;\r\n\r\n  try {\r\n    idSchema.parse(id);\r\n  } catch (e) {\r\n    return apiZodError(e) ?? apiError(\"invalid_input\");\r\n  }\r\n\r\n  // Pre-check: withdrawal must exist and be approved\r\n  const rows = await sql<{ id: string; status: string }[]>`\r\n    SELECT id, status\r\n    FROM ex_withdrawal_request\r\n    WHERE id = ${id}\r\n    LIMIT 1\r\n  `;\r\n\r\n  if (rows.length === 0) {\r\n    return apiError(\"not_found\", { status: 404 });\r\n  }\r\n\r\n  const w = rows[0]!;\r\n\r\n  // Idempotency: if already progressed, just return current state.\r\n  if (w.status === \"broadcasted\" || w.status === \"confirmed\" || w.status === \"failed\") {\r\n    const final = await sql<{ status: string; tx_hash: string | null }[]>`\r\n      SELECT status, tx_hash\r\n      FROM ex_withdrawal_request\r\n      WHERE id = ${id}\r\n    `;\r\n    const response = Response.json({\r\n      ok: true,\r\n      withdrawal_id: id,\r\n      status: final[0]?.status ?? w.status,\r\n      tx_hash: final[0]?.tx_hash ?? null,\r\n    });\r\n    logRouteResponse(request, response, { startMs, meta: { withdrawalId: id, idempotent: true } });\r\n    return response;\r\n  }\r\n\r\n  if (w.status !== \"approved\") {\r\n    return apiError(\"trade_state_conflict\", {\r\n      status: 409,\r\n      details: { current_status: w.status, message: \"Only approved withdrawals can be broadcast\" },\r\n    });\r\n  }\r\n\r\n  try {\r\n    await handleWithdrawalBroadcast(sql, { withdrawalId: id });\r\n\r\n    // Re-fetch to get final status\r\n    const final = await sql<{ status: string; tx_hash: string | null }[]>`\r\n      SELECT status, tx_hash\r\n      FROM ex_withdrawal_request\r\n      WHERE id = ${id}\r\n    `;\r\n\r\n    const response = Response.json({\r\n      ok: true,\r\n      withdrawal_id: id,\r\n      status: final[0]?.status ?? \"unknown\",\r\n      tx_hash: final[0]?.tx_hash ?? null,\r\n    });\r\n\r\n    logRouteResponse(request, response, { startMs, meta: { withdrawalId: id } });\r\n\r\n    try {\r\n      await writeAuditLog(sql, {\r\n        actorType: \"admin\",\r\n        action: \"withdrawal.broadcast\",\r\n        resourceType: \"withdrawal\",\r\n        resourceId: id,\r\n        ...auditContextFromRequest(request),\r\n        detail: {\r\n          final_status: final[0]?.status,\r\n          tx_hash: final[0]?.tx_hash,\r\n        },\r\n      });\r\n    } catch { /* audit log failure must not block response */ }\r\n\r\n    return response;\r\n  } catch (e) {\r\n    const resp = responseForDbError(\"exchange.admin.withdrawals.broadcast\", e);\r\n    if (resp) return resp;\r\n    throw e;\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","ignoreList":[13]}